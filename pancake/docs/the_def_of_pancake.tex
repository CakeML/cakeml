%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:

% \documentclass[graybox,envcountsect]{SVMonoEnhanced}
\documentclass[a4paper]{amsbook}

\usepackage{amsfonts}
\usepackage{amsbooka}

\usepackage{fontspec}
\newfontfamily{\emojifont}{Noto Emoji}

\usepackage{twemojis}

% \usepackage{amsrefs}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{xypic}
\usepackage{wallpaper}
\usepackage{listings}
\usepackage{float}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}

\lstdefinelanguage{pancakeAbs}%
{morekeywords={Skip,Dec,Assign,Store,StoreByte,Seq,If,While,Break,Continue,Call,ExtCall,Raise,Return,Tick},%
  basicstyle=\ttfamily}

\lstdefinelanguage{pancakeConcrete}%
{morekeywords={skip,str,strb,if,else,while,break,continue,raise,return,tick,var,in,with,handle,lds,ldb,@base,true,false},%
  basicstyle=\ttfamily}

\begin{document}

\ThisLRCornerWallPaper{1.1}{cover-bg.png}~

\title{The definition of Standard Pancake\footnote{Where a ``Standard Pancake'' is understood not to include toppings or syrup.}}

\date{March 2023}

% Authors and corresponding address tags.
\author[bnott]{Ben Nott} \email{b.nott@student.unsw.edu.au} \address{UNSW, Sydney}

\subjclass[2010]{Primary Programming languages; Secondary Semantics}
\keywords{Pancake,interaction tree,semantics,imperative,device driver}

% \university{The University of New South Wales,\\Sydney}
% \unilogo{unsw-logo-landscape.png}
\maketitle

\frontmatter

\section*{Preface}
\label{sec:preface}

Pancake is an imperative programming language designed for the creation of formally verified device drivers. The language is built upon the CakeML project, which provides a verified implementation of a substantial subset of Standard ML.

\tableofcontents
\setcounter{secnumdepth}{1}
% \listoffigures
% \listoflistings
\setcounter{secnumdepth}{0}

\mainmatter

\chapter{Introduction}
\label{cha:introduction}

\section{The language}
\label{sec:language}

Pancake is an imperative programming language intended for the development of formally verified device drivers.

\section{File naming}
\label{sec:file-naming}

The names of Pancake source files \emph{must} be suffixed with one of
\begin{enumerate}
  \item \verb|.p|
  \item \verb|.|{\Huge\texttwemoji{pancakes}}\footnote{Where the symbol is the ``Pancakes'' emoji represented by the UTF-8 codepoint \texttt{1F95E}.};
\end{enumerate}
chosen per the support of the operating system.

\chapter{Syntax}
\label{cha:syntax}

\section{Keywords}
\label{sec:keywords}
\lstset{language=pancakeConcrete}

The following are the keywords of the syntax and thus may not be used as identifiers.

\begin{lstlisting}
  skip str strb if else while break continue
  raise return tick var in handle lds ldb @base
  true false
\end{lstlisting}

\chapter{Semantics}
\label{cha:semantics}

\section{Specification}
\label{sec:semantics-spec}

Any semantics for Pancake must adhere to the \emph{specification}; an informal description of the intention behind Pancake program behaviour.

\subsection{Expressions}
\label{sec:expressions}

\subsection{Program commands}
\label{sec:program-commands}

\lstset{language=pancakeAbs}

\subsubsection{Skip}
\label{sec:skip}

The \lstinline!Skip! command shall produce no result and effect no change of the state. Hence, this command is always valid.

\subsubsection{Variable declaration}
\label{sec:variable-declaration}

A variable declaration \lstinline!Dec v e p! is valid when the expression \lstinline!e! evaluates under the current state.

A declaration binds the result of the expression \lstinline!e! to the variable name \lstinline!v!; overwriting any previous binding of the same name, possibly in an outer scope. The program \lstinline!p! is then evaluated in a new state with the aforementioned binding present.

The final state does not contain the binding created by the declaration. However, if there was a binding to the same name in an outer scope, then the outer binding is restored in the final state.

The result of the command is the result of the evaluation of the program \lstinline!p! in the context of the new binding.

\subsubsection{Variable assignment}
\label{sec:variable-assign}

A variable assignment \lstinline!Assign v e! is valid when
\begin{enumerate}
  \item the expression \lstinline!e! evaluates under the current state, and
  \item the shape of any existing value stored at the location bound to the variable name \lstinline!v! is of the same shape as the result of evaluating the expression \lstinline!e!.
\end{enumerate}

When valid, the command never produces a result.

The final state is that of the initial state with the variable \lstinline!v! updated to contain the value of the evaluated expression \lstinline!e!.

\subsubsection{Sequential composition}
\label{sec:sequ-comp}

A sequential composition \lstinline!Seq p1 p2! is valid when the program command \lstinline!p1! is valid.

The result of the command is the result of the evaluation of \lstinline!p2! when program \lstinline!p1! does not produce a result and otherwise just the result of \lstinline!p1!.

The final state is that of the program command whose result is final for the sequential composition.

\subsubsection{Memory write}
\label{sec:memory-write}

A write to memory \lstinline!Store dst src! is valid when
\begin{enumerate}
  \item the expressions \lstinline!dst! and \lstinline!src! evaluate under the current state, and
  \item the \lstinline!dst! expression evaluates only to a valid memory address.
\end{enumerate}

A valid memory write command never produces a result.

The final state is that of the original state with the address specified by the evaluation of \lstinline!dst! updated with the value produced by the evaluation of \lstinline!src!.

% more to add here about the mem_stores func.

\subsubsection{Store byte}
\label{sec:store-byte}

\subsubsection{Program control flow}
\label{sec:program-control-flow}

\subsubsection{While loop}
\label{sec:while-loop}

\subsubsection{Function call}
\label{sec:function-call}

\subsubsection{External function call}
\label{sec:external-call}

External function calls are the principal mechanic of the Pancake Foreign Function Interface (FFI). They enable Pancake programs to call functions defined outside of the local program state.

An external call
\begin{lstlisting}
  ExtCall name conf_ptr conf_len array_ptr array_len
\end{lstlisting}
is valid when
\begin{enumerate}
  \item each of \lstinline!conf_ptr, conf_len, array_ptr, array_len! evaluate under the current state,
  \item the evaluated results of \lstinline!conf_ptr! and \lstinline!array_ptr! are readable prior to the FFI call.
\end{enumerate}

\section{Operational semantics}
\label{sec:oper-semant}

\section{ITree semantics}
\label{sec:itree-semantics}

Being a language intended for the development of device drivers, it follows that a more natural semantics would be one that captures the reactive nature of typical driver design. Thus a tree-based semantics was developed for Pancake using the coinductive and monadic datatype known as ITrees \cite{xia_executable_nodate}.

\subsection{Layout}
\label{sec:layout}

The ITree semantics is separated into three layers:
\begin{enumerate}
  \item The expression semantics.
  \item The program command semantics.
  \item The observational semantics.
\end{enumerate}

The first two layers are denotational semantics for the corresponding type of term. The last serves as the final ITree semantics for Pancake programs and captures only the notion of external events and final result and state.

\subsection{Expression semantics}
\label{sec:expression-semantics}

The \emph{expression} semantics is carried over from the Pancake big-step functional semantics. Thus a denotation for an expression is a function
\begin{equation*}
  \sem{\cdot}_{e} : \text{state} \to \alpha\ \text{v}\ \text{option}.
\end{equation*}

The definition of the expression semantics follows from that of the functional big-step semantics. Thus the definition is omitted here.

\subsection{Program command semantics}
\label{sec:progr-comm-semant-1}

The \emph{program command} semantics describes the meaning of Pancake programs in terms of ITrees. The trees carry the result of evaluation and final state.

A denotation for a program command is a function
\begin{equation*}
  \sem{\cdot}_{p} : \text{state} \to (\alpha, \beta, (\gamma\ \text{result}\ \text{option} \times \text{state}))\ \text{itree}.
\end{equation*}

We define $\sem{\cdot}_{p}$ in terms of the \verb|mrec| combinator and a \emph{recursive event handler}, \verb|h_prog|, as
\begin{equation*}
  \sem{P}_{p} = \text{\lstinline!itree\_mrec!}\ \text{\lstinline!h\_prog!}\ P.
\end{equation*}

There exists a nontrivial challenge in defining a denotational semantics with the domain of ITrees, that supports looping and function calls. To overcome this challenge, the executable nature of ITrees is leveraged to define the program command semantics in terms of a recursive event handler.

\subsubsection{Recursive event handlers}
\label{sec:event-handlers}

A function
\begin{equation*}
  h : \alpha \to (\beta, \alpha + \epsilon, \gamma)\ \text{itree},
\end{equation*}
that maps a seed of type $\alpha$ to an ITree with an event type $\alpha$, is called an \emph{recursive event handler}.

The handler \emph{raises} an event by producing a
\begin{equation*}
  \text{Vis (INL } e:\alpha \text{)}
\end{equation*}
node, indicating that the seed $e$ is to be passed again to the event handler for further processing. The handler terminates computation by producing a
\begin{equation*}
  \text{Ret}\ r
\end{equation*}
node.

Regular Vis nodes can be created in the tree by the handler producing a
\begin{equation*}
  \text{Vis}\ (\text{INR}\ e':\epsilon)
\end{equation*}
node.

The \verb|mrec| combinator \cite{xia_executable_nodate} interprets the ITree produced by the recursive event handler and unfolds it over an ITree of type
\begin{equation*}
  (\beta, \epsilon, \gamma)\ \text{itree}.
\end{equation*}

\subsubsection{Recurisve program handler}
\label{sec:recur-progr-handl}

The program command semantics is defined compositionally at the level of the recursive event handler.

Let
\begin{equation*}
  \text{\lstinline!h\_prog!} : \text{prog} \to (\alpha,\beta,(\gamma\ \text{result option} \times \text{state}))\ \text{itree},
\end{equation*}
be a function defined over the abstract syntax of program commands.

\subsection{Observational semantics}
\label{sec:observ-semant}

\bibliography{refs.bib}

\end{document}
