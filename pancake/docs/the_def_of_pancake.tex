%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:

\documentclass[graybox,envcountsect]{SVMonoEnhanced}

\usepackage{amssymb,amscd}
\usepackage{hyperref}
\usepackage{wallpaper}
\usepackage{listings}
\usepackage{float}

\bibliographystyle{acm}

% \usepackage{biblatex}
% \addbibresource{refs.bib}

\lstdefinelanguage{pancakeAbs}%
{morekeywords={Skip,Dec,Assign,Store,StoreByte,Seq,If,While,Break,Continue,Call,ExtCall,Raise,Return,Tick},%
basicstyle=\ttfamily}

\begin{document}

\ThisLRCornerWallPaper{1.1}{cover-bg.png}~
\author{Ben Nott\\ \small b.nott@student.unsw.edu.au}
\title{The definition of Standard Pancake\footnote{Where a ``Standard Pancake'' is understood not to include toppings or syrup.}}
\subtitle{}
\date{March 2023}
\university{The University of New South Wales,\\Sydney}
\unilogo{unsw-logo-landscape.png}
\maketitle

\frontmatter

\section*{Preface}
\label{sec:preface}

Pancake is an imperative programming language designed for the creation of formally verified device drivers. The language is built upon the CakeML project, which provides a verified implementation of a substantial subset of Standard ML.

\tableofcontents
\setcounter{secnumdepth}{1}
% \listoffigures
% \listoflistings
\setcounter{secnumdepth}{0}

\mainmatter

\part{Syntax}
\label{part:syntax}

\section{Concrete syntax}
\label{sec:concrete-syntax}

\section{Abstract syntax}
\label{sec:abstract-syntax}

\part{Semantics}
\label{part:semantics}

\section{Informal rules of the semantics}
\label{sec:informal-rules}

The informal rules define the intention behind the design of the individual semantics provided for Pancake. They guide the extension of existing and development of new semantics for the language. These rules however cannot be taken to be any true semantic of the language.

\subsection{Expressions}
\label{sec:expressions}

\subsection{Program commands}
\label{sec:program-commands}

\lstset{language=pancakeAbs}

\subsubsection{Skip}
\label{sec:skip}

The \lstinline!Skip! command shall produce no result and effect no change of the state. Hence, this command is always valid.

\subsubsection{Variable declaration}
\label{sec:variable-declaration}

A variable declaration \lstinline!Dec v e p! is valid when the expression \lstinline!e! evaluates under the current state.

A declaration binds the result of the expression \lstinline!e! to the variable name \lstinline!v!; overwriting any previous binding of the same name, possibly in an outer scope. The program \lstinline!p! is then evaluated in a new state with the aforementioned binding present.

The final state does not contain the binding created by the declaration. However, if there was a binding to the same name in an outer scope, then the outer binding is restored in the final state.

The result of the command is the result of the evaluation of the program \lstinline!p! in the context of the new binding.

\subsubsection{Variable assignment}
\label{sec:variable-assign}

A variable assignment \lstinline!Assign v e! is valid when
\begin{enumerate}
  \item the expression \lstinline!e! evaluates under the current state, and
  \item the shape of any existing value stored at the location bound to the variable name \lstinline!v! is of the same shape as the result of evaluating the expression \lstinline!e!.
\end{enumerate}

When valid, the command never produces a result.

The final state is that of the initial state with the variable \lstinline!v! updated to contain the value of the evaluated expression \lstinline!e!.

\subsubsection{Sequential composition}
\label{sec:sequ-comp}

A sequential composition \lstinline!Seq p1 p2! is valid when the program command \lstinline!p1! is valid.

The result of the command is the result of the evaluation of \lstinline!p2! when program \lstinline!p1! does not produce a result and otherwise just the result of \lstinline!p1!.

The final state is that of the program command whose result is final for the sequential composition.

\subsubsection{Memory write}
\label{sec:memory-write}

A write to memory \lstinline!Store dst src! is valid when
\begin{enumerate}
  \item the expressions \lstinline!dst! and \lstinline!src! evaluate under the current state, and
  \item the \lstinline!dst! expression evaluates only to a valid memory address.
\end{enumerate}

A valid memory write command never produces a result.

The final state is that of the original state with the address specified by the evaluation of \lstinline!dst! updated with the value produced by the evaluation of \lstinline!src!.

% more to add here about the mem_stores func.

\subsubsection{Store byte}
\label{sec:store-byte}

\subsubsection{Program control flow}
\label{sec:program-control-flow}

\subsubsection{While loop}
\label{sec:while-loop}

\subsubsection{Function call}
\label{sec:function-call}

\subsubsection{External function call}
\label{sec:external-call}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}

\section{Operational semantics}
\label{sec:oper-semant}

\section{ITree semantics}
\label{sec:itree-semantics}

Being a language intended for the development of device drivers, it follows that a more natural semantics would be one that captures the reactive nature of typical driver design. Thus a tree-based semantics was developed for Pancake using the coinductive and monadic datatype known as ITrees \cite{xia_executable_nodate}.

\subsection{Layout}
\label{sec:layout}

The ITree semantics is separated into three layers:
\begin{enumerate}
  \item The expression semantics.
  \item The program command semantics.
  \item The observational semantics.
\end{enumerate}

The first two layers are denotational semantics for the corresponding type of term. The last serves as the final ITree semantics for Pancake programs and captures only the notion of external events and final result and state.

\subsection{Expression semantics}
\label{sec:expression-semantics}

The \emph{expression} semantics is carried over from the Pancake big-step functional semantics. Thus a denotation for an expression is a function
\begin{equation*}
  \sem{\cdot}_{e} : \text{state} \to \alpha\ \text{v}\ \text{option}.
\end{equation*}

The definition of the expression semantics follows from that of the functional big-step semantics. Thus the definition is omitted here.

\subsection{Program command semantics}
\label{sec:progr-comm-semant-1}

The \emph{program command} semantics describes the meaning of Pancake programs in terms of ITrees. The trees carry the result of evaluation and final state.

A denotation for a program command is a function
\begin{equation*}
  \sem{\cdot}_{p} : \text{state} \to (\alpha, \beta, (\gamma\ \text{result}\ \text{option} \times \text{state}))\ \text{itree}.
\end{equation*}

We define $\sem{\cdot}_{p}$ in terms of the \verb|mrec| combinator and a \emph{recursive event handler} as follows.
\begin{figure}[H]
  \centering
  \begin{align*}
    \sem{\cdot}_{p} =
  \end{align*}
  \caption{Definition of program statement semantics}
  \label{fig:sem_itree_prog}
\end{figure}

There exists a nontrivial challenge in defining a denotational semantics with the domain of ITrees, that supports looping and function calls. To overcome this challenge, the executable nature of ITrees is leveraged to define the program command semantics in terms of a recursive event handler.

\subsubsection{Recursive event handlers}
\label{sec:event-handlers}

\emph{Recursive event handlers} are functions
\begin{equation*}
  h : \alpha \to (\beta, \alpha + \epsilon, \gamma)\ \text{itree},
\end{equation*}
that map a seed of type $\alpha$ to an ITree with an event type $\alpha$.

The handler \emph{raises} an event by producing a $\text{Vis}\ (\text{INL}\ e)$ node, indicating that the seed $e$ is to be passed again to the event handler for further processing. The handler terminates computation by producing a $\text{Ret}\ r$ node. Regular Vis nodes can be created in the tree by the handler producing a $\text{Vis}\ (\text{INR}\ e')$ node.

The \verb|mrec| combinator \cite{xia_executable_nodate} interprets the ITree produced by the recursive event handler and unfolds it over a regular ITree of type $(\beta, \epsilon, \gamma)\ \text{itree}$.


\subsection{Observational semantics}
\label{sec:observ-semant}

\bibliography{refs.bib}

\end{document}
