
@article{xia_executable_nodate,
	title = {Executable Denotational Semantics With Interaction Trees},
	abstract = {Interaction trees are a representation of effectful and reactive systemsdesigned to be implemented in a proof assistant such as Coq. They are equipped with a rich algebra of combinators to construct recursive and effectful computations and to reason about them equationally. Interaction trees are also an executable structure, notably via extraction, which enables testing and directly developing executable programs in Coq. To demonstrate the usefulness of interaction trees, two applications are presented. First, I develop a novel approach to verify a compiler from a simple imperative language to assembly, by proving a semantic preservation theorem which is termination-sensitive, using an equational proof. Second, I present a framework of concurrent objects, inheriting the modularity, compositionality, and executability of interaction trees. Leveraging that framework, I formally prove the correctness of a transactionally predicated map, using a novel approach to reason about objects combining the notions of linearizability and strict serializability, two well-known correctness conditions for concurrent objects.},
	pages = {107},
	author = {Xia, Li-Yao},
	langid = {english},
	file = {Xia - Executable Denotational Semantics With Interaction.pdf:/home/ben/Zotero/storage/ZPBLFC4N/Xia - Executable Denotational Semantics With Interaction.pdf:application/pdf},
}

@inproceedings{owens_functional_2016,
	location = {Berlin, Heidelberg},
	title = {Functional Big-Step Semantics},
	isbn = {978-3-662-49498-1},
	doi = {10.1007/978-3-662-49498-1_23},
	series = {Lecture Notes in Computer Science},
	abstract = {When doing an interactive proof about a piece of software, it is important that the underlying programming language’s semantics does not make the proof unnecessarily difficult or unwieldy. Both small-step and big-step semantics are commonly used, and the latter is typically given by an inductively defined relation. In this paper, we consider an alternative: using a recursive function akin to an interpreter for the language. The advantages include a better induction theorem, less duplication, accessibility to ordinary functional programmers, and the ease of doing symbolic simulation in proofs via rewriting. We believe that this style of semantics is well suited for compiler verification, including proofs of divergence preservation. We do not claim the invention of this style of semantics: our contribution here is to clarify its value, and to explain how it supports several language features that might appear to require a relational or small-step approach. We illustrate the technique on a simple imperative language with C-like for-loops and a break statement, and compare it to a variety of other approaches. We also provide {ML} and lambda-calculus based examples to illustrate its generality.},
	pages = {589--615},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Owens, Scott and Myreen, Magnus O. and Kumar, Ramana and Tan, Yong Kiam},
	editor = {Thiemann, Peter},
	date = {2016},
	langid = {english},
	keywords = {Interactive Proof, Label Transition System, Recursive Call, Relational Semantic, Type Soundness},
	file = {Full Text PDF:/home/ben/Zotero/storage/92ZGPYVX/Owens et al. - 2016 - Functional Big-Step Semantics.pdf:application/pdf},
}
