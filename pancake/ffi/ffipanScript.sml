(*
  Generated by Lem from ffi.lem.
*)

open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "ffipan"

(*
  An oracle says how to perform an ffi call based on its internal
  state, represented by the type variable 'ffi.
*)
(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)


(* supported prmitive C values  *)

val _ = Datatype `
 c_primv = C_boolv bool
         | C_intv int`;


val _ = Datatype `
c_array_conf =
<| mutable     : bool
 ; with_length : bool
 |>`

(* C types for input/output arguments *)
val _ = Datatype `
 c_type = C_bool | C_int | C_array c_array_conf`;

(* C values *)
val _ = Datatype `
 c_value = C_primv c_primv | C_arrayv (word8 list)`;

val _ = Datatype `
c_funsig =
<| mlname      : string
 ; cname       : string
 ; retty       : c_type option (* NONE represents unit *)
 ; args        : c_type list
|>`


val _ = Datatype `
 ffi_outcome = FFI_failed | FFI_diverged`;

val _ = Datatype `
 oracle_result = Oracle_return 'ffi (word8 list list) (c_primv option)
               | Oracle_final ffi_outcome`;


val _ = type_abbrev((*  'ffi *) "oracle_function" , ``: 'ffi -> c_value list -> num list list -> 'ffi oracle_result``);
val _ = type_abbrev((*  'ffi *) "oracle" , ``: string -> 'ffi oracle_function``);

(* An I/O event, IO_event s bytes bytes2, represents the call of FFI function s with
* immutable input bytes and mutable input map fst bytes2,
* returning map snd bytes2 in the mutable array. TODO: update *)

val _ = Datatype `
 io_event = IO_event string (c_value list) (word8 list list) (c_primv option)`;


val _ = Datatype `
 final_event = Final_event string (c_value list) ffi_outcome`;


val _ = Datatype `
(*  'ffi *) ffi_state =
<| oracle      : 'ffi oracle
 ; ffi_state   : 'ffi
 ; io_events   : io_event list
 ; signatures  : c_funsig list
 |>`;


val _ = Define `
 ((initial_ffi_state:(string -> 'ffi oracle_function) -> 'ffi -> c_funsig list -> 'ffi ffi_state) oc ffi sigs =
 (<| oracle      := oc
 ; ffi_state   := ffi
 ; io_events   := ([])
 ; signatures  := sigs
 |>))`;


val _ = Define
  `debug_sig =
     <|mlname:="";
       cname:="ffi";
       retty := NONE;
       args := [C_array <|with_length := T; mutable := F|>;
                C_array <|with_length := T; mutable := T|>] |>`

val _ = Define `
  valid_ffi_name n sign st = (FIND (λsg. sg.mlname = n) st.signatures = SOME sign)
`


val is_mutty = Define `
 is_mutty ty =
  (case ty of C_array c => c.mutable
   | _ => F)
 `

val _ = Define `arg_ok t cv =
  case cv of
    C_arrayv _ => (case t of C_array _ => T | _ => F)
  | C_primv(C_boolv _) => (t = C_bool)
  | C_primv(C_intv _) => (t = C_int)
`

val _ = Define `args_ok cts cargs = LIST_REL arg_ok cts cargs`

val _ = Define `ret_ok t v =
(((t = NONE) /\ (v = NONE)) \/ (OPTION_MAP2 arg_ok t (OPTION_MAP C_primv v) = SOME T))`

val _ = Define `
  als_ok btl alsl =
    EVERY (λasl. ∀i j. MEM i asl /\ MEM j asl /\ i < LENGTH btl /\ j < LENGTH btl ==> (EL i btl = EL j btl)) alsl
`

val _ = Define `
 mut_len cts cargs =
   MAP LENGTH (MAP ((\v. case v of
    | C_arrayv bl => bl) o SND)
   (FILTER (is_mutty o FST) (ZIP (cts,cargs))))
`

val _ = Define `
  ffi_oracle_ok st =
  (!n sign cargs st' ffi newargs retv als.
           valid_ffi_name n sign st
           /\ args_ok sign.args cargs
           /\ (st.oracle n ffi cargs als = Oracle_return st' newargs retv)
           /\ n <> ""
           ==> ret_ok sign.retty retv /\ als_ok newargs als
               /\ (mut_len sign.args cargs = (MAP LENGTH newargs)))
    `

val _ = Datatype `
 ffi_result = FFI_return ('ffi ffi_state)  (word8 list list) (c_primv option)
            | FFI_final final_event`;


val _ = Define `
 call_FFI st n sign cargs als =
   if ~ (n = "") then
     case st.oracle n st.ffi_state cargs als of
         Oracle_return ffi' newargs retv =>
           if ret_ok sign.retty retv /\ als_ok newargs als /\ (mut_len sign.args cargs = (MAP LENGTH newargs)) then
              SOME (FFI_return (st with<| ffi_state := ffi'
                                   ; io_events := st.io_events ++ [IO_event n cargs newargs retv]
                         |>) newargs retv)
           else NONE
        | Oracle_final outcome => SOME (FFI_final (Final_event n cargs outcome))
  else SOME (FFI_return st [] NONE)`;

val _ = Define
`get_mut_args cts cargs = MAP SND (FILTER (is_mutty o FST) (ZIP(cts,cargs)))
`
val _ = Define `
  als_args cts args =
  (MAP
    (MAP FST o λ(ct,v).
      FILTER
          (λ(n',ct',v'). v = v')
          (MAPi $,
            (FILTER (is_mutty o FST) (ZIP (cts,args))))
    )
    (FILTER (is_mutty o FST) (ZIP (cts,args)))
  )
`

val _ = Datatype `
 outcome = Success | Resource_limit_hit | FFI_outcome final_event`;


(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
val _ = Datatype `
 behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge (io_event llist)
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate outcome (io_event list)
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail`;


(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics as follows. *)

(*val trace_oracle : oracle (llist io_event)*)
val _ = Define `
 ((trace_oracle:string ->(io_event)llist ->(c_value)list ->((io_event)llist)oracle_result) s io_trace args=
   ((case LHD io_trace of
    SOME (IO_event s' args' newargs retv) =>
      if (s = s') /\ (args = args') then
        Oracle_return (THE (LTL io_trace)) newargs retv
      else Oracle_final FFI_failed
  | _ => Oracle_final FFI_failed
  )))`;

val _ = export_theory()
