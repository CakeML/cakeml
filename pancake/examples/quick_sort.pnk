
/* Subdivide the region base_addr[x ..< y], returning z such that
   everything in [x ..< z] is <= piv, everything in [z ..< y] is >= piv,
   and z is not x or y if possible. */

fun partition (1 base_addr, 1 piv, 1 x, 1 y) {
  var xt = x;
  var yt = y - 1;
  while (xt < yt) {
    var xa = base_addr + (xt * 8);
    var ya = base_addr + (yt * 8);
    var xv = lds 1 xa;
    var yv = lds 1 ya;
    if ((xv < piv) & (yv < piv)) {
      xt = xt + 1;
    }
    else { if ((xv > piv) & (yv > piv)) {
      yt = yt - 1;
    }
    else {
      if (xv > yv) {
        stw xa, yv;
        stw ya, xv;
      }
      xt = xt + 1;
      yt = yt - 1;
    } }
    xt = xt + 1;
  }
  var xa = base_addr + (xt * 8);
  var xv = lds 1 xa;
  if (xv < piv) {
    return xt + 1;
  }
  else {
    return xt;
  }
}


fun do_sort (1 base_addr, 1 x, 1 y) {
  if ((y - x) <= 1) {
    return 0;
  }
  else {
    var piv = lds 1 (base_addr + (x * 8));
    var z = 0;
    z = partition (base_addr, piv, x, y);
    do_sort (base_addr, x, z);
    do_sort (base_addr, z, y);
    return 0;
  }
}

fun sort (1 base_addr, 1 len) {
  do_sort (base_addr, 0, len);
}


