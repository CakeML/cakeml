(*
  Definition of the fp_pattern language for Icing optimizations
*)

open import Pervasives
open import Lib
open import FpValTree

type fp_pat =
     | Word of word64
     | Var of nat
     | Unop of fp_uop * fp_pat
     | Binop of fp_bop * fp_pat * fp_pat
     | Terop of fp_top * fp_pat * fp_pat * fp_pat
     | Pred of fp_pred * fp_pat
     | Cmp of fp_cmp * fp_pat * fp_pat
     | Scope of sc * fp_pat

(* Substitutions are maps (paired lists) from numbers to 'a *)
type subst 'v = list (nat * 'v)

val substLookup: forall 'v. subst 'v -> nat -> maybe 'v
let rec substLookup ([]) n = Nothing
    and substLookup ((m, v)::s) n =
      if (m = n) then Just v else substLookup s n
declare termination_argument substLookup = automatic

val substUpdate: forall 'v. nat -> 'v -> subst 'v -> maybe (subst 'v)
let rec substUpdate n v1 [] = Nothing
    and substUpdate n v1 ((m,v2)::s) =
      if (n = m) then Just ((m,v1)::s)
      else
        match (substUpdate n v1 s) with
        | Nothing -> Nothing
        | Just sNew -> Just ((m,v2)::sNew)
        end

val substAdd: forall 'v. nat -> 'v -> subst 'v -> subst 'v
let rec substAdd n v s =
    match (substUpdate n v s) with
    | Just sNew -> sNew
    | Nothing -> (n,v)::s
    end

(* Matching a fp_pattern with the top-level of a value tree,
  if a matching exists an option with a substitution is returned.
  The matcher takes an additional substituion as argument to make sure
  that we do not double match a fp_pattern to different expressions
*)
val matchValTree: fp_pat -> fp_val -> subst fp_val -> maybe (subst fp_val)
let rec matchValTree (Word w1) (Fp_const w2) s =
    if (w1 = w2) then Just s else Nothing
    and matchValTree (Var n) v s =
      match substLookup s n with
      | Just v1 -> if v1 = v then Just s else Nothing
      | Nothing -> Just (substAdd n v s)
      end
    and matchValTree (Unop op1 p) (Fp_uop op2 v) s =
      if (op1 = op2)
      then matchValTree p v s
      else Nothing
    and matchValTree (Binop b1 p1 p2) (Fp_bop b2 v1 v2) s =
      if (b1 = b2)
      then
        match matchValTree p1 v1 s with
        | Nothing -> Nothing
        | Just s1 -> matchValTree p2 v2 s1
        end
      else Nothing
    and matchValTree (Terop t1 p1 p2 p3) (Fp_top t2 v1 v2 v3) s =
      if (t1 = t2)
      then
        match matchValTree p1 v1 s with
        | Nothing -> Nothing
        | Just s1 ->
          match matchValTree p2 v2 s1 with
          | Nothing -> Nothing
          | Just s2 -> matchValTree p3 v3 s2
          end
        end
      else Nothing
    and matchValTree (Scope sc1 p) (Fp_sc sc2 v) s =
      if sc1 = sc2 then matchValTree p v s else Nothing
    and matchValTree (Pred pred1 p) (Fp_pred pred2 v) s =
      if (pred1 = pred2) then matchValTree p v s else Nothing
    and matchValTree (Cmp cmp1 p1 p2) (Fp_cmp cmp2 v1 v2) s =
      if (cmp1 = cmp2)
      then
        match matchValTree p1 v1 s with
        | Nothing -> Nothing
        | Just s1 -> matchValTree p2 v2 s1
        end
      else Nothing
    and matchValTree _ _ s = Nothing

(* Instantiate a given fp_pattern with a substitution into a value tree *)
val instValTree: fp_pat -> subst fp_val -> maybe fp_val
let rec instValTree (Word w) s = Just (Fp_const w)
    and instValTree (Var n) s = substLookup s n
    and instValTree (Unop u p) s =
      match instValTree p s with
      | Nothing -> Nothing
      | Just v -> Just (Fp_uop u v)
      end
    and instValTree (Binop op p1 p2) s =
      match (instValTree p1 s, instValTree p2 s) with
      | (Just v1, Just v2) -> Just (Fp_bop op v1 v2)
      | (_, _) -> Nothing
      end
    and instValTree (Terop op p1 p2 p3) s =
      match (instValTree p1 s, instValTree p2 s , instValTree p3 s) with
      | (Just v1, Just v2, Just v3) -> Just (Fp_top op v1 v2 v3)
      | (_, _, _) -> Nothing
      end
    and instValTree (Scope sc p) s =
      match instValTree p s with
      | Nothing -> Nothing
      | Just v -> Just (Fp_sc sc v)
      end
    and instValTree (Pred pr p1) s =
      match instValTree p1 s with
      | Nothing -> Nothing
      | Just v -> Just (Fp_pred pr v)
      end
    and instValTree (Cmp cmp p1 p2) s =
      match (instValTree p1 s, instValTree p2 s) with
      | (Just v1, Just v2) -> Just (Fp_cmp cmp v1 v2)
      | (_, _) -> Nothing
      end
    and instValTree _ _ = Nothing

(* Define a floating-point rewrite as a pair of a source and target fp_pattern *)
type fp_rw = (fp_pat * fp_pat)

(** Rewriting on value trees is done in the semantics by picking a fp_path
  that walks down the value tree structure and then applies the rewrite in place
  if it matches **)

(* Datatype for fp_paths into a value tree. Here is the leaf node meaning that the
  rewrite should be applied *)
type fp_path = | Left of fp_path | Right of fp_path | Center of fp_path | Here

val maybe_map: forall 'v. ('v -> 'v) -> maybe 'v -> maybe 'v
let rec maybe_map f Nothing = Nothing
    and maybe_map f (Just res) = Just (f res)

(* Function rwFp_pathValTree b rw p v recurses through value tree v using fp_path p
  until p = Here or no further recursion is possible because of a mismatch.
  In case of a mismatch the function simply returns Nothing.
  Flag b is used to track whether we have passed an `opt` annotation allowing
  optimizations to be applied.
  Only if b is true, and p = Here, the rewrite rw is applied. *)
val rwFp_pathValTree: bool -> fp_rw -> fp_path -> fp_val -> maybe fp_val
let rec rwFp_pathValTree false rw Here v = Nothing
    and rwFp_pathValTree true rw Here v =
      let (lhs, rhs) = rw in
      match matchValTree lhs v [] with
        | Nothing -> Nothing
        | Just s -> instValTree rhs s
      end
    and rwFp_pathValTree b rw (Left p) (Fp_bop op v1 v2) =
      maybe_map (fun v1 -> Fp_bop op v1 v2) (rwFp_pathValTree b rw p v1)
    and rwFp_pathValTree b rw (Right p) (Fp_bop op v1 v2) =
      maybe_map (fun v2 -> Fp_bop op v1 v2) (rwFp_pathValTree b rw p v2)
    and rwFp_pathValTree b rw (Center p) (Fp_uop op v1) =
      maybe_map (fun v -> Fp_uop op v) (rwFp_pathValTree b rw p v1)
    and rwFp_pathValTree b rw (Left p) (Fp_top op v1 v2 v3) =
      maybe_map (fun v1 -> Fp_top op v1 v2 v3) (rwFp_pathValTree b rw p v1)
    and rwFp_pathValTree b rw (Center p) (Fp_top op v1 v2 v3) =
      maybe_map (fun v2 -> Fp_top op v1 v2 v3) (rwFp_pathValTree b rw p v2)
    and rwFp_pathValTree b rw (Right p) (Fp_top op v1 v2 v3) =
      maybe_map (fun v3 -> Fp_top op v1 v2 v3) (rwFp_pathValTree b rw p v3)
    and rwFp_pathValTree b rw (Center p) (Fp_sc sc v) =
      maybe_map (fun v -> Fp_sc sc v) (rwFp_pathValTree ((sc = Opt) || b) rw p v)
    and rwFp_pathValTree b rw (Center p) (Fp_pred pr v) =
      maybe_map (fun v -> Fp_pred pr v) (rwFp_pathValTree b rw p v)
    and rwFp_pathValTree b rw (Left p) (Fp_cmp cmp v1 v2) =
      maybe_map (fun v1 -> Fp_cmp cmp v1 v2) (rwFp_pathValTree b rw p v1)
    and rwFp_pathValTree b rw (Right p) (Fp_cmp cmp v1 v2) =
      maybe_map (fun v2 -> Fp_cmp cmp v1 v2) (rwFp_pathValTree b rw p v2)
    and rwFp_pathValTree _ _ _ _ = Nothing

(* Datatype holding a single rewrite application in the form of a fp_path into the
  value tree and a number giving the index of the rewrite to be used *)
type rewrite_app = | RewriteApp of fp_path * nat (* which rewrite rule *)

val nth: forall 'v. list 'v -> nat -> maybe 'v
let rec nth [] n = Nothing
    and nth (x::xs) n =
      if (n = 0) then Nothing
      else if (n = 1) then Just x
      else nth xs (n-1)

(* rwAllValTree rwApps canOpt rws v applies all the rewrite_app's in rwApps to
    value tree v using rwFp_pathValTree *)
val rwAllValTree: list rewrite_app -> bool -> list fp_rw -> fp_val -> maybe fp_val
let rec rwAllValTree [] canOpt rws v = Just v
    and rwAllValTree ((RewriteApp p n)::rs) canOpt rws v =
      match nth rws n with
      | Nothing -> Nothing
      | Just rw ->
        match rwFp_pathValTree canOpt rw p v with
        | Nothing -> Nothing
        | Just vNew -> rwAllValTree rs canOpt rws vNew
        end
      end