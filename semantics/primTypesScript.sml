(*Generated by Lem from primTypes.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory astTheory namespaceTheory ffiTheory semanticPrimitivesTheory evaluateTheory;

val _ = numLib.prefer_num();



val _ = new_theory "primTypes"

(*open import Pervasives*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)
(*open import Namespace*)
(*open import Lib*)
(*open import Evaluate*)

(* The ordering in the following is important. The stamps generated from the
   exceptions and types must match those in semanticPrimitives *)
(*val prim_types_program : list dec*)
val _ = Define `
 (prim_types_program=  
 ([Dexn unknown_loc "Bind" [];
   Dexn unknown_loc "Chr" [];
   Dexn unknown_loc "Div" [];
   Dexn unknown_loc "Subscript" [];
   Dtype unknown_loc [([], "bool", [("false", []); ("true", [])])];
   Dtype unknown_loc [(["'a"], "list", [("nil", []); ("::", [Atvar "'a"; Atapp [Atvar "'a"] (Short "list")]) ])];
   Dtype unknown_loc [(["'a"], "option", [("NONE", []);("SOME", [Atvar "'a"]) ])] ]))`;


(*val add_to_sem_env :
  forall 'ffi. Eq 'ffi => (state 'ffi * sem_env v) -> list dec -> maybe (state 'ffi * sem_env v)*)
val _ = Define `
 (add_to_sem_env (st, env) prog=  
 ((case evaluate_decs st env prog of
    (st', Rval env') => SOME (st', extend_dec_env env' env)
  | _ => NONE
  )))`;


(*val prim_sem_env : forall 'ffi. Eq 'ffi => ffi_state 'ffi -> maybe (state 'ffi * sem_env v)*)
val _ = Define `
 (prim_sem_env ffi=  
 (add_to_sem_env
    (<| clock :=(( 0 : num)); ffi := ffi; refs := ([]); next_type_stamp :=(( 0 : num)); next_exn_stamp :=(( 0 : num)) |>,
     <| v := nsEmpty; c := nsEmpty |>)
        prim_types_program))`;

val _ = export_theory()

