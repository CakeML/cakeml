(*Generated by Lem from ffi.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "ffi"

(*
  An oracle says how to perform an ffi call based on its internal
  state, represented by the type variable 'ffi.
*)
(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)


(* supported prmitive C values  *)

val _ = Hol_datatype `
 c_primv = C_boolv of bool | C_intv of int`;

(* configuration of byte array arguments, mutable/immutable and with_length: information for C-code  *)

val _ = Hol_datatype `
c_array_conf =
<| mutable     : bool
 ; with_length : bool
 |>`

(* supported c_types as the input/output arguments *)
val _ = Hol_datatype `
 c_type = C_bool | C_int | C_array of c_array_conf`;

(* supported values for c_types *)
val _ = Hol_datatype `
 c_value = C_primv of c_primv | C_arrayv of word8 list`;

val _ = Hol_datatype `
c_funsig =
<| mlname      : string
 ; cname       : string
 ; retty       : c_type option (* None represents unit *)
 ; args        : c_type list   (* list of the arguments *)
|>`

(*  arg_ok :: "c_type ⇒ c_value ⇒ bool" *)
val _ = Define `arg_ok t v =
  case v of
    C_arrayv _ => (case t of C_array _ => T | _ => F)
  | C_primv(C_boolv _) => (t = C_bool)
  | C_primv(C_intv _) => (t = C_int)
`

(*   args_ok :: "c_funsig ⇒ c_value list ⇒ bool" *)
(* values should be passed in sequence of their signature *)

val _ = Define `args_ok sig args = LIST_REL arg_ok sig.args args`

(* ret_ok :: "c_type option ⇒ c_value option ⇒ bool" *)
(*  talks only about the primitive c types *)
val _ = Define `ret_ok t v =
 ((t = NONE) /\ (v = NONE)) \/ (OPTION_MAP2 arg_ok t (OPTION_MAP C_primv v) = SOME T)`


(*
(* access this function with 0 *)
(* c_type list -> num -> (num#c_type) list*)

val _ = Define `
  (ctype_idx_pr [] count = []) /\
  (ctype_idx_pr (ct::cts) count = (count, ct) :: ctype_idx_pr cts (count+1) )
`


(* byte list list -> (num#c_type) list -> (num#byte list) list *)

val _ = Define `
  (cargs_sign_tag_retr [] _ = []) /\ 
  (cargs_sign_tag_retr _ [] = []) /\ 
  (cargs_sign_tag_retr (btl::btls) (ict::icts) = 
         case SDN ict of C_array conf => if conf.mutable 
                                         then (FST ict, btl) :: cargs_sign_tag_retr btls icts)
			                 else cargs_sign_tag_retr (btl:btls) icts
			 | _ =>  cargs_sign_tag_retr (btl:btls) icts
`


(* have a function alias_ok for checking about the consistency of the returned aliases  *)
(* v list -> num list list -> bool *)

*)


val is_mutty = Define `
 is_mutty ty =
  (case ty of C_array c => c.mutable
   | _ => F)
 `
(* given lists of types and values, mutargs returns the list of mutable array-values only *)
val _ = Define `(mutargs [] _ = [])
 /\ (mutargs _ [] = [])
 /\ (mutargs (ty::tys) (v::vs) =
     (case v of
        C_arrayv v => 
        (case ty of C_array c => if c.mutable then v::mutargs tys vs
                                else mutargs tys vs
                  | _ => mutargs tys vs)
      | _ => mutargs tys vs))`


val _ = Hol_datatype `
 ffi_outcome = FFI_failed | FFI_diverged`;

(* Oracle_return encodes the new state, list of word8 list of the output, and the return value *)
val _ = Hol_datatype `
 oracle_result = Oracle_return of 'ffi => word8 list list  => c_primv option 
               | Oracle_final of ffi_outcome`;





(* reinstating num list list because we want to treat aliasing *)
val _ = type_abbrev((*  'ffi *) "oracle_function" , ``: 'ffi -> c_value list -> num list list -> 'ffi oracle_result``);
val _ = type_abbrev((*  'ffi *) "oracle" , ``: string -> 'ffi oracle_function``);

(* An I/O event, IO_event s bytes bytes2, represents the call of FFI function s with
* immutable input bytes and mutable input map fst bytes2,
* returning map snd bytes2 in the mutable array. TODO: update *)

val _ = Hol_datatype `
 io_event = IO_event of string => c_value list => word8 list list => c_primv option`;


val _ = Hol_datatype `
 final_event = Final_event of string => c_value list => ffi_outcome`;


val _ = Hol_datatype `
(*  'ffi *) ffi_state =
<| oracle      : 'ffi oracle
 ; ffi_state   : 'ffi
 ; io_events   : io_event list
 ; signatures  : c_funsig list (* new *)
 |>`;


(*val initial_ffi_state : forall 'ffi. oracle 'ffi -> 'ffi -> ffi_state 'ffi*)
val _ = Define `
 ((initial_ffi_state:(string -> 'ffi oracle_function) -> 'ffi -> c_funsig list -> 'ffi ffi_state) oc ffi sigs =
 (<| oracle      := oc
 ; ffi_state   := ffi
 ; io_events   := ([])
 ; signatures  := sigs
 |>))`;



(*  its a precondition for theorems about the correctness of the FFI, doesn't have to be 
included in the  call_ffi*)

val _ = Define `
  ffi_oracle_ok st =
  (!s sign args ffi' newargs retv als.
           (FIND (λx. x.mlname = s) st.signatures = SOME sign)
           /\ args_ok sign args
           /\ (st.oracle s st.ffi_state args als = Oracle_return ffi' newargs retv)
           ==> ret_ok sign.retty retv
               /\ LIST_REL (λx y. LENGTH x = LENGTH y) (mutargs sign.args args) newargs
  )`

val _ = Hol_datatype `
 ffi_result = FFI_return of 'ffi ffi_state => word8 list list (* again the output argements *) => c_primv option (* return value *) 
            | FFI_final of final_event`;



(* call_FFI can either check that the returned aliases values are consistent or it 
can assume that they are as in ffi_oracle_ok *)


(*val call_FFI : forall 'ffi. ffi_state 'ffi -> string -> list word8 -> list word8 -> ffi_result 'ffi*)
(* we are not required to do the LENGTH check on the returned mutable arguments because 
we are not using ZIP anymore in the io_event log*)

val _ = Define `
 ((call_FFI:'ffi ffi_state -> string ->(c_value)list -> num list list -> 'ffi ffi_result) st s args als =
   (if ~ (s = "") then
    (case FIND (λx. x.mlname = s) st.signatures of
      SOME sign => 
      (if args_ok sign args then
       (case st.oracle s st.ffi_state args als of
         Oracle_return ffi' newargs retv =>
           if ret_ok sign.retty retv then
              FFI_return
               ( st with<| ffi_state := ffi'
                       ; io_events :=
                           (st.io_events ++
                             [IO_event s args newargs retv])
               |>)
               newargs retv
           else ARB (* TODO: should this be specified? Is so to what? *)
        | Oracle_final outcome =>
             FFI_final(Final_event s args outcome)
       )
       else ARB (* TODO: should this be specified? If so to what? *)
      )
    )
  else FFI_return st [] NONE))`;


val _ = Hol_datatype `
 outcome = Success | Resource_limit_hit | FFI_outcome of final_event`;


(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
val _ = Hol_datatype `
 behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge of  io_event llist
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate of outcome => io_event list
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail`;


(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics as follows. *)

(*val trace_oracle : oracle (llist io_event)*)
val _ = Define `
 ((trace_oracle:string ->(io_event)llist ->(c_value)list ->((io_event)llist)oracle_result) s io_trace args=
   ((case LHD io_trace of
    SOME (IO_event s' args' newargs retv) =>
      if (s = s') /\ (args = args') then
        Oracle_return (THE (LTL io_trace)) newargs retv
      else Oracle_final FFI_failed
  | _ => Oracle_final FFI_failed
  )))`;

val _ = export_theory()

