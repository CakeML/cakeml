(*Generated by Lem from lib.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_list_extraTheory lem_stringTheory sptreeTheory wordsTheory;

val _ = numLib.prefer_num();



val _ = new_theory "lib"

(*open import Pervasives*)
(*import List_extra*)
(*import String*)

(* TODO: look for these in the built-in library *)

(*val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)*)

(*val disjoint : forall 'a. set 'a -> set 'a -> bool*)

(*val all2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool*)

val _ = Define `
 (el_check n ls = (if n < LENGTH ls then SOME (EL n ls) else NONE))`;


(*val num_fold : forall 'a. ('a -> 'a) -> 'a -> nat -> 'a*)
 val _ = Define `
 (num_fold f a n = (if n = 0 then a else num_fold f (f a) (n -  1)))`;


 val _ = Define `
 (the _ (SOME x) = x) /\ (the x NONE = x)`;


(*val fapply : forall 'a 'b. MapKeyType 'b => 'a -> 'b -> Map.map 'b 'a -> 'a*)
val _ = Define `
 (fapply d x f = ((case FLOOKUP f x of SOME d => d | NONE => d )))`;


 val lunion_defn = Hol_defn "lunion" `

(lunion [] s = s)
/\
(lunion (x::xs) s =  
(if MEM x s
  then lunion xs s
  else x::(lunion xs s)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn lunion_defn;

(* TODO: proper support for nat sets as sptrees... *)
(*open import {hol} `sptreeTheory`*)
(*type nat_set*)
(*val nat_set_empty : nat_set*)
(*val nat_set_insert : nat_set -> nat -> nat_set*)
(*val nat_set_to_set : nat_set -> set nat*)
(*val nat_set_elem : nat_set -> nat -> bool*)
(*val nat_set_from_list : list nat -> nat_set*)

(* TODO: proper support for words... *)
(*open import {hol} `wordsTheory`*)
(*type word8*)
(*val natFromWord8 : word8 -> nat*)
(*val word_to_hex_string : word8 -> string*)

(* The builtin List.zip maps to list_combine in HOL, but I want to map to ZIP *)
(*val ZIP : forall 'a 'b. list 'a -> list 'b -> list ('a * 'b)*)

(* Environments *)
val _ = type_abbrev((* ( 'a, 'b) *) "env" , ``: ('a#'b) list``);

(*val emp : forall 'a 'b. env 'a 'b*)
val _ = Define `
 (emp = ([]))`;


(*val lookup : forall 'a 'b. Eq 'a => 'a -> env 'a 'b -> maybe 'b*)
 val _ = Define `

(lookup _ [] = NONE)
/\
(lookup n ((n',v)::e) =  
(if n' = n then
    SOME v
  else
    lookup n e))`;


(*val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (bind n v e = ((n,v)::e))`;


(*val opt_bind : forall 'a 'b. maybe 'a -> 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (opt_bind n v e =  
((case n of 
      NONE => e
    | SOME n' => (n',v)::e
  )))`;


(*val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (merge e1 e2 = (e1 ++ e2))`;


(* Lists of indices *)

 val _ = Define `

(lshift (n : num) ls =  
(MAP (\ v .  v - n) (FILTER (\ v .  n <= v) ls)))`;

val _ = export_theory()

