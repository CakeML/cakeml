(*Generated by Lem from fpValTree.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "fpValTree"

(*
  Definition of floating point value trees for CakeML
*)
(*open import Pervasives*)
(*open import Lib*)

val _ = Hol_datatype `
 sc =   Opt`;

val _ = Hol_datatype `
 fp_cmp = FP_Less | FP_LessEqual | FP_Greater | FP_GreaterEqual | FP_Equal`;

val _ = Hol_datatype `
 fp_pred =   FP_NaN`;

val _ = Hol_datatype `
 fp_uop = FP_Abs | FP_Neg | FP_Sqrt`;

val _ = Hol_datatype `
 fp_bop = FP_Add | FP_Sub | FP_Mul | FP_Div`;

val _ = Hol_datatype `
 fp_top =   FP_Fma`;


val _ = Hol_datatype `
 fp_val =
       Fp_const of word64
     | Fp_pred of fp_pred => fp_val
     | Fp_cmp of fp_cmp => fp_val => fp_val
     | Fp_uop of fp_uop => fp_val
     | Fp_bop of fp_bop => fp_val => fp_val
     | Fp_top of fp_top => fp_val => fp_val => fp_val
     | Fp_sc of sc => fp_val`;


(*val fp_pred: fp_pred -> fp_val -> fp_val*)
val _ = Define `
 ((fp_pred:fp_pred -> fp_val -> fp_val) fop f1=  (Fp_pred fop f1))`;


(*val fp_cmp : fp_cmp -> fp_val -> fp_val -> fp_val*)
val _ = Define `
 ((fp_cmp:fp_cmp -> fp_val -> fp_val -> fp_val) fop f1 f2=  (Fp_cmp fop f1 f2))`;


(*val fp_uop : fp_uop -> fp_val -> fp_val*)
val _ = Define `
 ((fp_uop:fp_uop -> fp_val -> fp_val) fop f1=  (Fp_uop fop f1))`;


(*val fp_bop : fp_bop -> fp_val -> fp_val -> fp_val*)
val _ = Define `
 ((fp_bop:fp_bop -> fp_val -> fp_val -> fp_val) fop f1 f2=  (Fp_bop fop f1 f2))`;


(*val fp_top : fp_top -> fp_val -> fp_val -> fp_val -> fp_val*)
val _ = Define `
 ((fp_top:fp_top -> fp_val -> fp_val -> fp_val -> fp_val) fop f1 f2 f3=  (Fp_top fop f1 f2 f3))`;


(*val isFpWordOp: fp_val -> bool*)
 val isFpWordOp_defn = Defn.Hol_multi_defns `
 ((isFpWordOp:fp_val -> bool) (Fp_const _)=  T)
    /\ ((isFpWordOp:fp_val -> bool) (Fp_uop _ _)=  T)
    /\ ((isFpWordOp:fp_val -> bool) (Fp_bop _ _ _)=  T)
    /\ ((isFpWordOp:fp_val -> bool) (Fp_top _ _ _ _)=  T)
    /\ ((isFpWordOp:fp_val -> bool) (Fp_sc _ v)=  (isFpWordOp v))
    /\ ((isFpWordOp:fp_val -> bool) _=  F)`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) (List.map Defn.save_defn) isFpWordOp_defn;

(*val isFpBoolOp: fp_val -> bool*)
 val isFpBoolOp_defn = Defn.Hol_multi_defns `
 ((isFpBoolOp:fp_val -> bool) (Fp_pred _ _)=  T)
    /\ ((isFpBoolOp:fp_val -> bool) (Fp_cmp _ _ _)=  T)
    /\ ((isFpBoolOp:fp_val -> bool) (Fp_sc _ v)=  (isFpBoolOp v))
    /\ ((isFpBoolOp:fp_val -> bool) _=  F)`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) (List.map Defn.save_defn) isFpBoolOp_defn;val _ = export_theory()

