(*Generated by Lem from ast.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "ast"

(*open import Pervasives*)
(*open import Lib*)

(* Literal constants *)
val _ = Hol_datatype `
 lit =
    IntLit of int
  | StrLit of string
  | Bool of bool
  | Unit
  | Word8 of word8`;


(* Built-in binary operations (including function application) *)

val _ = Hol_datatype `
 opn = Plus | Minus | Times | Divide | Modulo`;

val _ = Hol_datatype `
 opb = Lt | Gt | Leq | Geq`;


(*val opn_lookup : opn -> integer -> integer -> integer*)
val _ = Define `
 (opn_lookup n : int -> int -> int = ((case n of
    Plus => (+)
  | Minus => (-)
  | Times => ( * )
  | Divide => (/)
  | Modulo => (%)
)))`;


(*val opb_lookup : opb -> integer -> integer -> bool*)
val _ = Define `
 (opb_lookup n : int -> int -> bool = ((case n of
    Lt => (<)
  | Gt => (>)
  | Leq => (<=)
  | Geq => (>=)
)))`;


(* Module names *)
val _ = type_abbrev( "modN" , ``: string``);

(* Identifiers *)
val _ = Hol_datatype `
 id =
    Short of 'a
  | Long of modN => 'a`;


(*
instance forall 'a. Eq 'a => (Eq (id 'a))
  let (=) x y =
    match (x,y) with
      | (Short a, Short b) -> a = b
      | (Long mn a, Long mn' b) -> mn = mn' && (a = b)
    end
end
*)

(* Variable names *)
val _ = type_abbrev( "varN" , ``: string``);

(* Constructor names (from datatype definitions) *)
val _ = type_abbrev( "conN" , ``: string``);

(* Type names *)
val _ = type_abbrev( "typeN" , ``: string``);

(* Type variable names *)
val _ = type_abbrev( "tvarN" , ``: string``);

(*val mk_id : forall 'a. maybe modN -> 'a -> id 'a*)
val _ = Define `
 (mk_id mn_opt n =  
((case mn_opt of
      NONE => Short n
    | SOME mn => Long mn n
  )))`;


(*val id_to_n : forall 'a. id 'a -> 'a*)
val _ = Define `
 (id_to_n id =  
 ((case id of
      Short n => n
    | Long _ n => n
  )))`;


(* Opapp is function application. *)
val _ = Hol_datatype `
 op =
    Opn of opn
  | Opb of opb
  | Equality
  | Opapp
  | Opassign
  | Opref
  | Opderef
  (* Word8Array operations *)
  | Aalloc
  | Asub
  | Alength
  | Aupdate
  (* Vector operations *)
  | VfromList
  | Vsub`;


(* Built-in logical operations *)
val _ = Hol_datatype `
 lop =
    And
  | Or`;


(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
val _ = Hol_datatype `
 tctor =
    TC_name of typeN id
  | TC_int
  | TC_string
  | TC_bool
  | TC_unit
  | TC_ref
  | TC_word8
  | TC_word8array
  | TC_fn
  | TC_tup
  | TC_exn
  | TC_vector`;


val _ = Hol_datatype `
 t =
    Tvar of tvarN
  (* DeBruin indexed type variables. *)
  | Tvar_db of num
  | Tapp of t list => tctor`;


val _ = Define `
 (Tint = (Tapp [] TC_int))`;

val _ = Define `
 (Tstring = (Tapp [] TC_string))`;

val _ = Define `
 (Tunit = (Tapp [] TC_unit))`;

val _ = Define `
 (Tbool = (Tapp [] TC_bool))`;

val _ = Define `
 (Tref t = (Tapp [t] TC_ref))`;

val _ = Define `
 (Tword8 = (Tapp [] TC_word8))`;

val _ = Define `
 (Tword8array = (Tapp [] TC_word8array))`;

val _ = Define `
 (Tfn t1 t2 = (Tapp [t1;t2] TC_fn))`;

val _ = Define `
 (Texn = (Tapp [] TC_exn))`;


(* Patterns *)
val _ = Hol_datatype `
 pat =
    Pvar of varN
  | Plit of lit
  (* Constructor applications. *)
  | Pcon of  ( conN id)option => pat list
  | Pref of pat`;


(* Expressions *)
val _ = Hol_datatype `
 exp =
    Raise of exp
  | Handle of exp => (pat # exp) list
  | Lit of lit
  (* Constructor application. *)
  | Con of  ( conN id)option => exp list
  | Var of varN id
  | Fun of varN => exp
  (* Application of a primitive operator to arguments. Includes function application. *)
  | App of op => exp list
  (* Logical operations (and, or) *)
  | Log of lop => exp => exp
  | If of exp => exp => exp
  (* Pattern matching *)
  | Mat of exp => (pat # exp) list
  | Let of  varN option => exp => exp
  (* Local definition of (potentially) mutually recursive functions
   * The first varN is the function's name, and the second varN is its
   * parameter. *)
  | Letrec of (varN # varN # exp) list => exp`;


val _ = type_abbrev( "type_def" , ``: ( tvarN list # typeN # (conN # t list) list) list``);

(* Declarations *)
val _ = Hol_datatype `
 dec =
  (* Top-level bindings
   * The number is how many type variables are bound.
   * The pattern allows several names to be bound at once *)
    Dlet of pat => exp
  (* Mutually recursive function definition *)
  | Dletrec of (varN # varN # exp) list
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of type_def
  | Dtabbrev of tvarN list => typeN => t
  | Dexn of conN => t list`;


val _ = type_abbrev( "decs" , ``: dec list``); 

val _ = Hol_datatype `
 spec =
    Sval of varN => t
  | Stype of type_def
  | Stabbrev of tvarN list => typeN => t
  | Stype_opq of tvarN list => typeN
  | Sexn of conN => t list`;


val _ = type_abbrev( "specs" , ``: spec list``);

val _ = Hol_datatype `
 top =
    Tmod of modN =>  specs option => decs
  | Tdec of dec`;


val _ = type_abbrev( "prog" , ``: top list``);

(* Accumulates the bindings of a pattern *)
(*val pat_bindings : pat -> list varN -> list varN*)
 val pat_bindings_defn = Hol_defn "pat_bindings" `

(pat_bindings (Pvar n) already_bound =  
(n::already_bound))
/\
(pat_bindings (Plit l) already_bound =
  already_bound)
/\
(pat_bindings (Pcon _ ps) already_bound =  
(pats_bindings ps already_bound))
/\
(pat_bindings (Pref p) already_bound =  
(pat_bindings p already_bound))
/\
(pats_bindings [] already_bound =
  already_bound)
/\
(pats_bindings (p::ps) already_bound =  
(pats_bindings ps (pat_bindings p already_bound)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pat_bindings_defn;
val _ = export_theory()

