open HolKernel Parse boolLib bossLib;

val _ = new_theory "x64_heap";

open pred_setTheory arithmeticTheory pairTheory listTheory combinTheory;
open finite_mapTheory sumTheory relationTheory stringTheory optionTheory;
open wordsTheory wordsLib integer_wordTheory;
open prog_x64_extraTheory prog_x64Theory temporalTheory;
open lexer_funTheory lexer_implTheory;
open lcsymtacs;

open bytecodeTheory bytecodeExtraTheory;

open ml_copying_gcTheory ml_heapTheory
open decompilerLib;
open x64_codegenLib;
open x64_compilerLib;
open set_sepTheory;
open helperLib;
open addressTheory
open x64_copying_gcTheory;
open progTheory;
open intLib;
open bootstrapProofTheory
open repl_funTheory
open repl_funProofTheory

val _ = ParseExtras.temp_loose_equality();

(*
val _ = PolyML.SaveState.loadState "x64_heap_state";
*)

(* intLib blastLib bytecodeLabelsTheory miscLib *)

val _ = (max_print_depth := 25);

infix \\ val op \\ = op THEN;

fun gg tm = (proofManagerLib.drop ();
             proofManagerLib.drop ();
             proofManagerLib.set_goal([],tm));

val w2w_ADD_sw2sw_SUB = prove(
  ``!x y. x <+ 0x20000000w /\ y <+ 0x20000000w ==>
          (w2w x + sw2sw (y - x) = (w2w:word32 -> word64) y)``,
  REPEAT GEN_TAC \\ blastLib.BBLAST_TAC);


(* define zHEAP *)

val _ = (Datatype.big_record_size := 100);

val _ = Hol_datatype ` (* called cs *)
  zheap_consts = <| heap_limit : num ;
                    heap_part1 : word64 ;
                    heap_part2 : word64 ;
                    ret_address : word64 ;         (* once code completes ret here *)
                    rest_of_stack : word64 list ;  (* to be preserved throughout *)
                    getchar_ptr : word64 ;
                    putchar_ptr : word64 ;
                    error_ptr : word64 ;
                    alloc_ptr : word64 ;
                    bignum_ptr : word64 ;
                    equal_ptr : word64 ;
                    print_ptr : word64 ;
                    code_heap_ptr : word64 ;
                    code_heap_length : num ;
                    stack_trunk : word64 ;
                    repl_setup_ptr : word64 ;
                    repl_step_ptr : word64 ;
                    lex_ptr : word64 ;
                    install_and_run_ptr : word64 |>`;

val consts_zero = Define `
  consts_zero = <| heap_limit := 0 ;
                   heap_part1 := 0w ;
                   heap_part2 := 0w ;
                   ret_address := 0w ;
                   rest_of_stack := [] ;
                   getchar_ptr := 0w ;
                   putchar_ptr := 0w ;
                   error_ptr := 0w ;
                   alloc_ptr := 0w ;
                   bignum_ptr := 0w ;
                   equal_ptr := 0w ;
                   print_ptr := 0w ;
                   code_heap_ptr := 0w ;
                   code_heap_length := 0 ;
                   stack_trunk := 0w ;
                   repl_setup_ptr := 0w ;
                   repl_step_ptr := 0w ;
                   lex_ptr := 0w ;
                   install_and_run_ptr := 0w |>`;

val _ = Hol_datatype ` (* called local *)
  zheap_local = <| stop_addr : word64 ;
                   printing_on : word64 |> `;

val local_zero_def = Define `
  local_zero = <| stop_addr := 0w;
                  printing_on := 0w |>`;

val _ = Hol_datatype ` (* called vs *)
  zheap_vars = <| current_heap : word64 ;
                  other_heap : word64 ;
                  base_ptr : word64 ;
                  code_ptr : word64 ;
                  code_start_ptr : word64 ;
                  local : zheap_local |>`;

val _ = Hol_datatype ` (* called s *)
  zheap_state = <| input : string ;
                   output : string ;
                   handler : num ;
                   base_offset : num ;
                   code_mode : bool option ;
                   code : word8 list ;
                   code_start : word8 list ;
                   code_max_length : num ;
                   local : zheap_local |>`;

val _ = Hol_datatype ` (* called vals *)
  x64_vals = <| reg0 : word64 ;
                reg1 : word64 ;
                reg2 : word64 ;
                reg3 : word64 ;
                reg5 : word64 ;
                reg6 : word64 ;
                reg7 : word64 ;
                reg8 : word64 ;
                reg9 : word64 ;
                reg10 : word64 ;
                reg11 : word64 ;
                reg12 : word64 ;
                reg13 : word64 ;
                reg14 : word64 ;
                reg15 : word64 ;
                memory : word64 -> word64 ;
                memory_domain : word64 set ;
                stack : word64 list ;
                stack_bottom : word64 ;
                code_option : bool option ;
                code_list : word8 list ;
                input_stream : word8 list ;
                output_stream : word8 list |>`;

val heap_vars_ok_def = Define `
  heap_vars_ok vs =
    (vs.current_heap && 0x7w = 0x0w) /\
    (vs.other_heap && 0x7w = 0x0w) /\
    (vs.base_ptr && 0x7w = 0x0w)`;

val x64_store_def = Define `
  x64_store cs vs =
    one_list vs.base_ptr
      [ vs.current_heap          (*   0 pointer to currently used heap half *)
      ; vs.other_heap            (*   8 pointer to the other heap half *)
      ; n2w (cs.heap_limit)      (*  16 size of each heap half *)
      ; cs.putchar_ptr           (*  24 pointer to C's putchar method *)
      ; cs.getchar_ptr           (*  32 pointer to C's getchar method *)
      ; cs.error_ptr             (*  40 pointer to abort code which writes error message *)
      ; cs.alloc_ptr             (*  48 pointer to heap alloc routine *)
      ; cs.bignum_ptr            (*  56 pointer to entry point for bignum library *)
      ; cs.equal_ptr             (*  64 pointer to routine for rec equality check *)
      ; cs.print_ptr             (*  72 pointer to routine for rec printing of bc_value *)
      ; vs.code_ptr              (*  80 pointer to next free instruction slot *)
      ; n2w cs.code_heap_length  (*  88 size of code heap *)
      ; cs.code_heap_ptr         (*  96 base of code heap *)
      ; vs.code_start_ptr        (* 104 bytecode execution will start here *)
      ; cs.repl_step_ptr         (* 112 pointer to repl_step routine *)
      ; cs.lex_ptr               (* 120 lexer *)
      ; cs.install_and_run_ptr   (* 128 install and run bytecode *)
      ; vs.local.stop_addr       (* 136 address where bc execution returns *)
      ; vs.local.printing_on     (* 144 whether printing should be done *)
      ; 0w                       (* 152 padding *)
      ; 0w                       (* 160 padding *)
      ; 0w                       (* 168 padding *)
      ]`;

val not_0w_def = Define `not_0w = ~0w`;

val stack_inv_def = Define `
  stack_inv (r5:word64) r11 trunk bottom base_offset handler
            (rest_of_stack:word64 list) =
    (r5 = trunk - n2w (8 * base_offset)) /\
    (r11 = trunk - n2w (8 * handler)) /\
    (bottom - n2w (8 * LENGTH rest_of_stack) - 16w = trunk) /\
    (trunk && 3w = 0w)`;

val code_heap_inv_def = Define `
  code_heap_inv cs_code_heap_length (cs_code_heap_ptr:word64)
                (vals_code_option:bool option) (vals_code_list:word8 list)
                s_code_mode s_code s_code_start s_code_max_length
                vs_code_ptr vs_code_start_ptr =
    cs_code_heap_length < (2**61):num /\
    (vals_code_option = s_code_mode) /\
    (vals_code_list = s_code) /\
    (s_code_max_length = cs_code_heap_length) /\
    (cs_code_heap_ptr + n2w (LENGTH s_code) = vs_code_ptr) /\
    (cs_code_heap_ptr + n2w (LENGTH s_code_start) = vs_code_start_ptr)`;

val heap_inv_def = Define `
  heap_inv (cs,x1,x2,x3,x4,refs,stack,s:zheap_state,space) (vals:x64_vals) =
    ?vs r1 r2 r3 r4 roots heap a sp.
      abs_ml_inv ([x1;x2;x3;x4] ++ stack) refs
                 ([r1;r2;r3;r4] ++ roots,heap,a,sp) cs.heap_limit /\
      (space <> NONE ==> THE space (sp,vals)) /\
      (vals.reg0 = x64_addr vs.current_heap r1) /\
      (vals.reg1 = x64_addr vs.current_heap r2) /\
      (vals.reg2 = x64_addr vs.current_heap r3) /\
      (vals.reg3 = x64_addr vs.current_heap r4) /\
      (vals.reg6 = vs.current_heap + n2w (8 *  a) - 1w) /\
      (vals.reg7 = vs.current_heap + n2w (8 * (a + sp)) - 1w) /\
      (vals.reg9 = vs.base_ptr) /\
      (vals.reg10 = HD (MAP (n2w o ORD) s.input ++ [not_0w])) /\
      stack_inv vals.reg5 vals.reg11 cs.stack_trunk
        vals.stack_bottom s.base_offset s.handler
            cs.rest_of_stack /\
      code_heap_inv cs.code_heap_length cs.code_heap_ptr
                vals.code_option vals.code_list
                s.code_mode s.code s.code_start s.code_max_length
                vs.code_ptr vs.code_start_ptr /\
      cs.heap_limit < 281474976710656 /\ (* 2**(64-16) *)
      (x64_heap vs.current_heap heap vs.current_heap vs.current_heap *
       one_list_exists vs.other_heap cs.heap_limit *
       x64_store cs vs) (fun2set (vals.memory,vals.memory_domain)) /\
      (vals.stack = MAP (x64_addr vs.current_heap) roots ++
                    0x1w::cs.ret_address::cs.rest_of_stack) /\
      (vals.input_stream = MAP (n2w o ORD) (DROP 1 s.input)) /\
      (vals.output_stream = MAP (n2w o ORD) s.output) /\
      (vs.local = s.local) /\
      heap_vars_ok vs`

val zOPTION_CODE_HEAP_def = Define `
  (zOPTION_CODE_HEAP NONE len a xs = emp) /\
  (zOPTION_CODE_HEAP (SOME safe) len a xs = zCODE_HEAP safe a xs len)`;

val zVALS_def = Define `
  zVALS cs (vals:x64_vals) =
    zR 0w vals.reg0 *
    zR 1w vals.reg1 *
    zR 2w vals.reg2 *
    zR 3w vals.reg3 *
    zR 5w vals.reg5 *
    zR 6w vals.reg6 *
    zR 7w vals.reg7 *
    zR 8w vals.reg8 *
    zR 9w vals.reg9 *
    zR 10w vals.reg10 *
    zR 11w vals.reg11 *
    zR 12w vals.reg12 *
    zR 13w vals.reg13 *
    zR 14w vals.reg14 *
    zR 15w vals.reg15 *
    zSTACK (vals.stack_bottom,vals.stack) *
    zMEMORY64 vals.memory_domain vals.memory *
    zOPTION_CODE_HEAP vals.code_option cs.code_heap_length
                      cs.code_heap_ptr vals.code_list *
    zIO (cs.getchar_ptr,vals.input_stream,
         cs.putchar_ptr,vals.output_stream)`;

val zHEAP_def = Define `
  zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) =
    SEP_EXISTS vals.
      zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,space) vals)`;

val zHEAP_OUTPUT_def = Define `
  zHEAP_OUTPUT (cs,output) =
    SEP_EXISTS vals. zVALS cs vals * zPC cs.ret_address * ~zS *
                     cond ((vals.stack = cs.rest_of_stack) /\
                           (vals.output_stream = MAP (n2w o ORD) output))`;

val error_msg_def = Define `
  error_msg = "\nERROR: resource bound hit, aborting\n"`;

val zHEAP_ERROR_def = Define `
  zHEAP_ERROR cs =
    SEP_EXISTS output. zHEAP_OUTPUT (cs,output ++ error_msg)`;

(* define INIT_STATE *)

val _ = Hol_datatype ` (* called init *)
  zheap_init = <| init_heap_ptr : word64 ;
                  init_heap_size : word64 ;
                  init_code_heap_ptr : word64 ;
                  init_code_heap_size : word64 ;
                  init_putc_ptr : word64 ;
                  init_getc_ptr : word64 ;
                  init_input : string ;
                  init_ret_ptr : word64 ;
                  init_stack_bottom : word64 ;
                  init_stack : word64 list |>`;

(*

  heap[0] = HEAP_SIZE;
  heap[1] = (long) (& codeheap);
  heap[2] = CODE_HEAP_SIZE;
  heap[3] = (long) (& putchar);
  heap[4] = (long) (& getchar);

  - pointer to heap is in rax
  - ret address on top of stack

*)

val init_inv_def = Define `
  init_inv (cs:zheap_consts) (vals:x64_vals) (init:zheap_init) =
    (* heap pointer is in rax regsiter *)
    (vals.reg0 = init.init_heap_ptr) /\
    (* pointers are 64-bit aligned and sizes are < 2 ** 48 *)
    (init.init_heap_ptr && 7w = 0w) /\
    (init.init_code_heap_ptr && 7w = 0w) /\
    0x100 <= w2n init.init_heap_size /\
    (w2n init.init_heap_size MOD 16 = 0) /\
    w2n init.init_heap_size < 0x1000000000000 /\
    w2n init.init_code_heap_size < 0x1000000000000 /\
    (* stack contains ret pointer *)
    (vals.stack = init.init_ret_ptr :: init.init_stack) /\
    (vals.stack_bottom = init.init_stack_bottom) /\
    (* code heap is present but not clean *)
    (vals.code_option = SOME F) /\ (vals.code_list = []) /\
    (cs.code_heap_ptr = init.init_code_heap_ptr) /\
    (cs.code_heap_length = w2n init.init_code_heap_size) /\
    (* input_stream holds input and output is empty *)
    (cs.getchar_ptr = init.init_getc_ptr) /\
    (cs.putchar_ptr = init.init_putc_ptr) /\
    (vals.input_stream = MAP (n2w o ORD) init.init_input) /\
    (vals.output_stream = []) /\
    (* memory contains heap array with space for heaps *)
    ?space.
      (one_list init.init_heap_ptr ([init.init_heap_size;
                                     init.init_code_heap_ptr;
                                     init.init_code_heap_size;
                                     init.init_putc_ptr;
                                     init.init_getc_ptr] ++ space))
           (fun2set (vals.memory,vals.memory_domain)) /\
      (8 * (5 + LENGTH space) = w2n init.init_heap_size)`;

val INIT_STATE_def = Define `
  INIT_STATE init =
    SEP_EXISTS cs vals.
      zVALS cs vals * cond (init_inv cs vals init)`;

(* definition and lemmas for SPEC_N *)

val T_DISJ_def = Define `
  T_DISJ p q f s = (p f s) \/ (q f s):bool`;

val T_CONJ_def = Define `
  T_CONJ p q f s = (p f s) /\ (q f s):bool`;

val LATER_def = Define `
  LATER p = NEXT (EVENTUALLY p)`;

val N_NEXT_def = Define `
  (N_NEXT 0 = I) /\
  (N_NEXT (SUC n) = NEXT o N_NEXT n)`;

val N_NEXT_THM = prove(
  ``!k p f s. N_NEXT k p f s <=> p f (\n. s (n + k))``,
  Induct \\ ASM_SIMP_TAC std_ss [N_NEXT_def,LATER_def,NEXT_def,EVENTUALLY_def]
  \\ REPEAT STRIP_TAC \\ RES_TAC
  THEN1 (CONV_TAC (DEPTH_CONV ETA_CONV) \\ FULL_SIMP_TAC std_ss [])
  \\ FULL_SIMP_TAC (srw_ss()) [ADD1,AC ADD_COMM ADD_ASSOC]);

val SPEC_N_def = Define `
  SPEC_N n model pre code post err <=>
     TEMPORAL model code
       (T_IMPLIES (NOW pre) (T_OR_F (N_NEXT n (EVENTUALLY (NOW post))) err))`

val SPEC_1_EQ_SPEC_N = prove(
  ``SPEC_1 m p c q e <=> SPEC_N 1 m p c q e``,
  EVAL_TAC);

val TEMPORAL_IMP_T_OR_F_EVENTUALLY = store_thm("TEMPORAL_IMP_T_OR_F_EVENTUALLY",
  ``TEMPORAL model code (T_IMPLIES p1 (T_OR_F (EVENTUALLY p1) p2))``,
  PairCases_on`model` >>
  rw[TEMPORAL_def,T_IMPLIES_def,T_OR_F_def,EVENTUALLY_def] >>
  disj1_tac >>
  qexists_tac`0` >>
  simp[ETA_AX])

val rel_sequence_shift = prove(
  ``!n seq' s. rel_sequence n seq' s ==> !i. rel_sequence n (\j. seq' (i + j)) (seq' i)``,
  REWRITE_TAC [rel_sequence_def] \\ REPEAT STRIP_TAC \\ SIMP_TAC std_ss []
  \\ Cases_on `?s. n (seq' (i + n')) s` \\ ASM_REWRITE_TAC []
  \\ FULL_SIMP_TAC std_ss [ADD1,ADD_ASSOC] \\ METIS_TAC []);

val N_NEXT_thm = prove(
  ``!k p f s. N_NEXT k p f s = p f (\n. s (n + k))``,
  Induct \\ fs [N_NEXT_def,NEXT_def,ADD1,AC ADD_COMM ADD_ASSOC]
  \\ CONV_TAC (DEPTH_CONV ETA_CONV) \\ fs []);

val T_OR_F_thm = prove(
  ``T_OR_F p post = T_DISJ p (EVENTUALLY (NOW post))``,
  FULL_SIMP_TAC std_ss [FUN_EQ_THM,T_OR_F_def,T_DISJ_def]);

val SPEC_N_COMPOSE = prove(
  ``SPEC_N m model p2 c p3 err ==>
    SPEC_N n model p1 c p2 err ==>
    SPEC_N (m+n) model p1 c p3 err``,
  PairCases_on `model`
  \\ fs [SPEC_N_def,T_OR_F_thm,TEMPORAL_def,LET_DEF]
  \\ fs [T_IMPLIES_def,T_DISJ_def,EVENTUALLY_def,NOW_def]
  \\ fs [N_NEXT_thm,EVENTUALLY_def,NOW_def]
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 METIS_TAC []
  \\ Q.MATCH_ASSUM_RENAME_TAC `rel_sequence model1 s state`
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`s`,`r`]) \\ fs []
  \\ REVERSE (REPEAT STRIP_TAC)
  THEN1 METIS_TAC [] THEN1 METIS_TAC [] THEN1 METIS_TAC []
  \\ IMP_RES_TAC rel_sequence_shift
  \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `k + n`)
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`(s (k + n:num))`,`\j. s (k + n + j:num)`,`r`])
  \\ fs [] \\ REPEAT STRIP_TAC
  THEN1 (DISJ1_TAC \\ Q.EXISTS_TAC `k+k'` \\ fs [AC ADD_COMM ADD_ASSOC])
  THEN1 (DISJ2_TAC \\ METIS_TAC [])
  THEN1 (DISJ2_TAC \\ Q.EXISTS_TAC `k+k'+n` \\ fs [AC ADD_COMM ADD_ASSOC])
  THEN1 (DISJ2_TAC \\ METIS_TAC []));

val SPEC_N_1_IMP_SUC = store_thm("SPEC_N_1_IMP_SUC",
  ``!n model pre1 pre2 post code err.
      SPEC_N n model pre2 code post err /\ SPEC_1 model pre1 code pre2 err ==>
      SPEC_N (SUC n) model pre1 code post err``,
  REPEAT STRIP_TAC \\ fs [ADD1,SPEC_1_EQ_SPEC_N]
  \\ IMP_RES_TAC SPEC_N_COMPOSE);

val SPEC_IMP_SPEC_N = prove(
  ``SPEC model p c (q \/ err) ==> SPEC_N 0 model p c q err``,
  fs [SPEC_EQ_TEMPORAL,SPEC_N_def,N_NEXT_def,T_OR_F_thm,TEMPORAL_def]
  \\ PairCases_on `model` \\ fs [TEMPORAL_def,LET_DEF]
  \\ fs [T_IMPLIES_def,FUN_EQ_THM,EVENTUALLY_def,T_DISJ_def,NOW_def,SEP_CLAUSES]
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 METIS_TAC []
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`seq'`,`r`]) \\ fs []
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 METIS_TAC []
  \\ fs [SEP_REFINE_def,SEP_DISJ_def] \\ METIS_TAC []);

val SPEC_N_0 = prove(
  ``SPEC_N 0 model p c q err <=> SPEC model p c (q \/ err)``,
  fs [SPEC_N_def,N_NEXT_def,SPEC_EQ_TEMPORAL]
  \\ PairCases_on `model`
  \\ fs [T_OR_F_def,EVENTUALLY_def,NOW_def,
         TEMPORAL_def,T_IMPLIES_def,LET_DEF,SEP_CLAUSES,SEP_REFINE_def]
  \\ fs [SEP_DISJ_def]
  \\ REVERSE (REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC)
  THEN1 (METIS_TAC [])
  THEN1 (METIS_TAC [])
  THEN1 (METIS_TAC [])
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`seq'`,`r`])
  \\ fs [] \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC \\ METIS_TAC []);

val SPEC_IMP_SPEC_N_ALT =
  SPEC_IMP_SPEC_N |> Q.INST [`err`|->`SEP_F`] |> RW [SEP_CLAUSES];

val SPEC_1_MOVE_COND = prove(
  ``!x p c q g err.
      SPEC_1 x (p * cond g) c q err <=> g ==> SPEC_1 x p c q err``,
  REPEAT STRIP_TAC \\ PairCases_on `x` \\ fs [SPEC_1_def]
  \\ Cases_on `g` \\ fs [SEP_CLAUSES]
  \\ fs [TEMPORAL_def,LET_DEF,T_IMPLIES_def,NOW_def,SEP_F_def,SEP_CLAUSES]
  \\ fs [SEP_REFINE_def,SEP_F_def,T_OR_F_def,EVENTUALLY_def,NOW_def]
  \\ METIS_TAC []);

(* helpers theorems *)

val globals_count_def = Define `
  globals_count = 10000:num`;

fun take n [] = []
  | take 0 xs = []
  | take n (x::xs) = x::take (n-1) xs;

fun drop n [] = []
  | drop 0 xs = xs
  | drop n (x::xs) = drop (n-1) xs;

val getTag_def = Define `(getTag (Block n x) = n)`;
val getContent_def= Define `(getContent (Block n x) = x)`
val getNumber_def = Define `
  (getNumber (Number i) = i) /\
  (getNumber _ = 0)`;

val isBlock_def = Define `(isBlock (Block n x) = T) /\ (isBlock _ = F)`;

val isNumber_def = Define `
  (isNumber (Number i) = T) /\
  (isNumber _ = F)`;

val isRefPtr_def = Define `
  (isRefPtr (RefPtr i) = T) /\
  (isRefPtr _ = F)`;

val getRefPtr_def = Define `(getRefPtr (RefPtr x) = x) /\ (getRefPtr _ = ARB)`;

val isValueArray_def = Define`
  (isValueArray (ValueArray _) = T) /\
  (isValueArray _ = F)`
val getValueArray_def = Define`
  (getValueArray (ValueArray v) = v)`

val isByteArray_def = Define`
  (isByteArray (ByteArray _) = T) /\
  (isByteArray _ = F)`
val getByteArray_def = Define`
  (getByteArray (ByteArray v) = v)`

val isCodePtr_def = Define `
  (isCodePtr (CodePtr _) = T) /\ (isCodePtr _ = F)`;

val getCodePtr_def = Define `
  (getCodePtr (CodePtr x) = x)`;

val canCompare_def = Define `
  (canCompare (Number _) = T) /\
  (canCompare (RefPtr _) = T) /\
  (canCompare (Block _ _) = T) /\
  (canCompare _ = F)`;

val DISJ_IMP = METIS_PROVE [] ``(x \/ y ==> z) <=> (x ==> z) /\ (y ==> z)``;

val SPEC_WEAKEN_LEMMA = prove(
  ``(b ==> SPEC m (p * cond i) c q1) ==>
    !q2. (i ==> b /\ SEP_IMP q1 q2) ==>
         SPEC m (p * cond i) c q2``,
  Cases_on `i` THEN Cases_on `b` THEN SIMP_TAC std_ss [SPEC_MOVE_COND]
  THEN METIS_TAC [SPEC_WEAKEN]);

val SPEC_1_WEAKEN_LEMMA = prove(
  ``(b ==> SPEC_1 m (p * cond i) c q1 err) ==>
    !q2. (i ==> b /\ SEP_IMP q1 q2) ==>
         SPEC_1 m (p * cond i) c q2 err``,
  Cases_on `i` THEN Cases_on `b` THEN SIMP_TAC std_ss [SPEC_1_MOVE_COND]
  THEN METIS_TAC [SPEC_1_WEAKEN]);

val EVERY2_IMP_LENGTH = LIST_REL_LENGTH

val blast_align_lemma = prove(
  ``(8w + w && 7w = w && 7w:word64) /\
    (w + 8w && 7w = w && 7w:word64) /\
    (w + 8w * x && 7w = w && 7w:word64) /\
    (w + x * 8w && 7w = w && 7w:word64) /\
    (w - 8w * x && 7w = w && 7w:word64) /\
    (w - x * 8w && 7w = w && 7w:word64)``,
  REPEAT STRIP_TAC \\ blastLib.BBLAST_TAC);

val PULL_IMP_EXISTS = METIS_PROVE []
  ``(P ==> ?x. Q x) <=> ?x. P ==> Q x``

val reachable_refs_SIMP = prove(
  ``(reachable_refs (Number n::x1::x3::x4::stack) refs m =
     reachable_refs (x1::x3::x4::stack) refs m) /\
    (reachable_refs (x1::Number n::x3::x4::stack) refs m =
     reachable_refs (x1::x3::x4::stack) refs m) /\
    (reachable_refs (x1::x3::Number n::x4::stack) refs m =
     reachable_refs (x1::x3::x4::stack) refs m) /\
    (reachable_refs (x1::x3::x4::Number n::stack) refs m =
     reachable_refs (x1::x3::x4::stack) refs m)``,
  SIMP_TAC std_ss [reachable_refs_def,MEM]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ Q.LIST_EXISTS_TAC [`x`,`r`] \\ FULL_SIMP_TAC std_ss []
  \\ REPEAT (POP_ASSUM MP_TAC)
  \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]);


(* helper automation *)

fun get_pc th = let
  val (_,_,_,post) = UNDISCH_ALL th |> concl |> dest_spec
  in find_term (can (match_term ``zPC (p + n2w n)``)) post end;

fun dest_spec_1 tm = let
  val (mxyz,t) = dest_comb tm
  val (mxy,z) = dest_comb mxyz
  val (mx,y) = dest_comb mxy
  val (m,x) = dest_comb mx
  in (m,x,y,z) end

fun expand_pre th target = let
  val th = SIMP_RULE std_ss [SPEC_MOVE_COND,SPEC_1_MOVE_COND,
             REWRITE_CONV [SEP_HIDE_def] ``~(zR r)``] th |> UNDISCH_ALL
           |> CONV_RULE (PRE_CONV (SIMP_CONV std_ss [SEP_CLAUSES]))
           |> SIMP_RULE std_ss [GSYM SPEC_PRE_EXISTS] |> SPEC_ALL
  val (_,p,_,_) = dest_spec (concl th)
                  handle HOL_ERR _ =>
                  dest_spec_1 (concl th)
  val ps = list_dest dest_star p
  val target_thm = target |> REWRITE_CONV [zVALS_def]
  val tm = target_thm |> concl |> rand
  val ts = list_dest dest_star tm
  fun find_inst tm = let
    val j = first (can (match_term tm)) ts
    in fst (match_term tm j) end handle HOL_ERR _ => []
  val th = INST (flatten (map find_inst ps)) th
  val (_,p,_,post) = dest_spec (concl th)
                     handle HOL_ERR _ =>
                     dest_spec_1 (concl th)
  val ps = list_dest dest_star p
  val rs = set_diff (map get_sep_domain ts) (map get_sep_domain ps)
  val rs = filter (fn t => mem (get_sep_domain t) rs) ts
  val frame = list_mk_star rs (type_of (hd ps))
  val th = MATCH_MP SPEC_FRAME th |> SPEC frame
           handle HOL_ERR _ =>
           MATCH_MP SPEC_1_FRAME th |> SPEC frame |> RW [SEP_CLAUSES]
  val (th,goal) = SPEC_STRENGTHEN_RULE th target
  in (th,goal) end;

fun spec str = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode str)
  in th end

fun compose_specs strs = let
  val th = SPEC_COMPOSE_RULE (map spec strs)
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE true sts th
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
              |> UNDISCH_ALL
  in th end

fun x64_decompile name asm =
  decompile_strings prog_x64Lib.x64_tools_64 name
    (assemble asm);

fun x64_decompile_no_status name asm =
  decompile_strings prog_x64Lib.x64_tools_64_no_status name
    (assemble asm);

val (_,_,sts,_) = prog_x64Lib.x64_tools

fun abbreviate_code name ptr = let
  val pat1 = ``(^ptr,xx:'a)``
  val pat2 = ``(^ptr + n2w n,xx:'a)``
  fun g tm = can (match_term pat1) tm orelse can (match_term pat2) tm
  val in_pat = ``x INSERT s``
  val in_in_pat = ``x INSERT y INSERT s``
  val in_union_pat = ``x INSERT s1 UNION s2``
  val PULL_INSERT_UNION = prove(
    ``((x INSERT s) UNION t = x INSERT (s UNION t)) /\
      (s UNION (x INSERT t) = x INSERT (s UNION t))``,
    SIMP_TAC (srw_ss()) [EXTENSION] \\ METIS_TAC []);
  val PUSH_INSERT_THM = prove(
    ``x INSERT (s UNION t) = s UNION (x INSERT t)``,
    SIMP_TAC (srw_ss()) [EXTENSION] \\ METIS_TAC []);
  val UNION_IDEMPOT_LEMMA = prove(
    ``(s UNION (s UNION t)) = s UNION t``,
    SIMP_TAC (srw_ss()) [EXTENSION] \\ METIS_TAC []);
  fun insert_final_empty_conv tm =
    if can (match_term in_pat) tm then
      RAND_CONV insert_final_empty_conv tm
    else if pred_setSyntax.is_union tm then
      RAND_CONV insert_final_empty_conv tm
    else UNION_EMPTY |> CONJUNCT2 |> GSYM |> ISPEC tm
  fun full_push_insert_conv g tm =
    if can (match_term in_pat) tm then let
      val x = tm |> rator |> rand
      fun push_insert_conv tm = (* assumes input of form x INSERT s such that g x *)
        if can (match_term in_in_pat) tm then let
          val x = tm |> rator |> rand
          val y = tm |> rand |> rator |> rand
          in if g y then ALL_CONV tm else
            (REWR_CONV INSERT_COMM THENC RAND_CONV push_insert_conv) tm
          end
        else if can (match_term in_union_pat) tm then
          (REWR_CONV PUSH_INSERT_THM THENC RAND_CONV push_insert_conv) tm
        else ALL_CONV tm
        in if g x then push_insert_conv tm else ALL_CONV tm end
    else ALL_CONV tm
  fun f tm = let
    val q = [QUOTE (name^"_code p = "),ANTIQUOTE (subst [ptr|->``p:word64``] tm)]
    in REWR_CONV (GSYM (Define q)) tm end
  fun modify_conv f g tm =
    if can (match_term in_pat) tm then let
      val x = tm |> rator |> rand
      in if g x then f tm else RAND_CONV (modify_conv f g) tm end
    else RAND_CONV (modify_conv f g) tm
  val c = (REWRITE_CONV [PULL_INSERT_UNION]
           THENC insert_final_empty_conv
           THENC DEPTH_CONV (full_push_insert_conv g)
           THENC modify_conv f g
           THENC SIMP_CONV std_ss [AC UNION_ASSOC UNION_COMM,UNION_IDEMPOT_LEMMA]
           THENC SIMP_CONV std_ss [UNION_EMPTY,UNION_ASSOC])
  in CONV_RULE ((RATOR_CONV o RAND_CONV) c) end

val SPEC_WEAKEN_EXISTS = prove(
  ``(!x. a x ==> SPEC m p c (q x)) ==>
    !i q1. (i ==> ?x. a x /\ SEP_IMP (q x) q1) ==>
            i ==> SPEC m p c q1``,
  REPEAT STRIP_TAC \\ Cases_on `i` \\ fs [] \\ REPEAT STRIP_TAC \\ RES_TAC
  \\ METIS_TAC [SPEC_WEAKEN]);

val BINOP1_CONV = RATOR_CONV o RAND_CONV

fun SMART_WEAKEN th = let
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO,GSYM CONJ_ASSOC]
  val (a,s) = dest_imp (concl th)
  val a_vs = free_vars a
  val (_,pre,code,post) = dest_spec s
  val pre_code_vs = free_vars pre @ free_vars code
  val post_vs = free_vars post
  fun diff xs ys = filter (fn x => not (mem x ys)) xs
  val var_sort = sort (fn v => fn w => fst (dest_var v) <= fst (dest_var w))
  val hide_vs = diff (a_vs @ post_vs) pre_code_vs |> var_sort |> all_distinct
  val hide_tuple = pairSyntax.list_mk_pair hide_vs
  val cc = PairRules.UNPBETA_CONV hide_tuple
  val th1 = th |> CONV_RULE (BINOP1_CONV cc THENC
                             RAND_CONV (RAND_CONV cc))
  val v = mk_var("v",type_of hide_tuple)
  fun foo 0 tm = ALL_CONV tm
    | foo n tm =
      (ONCE_REWRITE_CONV [GSYM PAIR] THENC
       RAND_CONV (foo (n-1))) tm
  val all_parts = foo (length hide_vs-1) v
  val i = zip hide_vs (list_dest pairSyntax.dest_pair (all_parts |> concl |> rand))
          |> map (fn (x,y) => x |-> y)
  val th2 = th1 |> INST i |> RW [PAIR] |> GEN v
  val lemma = MATCH_MP SPEC_WEAKEN_EXISTS th2
  fun EXISTS_ALPHA_CONV [] = ALL_CONV
    | EXISTS_ALPHA_CONV (v::vs) =
        RAND_CONV (ALPHA_CONV v THENC ABS_CONV (EXISTS_ALPHA_CONV vs))
   val c = SIMP_CONV bool_ss [EXISTS_PROD]
           THENC EXISTS_ALPHA_CONV hide_vs
           THENC SIMP_CONV std_ss []
   val th = CONV_RULE ((QUANT_CONV o QUANT_CONV o BINOP1_CONV o RAND_CONV) c) lemma
   in th end


(* GC is a no-op *)

val _ = add_compiled [x64_full_gc_res];

val (x64_gc_op_res, x64_gc_op_def, x64_gc_op_pre_def) = x64_compile `
  x64_gc_op (r0:word64,r1:word64,r2:word64,r3:word64,r9:word64,ss:word64 list,dm,m) =
    let (r8:word64) = m r9 in
    let r7 = m (r9 + 8w) in
    let m = (r9 =+ r7) m in
    let m = (r9 + 8w =+ r8) m in
    let (r8,ss,dm,m) = x64_full_gc (r7,ss,dm,m) in
    let r0 = m r9 in
    let r7 = m (r9 + 16w) in
    let r7 = r7 << 3 in
    let r7 = r7 + r0 in
    let r7 = r7 - 1w in
    let r0 = 0w:word64 in
    let r1 = r0 in
    let r2 = r0 in
    let r3 = r0 in
    let r6 = r8 - 1w in
      (r0,r1,r2,r3,r6,r7,r8,r9,ss,dm,m)`

val x64_heap_IGNORE_bf = prove(
  ``!heap a.
      (FILTER isForwardPointer heap = []) ==>
      (x64_heap a heap bf bd = x64_heap a heap ARB bd)``,
  Induct \\ SIMP_TAC std_ss [x64_heap_def,x64_el_def]
  \\ Cases \\ ASM_SIMP_TAC std_ss [x64_heap_def,x64_el_def,
    isForwardPointer_def,FILTER,NOT_CONS_NIL]
  \\ Cases_on `b` \\ FULL_SIMP_TAC std_ss [x64_el_def]);

val reachable_refs_Number = prove(
  ``reachable_refs (Number 0::stack) refs n =
    reachable_refs stack refs n``,
  SIMP_TAC std_ss [reachable_refs_def,MEM]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ NTAC 2 (POP_ASSUM MP_TAC) \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]
  \\ METIS_TAC []);

val push_num_lemma = prove(
  ``abs_ml_inv (Number 0::stack) refs (Data 0x0w::roots,x,a,k) l <=>
    abs_ml_inv stack refs (roots,x,a,k) l``,
  FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,roots_ok_def,MEM,reachable_refs_Number,
    bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def,EVAL ``small_int 0``]);

val STACK_LENGTH_LEMMA = prove(
  ``SPEC m (x * zVALS cs vals * cond g) c q <=>
    SPEC m (x * zVALS cs vals *
            cond (g /\ 8 * LENGTH vals.stack < 2 ** 64)) c q``,
  Cases_on `8 * LENGTH vals.stack < 2 ** 64` \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC std_ss [SEP_CLAUSES,SPEC_FALSE_PRE]
  \\ SIMP_TAC std_ss [zVALS_def,zSTACK_def]
  \\ `!rsp top dm m. ~stack_ok rsp top vals.stack_bottom vals.stack dm m` by ALL_TAC
  \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES,SPEC_FALSE_PRE]
  \\ SIMP_TAC std_ss [stack_ok_def] \\ REPEAT STRIP_TAC
  \\ CCONTR_TAC \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,LEFT_ADD_DISTRIB]
  \\ DECIDE_TAC);

val zHEAP_GC_RAW = let
  val th = x64_gc_op_res
  val pc = get_pc th
  val inv = ``SOME (\(sp:num,vals).
    (ttt13 = vals.reg13) /\ (ttt14 = vals.reg14))``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = RW1 [STACK_LENGTH_LEMMA] th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val n = ``Number 0``
  val th = th |> Q.SPEC `zHEAP (cs,^n,^n,^n,^n,refs,stack,s,^inv) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val x64_heap_heap_expand = prove(
    ``x64_heap a (heap_expand n) x y = one_list_exists a n``,
    Cases_on `n` \\ ASM_SIMP_TAC (srw_ss()) [heap_expand_def,x64_heap_def,
       one_list_exists_def,LENGTH_NIL,SEP_CLAUSES,one_list_def,x64_el_def]
    \\ FULL_SIMP_TAC std_ss [ADD1]);
  val MAP_APPEND_LEMMA = prove(
    ``f x :: (MAP f xs ++ ys) = MAP f (x::xs) ++ ys``,
    FULL_SIMP_TAC std_ss [MAP,APPEND]);
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [x64_gc_op_def, x64_gc_op_pre_def,LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ `(vals.memory (vs.base_ptr) = vs.current_heap)` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [x64_store_def,Once one_list_def] \\ SEP_R_TAC)
    \\ `(vals.memory (vs.base_ptr + 0x8w) = vs.other_heap)` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [x64_store_def,Ntimes one_list_def 3] \\ SEP_R_TAC)
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND_LEMMA,APPEND]
    \\ Q.ABBREV_TAC `m1 = (vs.base_ptr + 0x8w =+ vs.current_heap)
         ((vs.base_ptr =+ vs.other_heap) vals.memory)`
    \\ Q.ABBREV_TAC `vals1 = vals with memory := m1`
    \\ `(vals.memory_domain = vals1.memory_domain) /\
        (m1 = vals1.memory)` by (Q.UNABBREV_TAC `vals1` \\ SRW_TAC [] [])
    \\  POP_ASSUM (fn th => SIMP_TAC std_ss [th])
    \\  POP_ASSUM (fn th => SIMP_TAC std_ss [th])
    \\ IMP_RES_TAC (pop_thm
      |> Q.INST [`xs`|->`[x1;x2;x3;x4]`,`rs`|->`[r1;r2;r3;r4]`]
      |> SIMP_RULE std_ss [LENGTH,APPEND])
    \\ Q.PAT_ASSUM `abs_ml_inv (ss::sss) refs bla cs.heap_limit` (K ALL_TAC)
    \\ IMP_RES_TAC full_gc_thm
    \\ `x64_heap vs.current_heap heap vs.current_heap vs.current_heap =
        x64_heap vs.current_heap heap vs.other_heap vs.current_heap` by
      (FULL_SIMP_TAC std_ss [abs_ml_inv_def,heap_ok_def,x64_heap_IGNORE_bf])
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.ABBREV_TAC `vs1 = (vs with <| current_heap := vs.other_heap;
           other_heap := vs.current_heap |>)`
    \\ `(x64_heap vs.current_heap heap vs.other_heap vs.current_heap *
         one_list_exists vs.other_heap cs.heap_limit *
         x64_store cs vs1)
           (fun2set (vals1.memory,vals1.memory_domain))` by ALL_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES,STAR_ASSOC]
      \\ Q.ABBREV_TAC `m = vals.memory`
      \\ Q.ABBREV_TAC `dm = vals.memory_domain`
      \\ SEP_W_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) []
      \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ FULL_SIMP_TAC std_ss []
    \\ ASSUME_TAC (x64_full_gc_thm |> GEN_ALL)
    \\ SEP_I_TAC "x64_full_gc"
    \\ POP_ASSUM (MP_TAC o Q.GEN `r` o
           Q.SPECL [`roots2`,`r`,`cs.heap_limit`,`heap2`,`heap`])
    \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC \\ SEP_F_TAC
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
    THEN1 (FULL_SIMP_TAC std_ss [heap_vars_ok_def]
           \\ STRIP_TAC THEN1 DECIDE_TAC
           \\ STRIP_TAC THEN1 DECIDE_TAC
           \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
           \\ IMP_RES_TAC EVERY2_IMP_LENGTH
           \\ Q.PAT_ASSUM `8 * LENGTH vals.stack < nn` MP_TAC
           \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC (srw_ss()) []
      \\ FULL_SIMP_TAC std_ss [x64_store_def,Ntimes one_list_def 3,word_arith_lemma1]
      \\ SEP_R_TAC \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,MAP,HD,TL]
    \\ REPEAT STRIP_TAC
    \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_EXISTS_THM,zVALS_def]
    \\ `m1' (vs.base_ptr + 0x10w) << 3 + m1' vs.base_ptr =
        vs.other_heap + n2w (8 * cs.heap_limit)` by ALL_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [x64_store_def,Ntimes one_list_def 3,word_arith_lemma1]
      \\ SEP_R_TAC
      \\ SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,word_add_n2w]
      \\ SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
    \\ FULL_SIMP_TAC std_ss [MAP,HD,TL,APPEND]
    \\ Q.EXISTS_TAC `vals with
          <| reg0 := 0w;
             reg1 := 0w;
             reg2 := 0w;
             reg3 := 0w;
             reg6 := vs.other_heap + n2w (8 * heap_length heap2) - 1w;
             reg7 := vs.other_heap + n2w (8 * cs.heap_limit) - 1w;
             reg8 := (vs.other_heap + n2w (8 * heap_length heap2));
             reg9 := vs.base_ptr;
             stack := (MAP (x64_addr vs.other_heap) roots2 ++
                      0x1w::cs.ret_address::cs.rest_of_stack);
             memory := m1' |>`
    \\ SIMP_TAC (srw_ss()) []
    \\ `vals1.memory_domain = vals.memory_domain` by ALL_TAC
    THEN1 (Q.UNABBREV_TAC `vals1` \\ SRW_TAC [] [])
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [STAR_ASSOC,cond_STAR]
    \\ REVERSE STRIP_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) []
           \\ FULL_SIMP_TAC (std_ss++star_ss) [AC WORD_ADD_ASSOC WORD_ADD_COMM])
    \\ ASM_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs1`,`Data 0w`,`Data 0w`,`Data 0w`,`Data 0w`,`roots2`,
         `heap2 ++ heap_expand (cs.heap_limit - a2)`,`a2`,`cs.heap_limit - a2`]
    \\ `heap_vars_ok vs1` by ALL_TAC
    THEN1 (Q.UNABBREV_TAC `vs1` \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def])
    \\ ASM_SIMP_TAC std_ss []
    \\ Q.UNABBREV_TAC `vs1` \\ ASM_SIMP_TAC (srw_ss()) [x64_addr_def]
    \\ FULL_SIMP_TAC std_ss [APPEND,x64_heap_APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [x64_heap_heap_expand]
    \\ FULL_SIMP_TAC (srw_ss()) [x64_store_def,Ntimes one_list_def 3]
    \\ SEP_R_TAC
    \\ `a2 <= cs.heap_limit` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,heap_ok_def,heap_length_APPEND]
      \\ DECIDE_TAC)
    \\ IMP_RES_TAC (DECIDE ``n <= (m:num) ==> (n + (m - n) = m)``)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [push_num_lemma])
  val th = MP th lemma
  val th = RW1 [GSYM STACK_LENGTH_LEMMA] th
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> Q.INST [`ttt13`|->`r13`,`ttt14`|->`r14`]
  in th end;


(* from INIT_STATE to zHEAP *)

val store_length =
  x64_store_def |> SPEC_ALL |> concl |> rand |> rand
    |> listSyntax.dest_list |> fst |> length |> numSyntax.term_of_int

val heap_len =
  ``((w2n init.init_heap_size - 8 * ^store_length) DIV 16)``

val first_s_def = Define `
  first_s (init:zheap_init) =
    <| input := " " ++ init.init_input ;
       output := "" ;
       handler := 0 ;
       base_offset := 0 ;
       code_mode := SOME F ;
       code := [] ;
       code_start := [] ;
       code_max_length := w2n init.init_code_heap_size ;
       local := local_zero |>`

val first_cs_def = Define `
  first_cs (init:zheap_init) =
    consts_zero with
    <| heap_limit := ^heap_len
     ; ret_address := init.init_ret_ptr
     ; rest_of_stack := init.init_stack
     ; stack_trunk := init.init_stack_bottom - n2w (8 * LENGTH init.init_stack + 16)
     ; code_heap_ptr := init.init_code_heap_ptr
     ; code_heap_length := w2n init.init_code_heap_size
     ; getchar_ptr := init.init_getc_ptr
     ; putchar_ptr := init.init_putc_ptr |>`;

val reintro_word_sub64 = SIMP_CONV (srw_ss()) [] ``-(n2w n):word64`` |> GSYM
val reintro_word_sub63 = SIMP_CONV (srw_ss()) [] ``-(n2w n):63 word`` |> GSYM

val ID_def = Define `ID x = x`;

val n2w_lsr = prove(
  ``!n. n < 2**64 ==>
        (n2w n >>> k = n2w (n DIV 2 ** k):word64)``,
  SIMP_TAC std_ss [w2n_lsr,GSYM w2n_11,w2n_n2w] \\ REPEAT STRIP_TAC
  \\ `(n DIV 2 ** k) < dimword (:64)` by ALL_TAC \\ FULL_SIMP_TAC std_ss []
  \\ FULL_SIMP_TAC (srw_ss()) [DIV_LT_X]
  \\ Cases_on `(2:num) ** k` \\ FULL_SIMP_TAC std_ss [MULT_CLAUSES]
  \\ DECIDE_TAC) |> SIMP_RULE std_ss [];

val x64_heap_heap_expand = prove(
  ``x64_heap curr (heap_expand len) curr curr = one_list_exists curr len``,
  Cases_on `len` \\ ASM_SIMP_TAC std_ss [heap_expand_def]
  \\ SIMP_TAC std_ss [one_list_exists_def,FUN_EQ_THM,SEP_EXISTS_THM,ADD1,
      cond_STAR,LENGTH_NIL,one_list_def,x64_heap_def,SEP_CLAUSES,x64_el_def]);

val x64_heap_APPEND_one_list_exists = prove(
  ``x64_heap curr (heap_expand heap_len) curr curr *
    one_list_exists (curr + 0x8w * n2w heap_len) heap_len =
    one_list_exists curr (heap_len + heap_len)``,
  SIMP_TAC std_ss [x64_heap_heap_expand,one_list_exists_def,SEP_CLAUSES]
  \\ SIMP_TAC (std_ss++sep_cond_ss) [FUN_EQ_THM,SEP_EXISTS_THM,cond_STAR]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC THEN1
   (Q.EXISTS_TAC `xs ++ xs'`
    \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,one_list_APPEND,word_mul_n2w])
  \\ IMP_RES_TAC LENGTH_EQ_SUM \\ FULL_SIMP_TAC std_ss []
  \\ Q.LIST_EXISTS_TAC [`l1`,`l2`]
  \\ FULL_SIMP_TAC std_ss [one_list_APPEND,word_mul_n2w]);

val (x64_setup_res, x64_setup_def, x64_setup_pre_def) = x64_compile `
  x64_setup (r0:word64,dm:word64 set,m:word64->word64,ss:word64 list) =
    let r1 = 1w:word64 in
    let ss = r1 :: ss in
    let r1 = m r0 in
    let r12 = m (r0 + 0x08w) in (* code_heap_ptr *)
    let r13 = m (r0 + 0x10w) in (* code_heap_size *)
    let r3 = n2w ^store_length in
    let r3 = r3 << 3 in
    let r15 = r0 + r3 in (* v *)
    let r1 = r1 - r3 in
    let r1 = r1 >>> 4 in (* w *)
    let r9 = r0 in
    let r6 = r15 - 1w in
    let r7 = r1 << 3 in
    let r7 = r7 + r15 in
    let r7 = r7 - 1w in
    let r10 = 0x20w:word64 in
    let m = (r0 =+ r15) m in
    let r2 = r1 << 3 in
    let r15 = r15 + r2 in
    let r14 = 0w:word64 in
    let m = (r0 + 8w =+ r15) m in
    let m = (r0 + 0x10w =+ r1) m in
    let m = (r0 + 0x28w =+ r14) m in
    let m = (r0 + 0x30w =+ r14) m in
    let m = (r0 + 0x38w =+ r14) m in
    let m = (r0 + 0x40w =+ r14) m in
    let m = (r0 + 0x48w =+ r14) m in
    let m = (r0 + 0x58w =+ r13) m in
    let m = (r0 + 0x50w =+ r12) m in
    let m = (r0 + 0x60w =+ r12) m in
    let m = (r0 + 104w =+ r12) m in
    let r0 = r0 + 112w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r0 + 8w in
    let m = (r0 =+ r14) m in
    let r0 = r14 in
    let r1 = r14 in
    let r2 = r14 in
    let r3 = r14 in
    let r8 = r14 in
    let r12 = r14 in
    let r13 = r14 in
    let r15 = r14 in
      (r0,r1,r2,r3,r6,r7,r8,r9,r10,r12,r13,r14,r15,dm,m,ss)`

val stack_assum =
  ``(vals.reg5 = vals.stack_bottom - n2w (8 * LENGTH vals.stack + 8)) /\
    (vals.reg11 = vals.reg5) /\
    (vals.stack_bottom && 7w = 0w)``;

val init_inv_IMP_heap_inv = prove(
  ``init_inv cs vals init ==>
      x64_setup_pre (vals.reg0,vals.memory_domain,vals.memory,vals.stack) /\
     (^stack_assum ==>
      let x = Number 0 in
      let w = (vals.memory vals.reg0 - n2w (ID (8 * ^store_length))) >>> 4 in
      let c = (vals.memory (vals.reg0 + 8w)) in
      let v = vals.reg0 + n2w (8 * ^store_length) in
        heap_inv (first_cs init,x,x,x,x,FEMPTY,[],first_s init,NONE)
          (let (r0,r1,r2,r3,r6,r7,r8,r9,r10,r12,r13,r14,r15,dm,m,ss) =
            x64_setup (vals.reg0,vals.memory_domain,vals.memory,vals.stack) in
             vals with <| reg0 := r0 ;
                          reg1 := r1 ;
                          reg2 := r2 ;
                          reg3 := r3 ;
                          reg6 := r6 ;
                          reg7 := r7 ;
                          reg8 := r8 ;
                          reg9 := r9 ;
                          reg10 := r10 ;
                          reg12 := r12 ;
                          reg13 := r13 ;
                          reg14 := r14 ;
                          reg15 := r15 ;
                          stack := ss ;
                          memory := m ;
                          memory_domain := dm |>))``,
  ONCE_REWRITE_TAC [CONJ_COMM]
  \\ SIMP_TAC std_ss [LET_DEF,init_inv_def] \\ STRIP_TAC
  \\ Q.ABBREV_TAC `heap_len = ^heap_len`
  \\ Q.ABBREV_TAC `curr = init.init_heap_ptr + n2w (8 * ^store_length)`
  \\ `(vals.memory init.init_heap_ptr - n2w (ID 176)) >>> 4 = n2w heap_len` by
   (FULL_SIMP_TAC std_ss [one_list_def,APPEND] \\ SEP_R_TAC
    \\ UNABBREV_ALL_TAC \\ Cases_on `init.init_heap_size`
    \\ FULL_SIMP_TAC std_ss [w2n_n2w,WORD_SUB_INTRO,ID_def]
    \\ `~(n < 8 * ^store_length)` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [word_arith_lemma2]
    \\ `n - 8 * ^store_length < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC bool_ss [EVAL ``8 * ^store_length``]
    \\ IMP_RES_TAC n2w_lsr
    \\ FULL_SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
  \\ `curr + n2w heap_len << 3 - 0x1w = (curr + n2w (8 * heap_len)) - 1w` by
   (FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,word_sub_def]
    \\ SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
  \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC (srw_ss()) [LET_DEF,heap_inv_def]
  \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
  \\ Q.LIST_EXISTS_TAC [`<| current_heap := curr;
                            other_heap := curr + n2w (8 * heap_len);
                            base_ptr := init.init_heap_ptr ;
                            code_ptr := init.init_code_heap_ptr ;
                            code_start_ptr := init.init_code_heap_ptr ;
                            local := local_zero |>`,
       `Data 0w`,`Data 0w`,`Data 0w`,`Data 0w`,`[]`,
       `heap_expand heap_len`,`0`,`heap_len`]
  \\ FULL_SIMP_TAC std_ss [GSYM CONJ_ASSOC]
  \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def,first_cs_def,heap_vars_ok_def]
  \\ REVERSE STRIP_TAC THEN1
   (`^store_length - 5 <= LENGTH space` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_EQ_LENGTH
    \\ FULL_SIMP_TAC std_ss []
    \\ Cases_on `ys1` \\ FULL_SIMP_TAC std_ss [LENGTH]
    \\ REVERSE (NTAC 10 (REPEAT (Cases_on `t` \\ FULL_SIMP_TAC std_ss [LENGTH])
               \\ REPEAT (Cases_on `t'` \\ FULL_SIMP_TAC std_ss [LENGTH])))
    THEN1 (SIMP_TAC std_ss [ADD1] \\ `F` by DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()++sep_cond_ss) [APPEND,one_list_def,x64_store_def,
         EVAL ``consts_zero``,STAR_ASSOC,SEP_CLAUSES,SEP_EXISTS_THM,
         one_list_exists_def,cond_STAR]
    \\ FULL_SIMP_TAC std_ss [x64_setup_pre_def,LET_DEF,word_arith_lemma1]
    \\ SEP_R_TAC \\ SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `0x7w && init.init_heap_ptr = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  \\ STRIP_TAC
  \\ STRIP_TAC THEN1
   (Cases_on `heap_len = 0` \\ FULL_SIMP_TAC std_ss [heap_expand_def]
    \\ EVAL_TAC \\ SIMP_TAC std_ss [SUM,PULL_EXISTS] \\ Q.EXISTS_TAC `FEMPTY`
    \\ SRW_TAC [] [INJ_DEF,get_refs_def] \\ TRY DECIDE_TAC
    \\ fs [bc_value_inv_def] \\ EVAL_TAC
    \\ CCONTR_TAC \\ fs [] \\ SRW_TAC [] [] \\ fs [get_refs_def])
  \\ FULL_SIMP_TAC (srw_ss()) [init_inv_def,first_s_def,code_heap_inv_def,
       stack_inv_def] \\ FULL_SIMP_TAC std_ss [reintro_word_sub64]
  \\ `heap_len < 281474976710656 /\
      heap_len < 4611686018427387904` by ALL_TAC THEN1
    (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [DIV_LT_X] \\ DECIDE_TAC)
  \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND_one_list_exists
       |> SIMP_RULE std_ss [word_mul_n2w]]
  \\ `0x7w && curr = 0x0w` by ALL_TAC THEN1
   (UNABBREV_ALL_TAC
    \\ Q.PAT_ASSUM `0x7w && init.init_heap_ptr = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC) \\ FULL_SIMP_TAC std_ss []
  \\ `0x7w && curr + n2w (8 * heap_len) = 0x0w` by ALL_TAC THEN1
   (POP_ASSUM MP_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ blastLib.BBLAST_TAC) \\ FULL_SIMP_TAC std_ss []
  \\ FULL_SIMP_TAC (srw_ss()) [x64_setup_def,LET_DEF,ID_def,local_zero_def]
  \\ STRIP_TAC THEN1
   (SIMP_TAC std_ss [reintro_word_sub64,GSYM (EVAL ``-16w:word64``)]
    \\ SIMP_TAC std_ss [WORD_SUB_INTRO,GSYM WORD_SUB_PLUS,word_add_n2w]
    \\ `(8 * (SUC (LENGTH init.init_stack)) + 8 =
         8 * (LENGTH init.init_stack + 2)) /\
        (8 * (LENGTH init.init_stack) + 16 =
         8 * (LENGTH init.init_stack + 2))` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ Q.PAT_ASSUM `0x7w && init.init_stack_bottom = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  \\ STRIP_TAC THEN1 DECIDE_TAC
  \\ `^store_length - 5 <= LENGTH space` by DECIDE_TAC
  \\ IMP_RES_TAC LESS_EQ_LENGTH
  \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `ys1` \\ FULL_SIMP_TAC std_ss [LENGTH]
  \\ REVERSE (NTAC 10 (REPEAT (Cases_on `t` \\ FULL_SIMP_TAC std_ss [LENGTH])
              \\ REPEAT (Cases_on `t'` \\ FULL_SIMP_TAC std_ss [LENGTH])))
  THEN1 (SIMP_TAC std_ss [ADD1] \\ `F` by DECIDE_TAC)
  \\ FULL_SIMP_TAC (srw_ss()++sep_cond_ss) [APPEND,one_list_def,x64_store_def,
       EVAL ``consts_zero``,STAR_ASSOC,SEP_CLAUSES,SEP_EXISTS_THM,
       one_list_exists_def,cond_STAR]
  \\ SIMP_TAC std_ss [GSYM CONJ_ASSOC]
  \\ Q.EXISTS_TAC `ys2` \\ STRIP_TAC THEN1
   (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [ADD1,LEFT_ADD_DISTRIB]
    \\ FULL_SIMP_TAC std_ss [ADD_ASSOC]
    \\ Q.PAT_ASSUM `ww = w2n init.init_heap_size` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `(ppp + 8 * LENGTH ys2) MOD 16 = 0` MP_TAC
    \\ SIMP_TAC std_ss [Once (GSYM MOD_PLUS)]
    \\ ONCE_REWRITE_TAC [GSYM (EVAL ``8 * 2:num``)]
    \\ SIMP_TAC bool_ss [GSYM MOD_COMMON_FACTOR,DECIDE ``0 < 8:num /\ 0 < 2:num``]
    \\ SIMP_TAC std_ss [GSYM DIV_DIV_DIV_MULT,RW1 [MULT_COMM] MULT_DIV]
    \\ STRIP_ASSUME_TAC (Q.SPEC `LENGTH (ys2:word64 list)`
           (MATCH_MP DIVISION (DECIDE ``0<2:num``)) |> GSYM)
    \\ POP_ASSUM (K ALL_TAC)
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ DECIDE_TAC)
  \\ SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w]
  \\ Q.ABBREV_TAC `ptr = init.init_heap_ptr`
  \\ Q.ABBREV_TAC `m = vals.memory`
  \\ Q.ABBREV_TAC `dm = vals.memory_domain`
  \\ SEP_R_TAC
  \\ FULL_SIMP_TAC std_ss [] \\ SEP_W_TAC
  \\ POP_ASSUM MP_TAC
  \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ SIMP_TAC std_ss [STAR_ASSOC]
  \\ Q.PAT_ABBREV_TAC `pat = (ww:word64 =+ vv:word64) bbb`
  \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ SIMP_TAC std_ss [STAR_ASSOC])
  |> SPEC_ALL |> SIMP_RULE std_ss [LET_DEF];

val new_vals = init_inv_IMP_heap_inv |> concl |> rand |> rand |> rand;

val zSTACK_SETUP = let
  val th = compose_specs ["mov r5,r4","sub r5,8","mov r11,r5"]
  val th = th |> Q.INST [`r4`|->`rsp`]
  val pc = get_pc th
  val th = SPEC_FRAME_RULE th ``zR1 zGhost_stack_top top *
       zR1 zGhost_stack_bottom base * zMEMORY64 dm m *
       cond (stack_ok rsp top base stack dm m)``
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``^pc * zR 0xBw (base - n2w (8 * LENGTH stack + 8)) *
      zR 0x5w (base - n2w (8 * LENGTH stack + 8)) *
      ~zS * zSTACK (base,stack) * cond (base && 7w = 0w)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [zSTACK_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC std_ss [stack_ok_def]
    \\ Q.PAT_ASSUM `rsp + x = base` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [GSYM word_arith_lemma1,WORD_ADD_SUB]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def])
  val th = MP th lemma |> Q.GENL (rev [`rsp`,`top`,`dm`,`m`])
           |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
      ``zPC p * zR 0x5w r5 * zR 0xBw r11 * ~zS * zSTACK (base,stack)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [zSTACK_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def])
  val th = MP th lemma
  in th end

val zHEAP_SETUP = let
  val lemma = prove(``cond = ID cond``, SIMP_TAC std_ss [ID_def]);
  val th = zSTACK_SETUP |> RW1 [lemma]
  val th = SPEC_COMPOSE_RULE [th,x64_setup_res] |> SIMP_RULE (std_ss++sep_cond_ss) []
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals * cond (init_inv cs vals init)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (first_cs init,Number 0,Number 0,
                                Number 0,Number 0,FEMPTY,[],
                                first_s init,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES] \\ NTAC 2 STRIP_TAC
    THEN1 (IMP_RES_TAC init_inv_IMP_heap_inv)
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,ID_def]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ (init_inv_IMP_heap_inv
        |> Q.INST [`vals`|->`vals with
           <| reg5 := vals.stack_bottom  n2w (8 * LENGTH vals.stack + 8)
            ; reg11 := vals.stack_bottom  n2w (8 * LENGTH vals.stack + 8) |>`]
        |> SIMP_RULE (srw_ss()) [] |> UNDISCH
        |> CONJUNCT2 |> DISCH_ALL |> RW [AND_IMP_INTRO] |> MP_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC IMP_IMP
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [init_inv_def] \\ Q.EXISTS_TAC `space`
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ `?r0 r1 r2 r3 r6 r7 r8 r9 r10 r12 r13 r14 r15 dm m ss.
          x64_setup (vals.reg0,vals.memory_domain,vals.memory,vals.stack) =
            (r0,r1,r2,r3,r6,r7,r8,r9,r10,r12,r13,r14,r15,dm,m,ss)` by
               METIS_TAC [PAIR]
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC
    \\ (fn (hyps,tm) => EXISTS_TAC (rand (hd hyps)) (hyps,tm))
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def,LET_DEF,ID_def,first_cs_def]
    \\ FULL_SIMP_TAC std_ss [STAR_ASSOC]
    \\ Q.PAT_ASSUM `init_inv cs vals init` ASSUME_TAC
    \\ FULL_SIMP_TAC std_ss [init_inv_def]
    \\ Q.PAT_ASSUM `xx s` MP_TAC
    \\ FULL_SIMP_TAC (srw_ss()++star_ss) []
    \\ FULL_SIMP_TAC std_ss [STAR_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val th = Q.GEN `cs` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th ``INIT_STATE init * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [INIT_STATE_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* SNOC imm8 to code heap *)

val imm8_sw2sw = prove(
  ``!imm8. n2w (SIGN_EXTEND 8 64 (w2n (imm8:word8)) MOD 256):word8 = imm8``,
  Cases \\ FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,LET_DEF]
  \\ SRW_TAC [] []
  \\ ONCE_REWRITE_TAC [MATCH_MP (GSYM MOD_PLUS) (DECIDE ``0 < 256:num``)]
  \\ FULL_SIMP_TAC std_ss []);

val zHEAP_CODE_SNOC_IMM = let
  val th1 = compose_specs ["mov r15,[r9+80]"]
  val ((th,_,_),_) = prog_x64Lib.x64_spec "41C607"
  val th = SIMP_RULE std_ss [imm8_sw2sw,zBYTE_MEMORY_def,GSYM zBYTE_MEMORY_Z_def] th
           |> Q.INST [`r15`|->`a + n2w (LENGTH (xs:word8 list))`]
           |> Q.GENL [`g`,`dg`]
           |> MATCH_MP zCODE_HEAP_SNOC |> Q.INST [`xs`|->`code`]
           |> DISCH ``a + n2w (LENGTH (code:word8 list)) = r15:word64``
           |> SIMP_RULE std_ss [] |> UNDISCH
  val th2 = compose_specs ["inc r15","mov [r9+80],r15"]
  val th = SPEC_COMPOSE_RULE [th1,th,th2]
  val th = th |> RW [GSYM zOPTION_CODE_HEAP_def]
              |> DISCH ``SOME F = mode`` |> SIMP_RULE std_ss [] |> UNDISCH
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            LENGTH s.code < s.code_max_length /\ (s.code_mode = SOME F))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                           s with code := SNOC imm8 s.code,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| memory := (vals.reg9 + 0x50w =+
         vals.memory (vals.reg9 + 0x50w) + 0x1w) vals.memory ;
         reg15 := (vals.memory (vals.reg9 + 0x50w) + 0x1w) ;
         code_list := SNOC imm8 vals.code_list |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with code_ptr := vs.code_ptr + 1w`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ fs [] \\ rfs []
    \\ STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.ABBREV_TAC `dm = vals.memory_domain` \\ POP_ASSUM (K ALL_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory` \\ POP_ASSUM (K ALL_TAC)
    \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `xx = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w] \\ SRW_TAC [] [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (LENGTH s.code < s.code_max_length /\ (s.code_mode = SOME F))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* SNOC number to code heap *)

val zHEAP_CODE_SNOC_X2_BYTE = let
  val th1 = compose_specs ["mov r15,[r9+80]","mov r14,r1","shr r14,2"]
  val th = spec "mov [r15], r14b"
  val th = SIMP_RULE std_ss [imm8_sw2sw,zBYTE_MEMORY_def,GSYM zBYTE_MEMORY_Z_def] th
           |> Q.INST [`r15`|->`a + n2w (LENGTH (xs:word8 list))`]
           |> Q.GENL [`g`,`dg`]
           |> MATCH_MP zCODE_HEAP_SNOC |> Q.INST [`xs`|->`code`]
           |> DISCH ``a + n2w (LENGTH (code:word8 list)) = r15:word64``
           |> SIMP_RULE std_ss [] |> UNDISCH
  val th2 = compose_specs ["inc r15","mov [r9+80],r15"]
  val th = SPEC_COMPOSE_RULE [th1,th,th2]
  val th = th |> RW [GSYM zOPTION_CODE_HEAP_def]
              |> DISCH ``SOME F = mode`` |> SIMP_RULE std_ss [] |> UNDISCH
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            LENGTH s.code < s.code_max_length /\ (s.code_mode = SOME F) /\
            isNumber x2 /\ small_int (getNumber x2) /\ ~(getNumber x2 < 0))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                 s with code := SNOC (n2w (Num (getNumber x2))) s.code,NONE) *
                         ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| memory := (vals.reg9 + 0x50w =+
         vals.memory (vals.reg9 + 0x50w) + 0x1w) vals.memory ;
         reg14 := (vals.reg1 >>> 2) ;
         reg15 := (vals.memory (vals.reg9 + 0x50w) + 0x1w) ;
         code_list := SNOC (w2w (vals.reg1 >>> 2)) vals.code_list |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with code_ptr := vs.code_ptr + 1w`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ fs [] \\ rfs []
    \\ STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.ABBREV_TAC `dm = vals.memory_domain` \\ POP_ASSUM (K ALL_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory` \\ POP_ASSUM (K ALL_TAC)
    \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `xx = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w] \\ SRW_TAC [] []
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
         LIST_REL_def,bc_value_inv_def,x64_addr_def]
    \\ `(n2w (Num i) = (w2w:63 word -> word8) (n2w (Num i)))` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [w2w_n2w])
    \\ FULL_SIMP_TAC std_ss [] \\ Q.SPEC_TAC (`n2w (Num i):63 word`,`w`)
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (LENGTH s.code < s.code_max_length /\ (s.code_mode = SOME F) /\
            isNumber x2 /\ small_int (getNumber x2) /\ ~(getNumber x2 < 0))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val _ = add_compiled [th]
  in th end;

val zHEAP_CODE_SNOC_X2_IMM32 = let
  val th1 = compose_specs ["mov r15,[r9+80]","mov r14,r1","shr r14,2"]
  val th = spec "mov [r15], r14b"
  val th = SIMP_RULE std_ss [imm8_sw2sw,zBYTE_MEMORY_def,GSYM zBYTE_MEMORY_Z_def] th
           |> Q.INST [`r15`|->`a + n2w (LENGTH (xs:word8 list))`]
           |> Q.GENL [`g`,`dg`]
           |> MATCH_MP zCODE_HEAP_SNOC |> Q.INST [`xs`|->`code`]
           |> DISCH ``a + n2w (LENGTH (code:word8 list)) = r15:word64``
           |> SIMP_RULE std_ss [] |> UNDISCH
  val thi = compose_specs ["inc r15","shr r14,8"]
  val th2 = compose_specs ["inc r15","mov [r9+80],r15"]
  val th = th |> RW [GSYM zOPTION_CODE_HEAP_def]
              |> DISCH ``SOME F = mode`` |> SIMP_RULE std_ss [] |> UNDISCH
  val th = SPEC_COMPOSE_RULE [th1,th,thi,th,thi,th,thi,th,th2]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            LENGTH s.code + 4 <= s.code_max_length /\ (s.code_mode = SOME F) /\
            isNumber x2 /\ small_int (getNumber x2) /\ ~(getNumber x2 < 0))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                 s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))),NONE) *
                         ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.PAT_ABBREV_TAC `pp:word8 list = SNOC xx yy`
    \\ Q.EXISTS_TAC `vals with <| memory := (vals.reg9 + 0x50w =+
         vals.memory (vals.reg9 + 0x50w) + 0x4w) vals.memory ;
         reg14 := (vals.reg1 >>> 2 >>> 8 >>> 8 >>> 8) ;
         reg15 := (vals.memory (vals.reg9 + 0x50w) + 0x4w) ;
         code_list := pp |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with code_ptr := vs.code_ptr + 4w`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ Q.ABBREV_TAC `dm = vals.memory_domain` \\ POP_ASSUM (K ALL_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory` \\ POP_ASSUM (K ALL_TAC)
    \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.PAT_ASSUM `xx = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ ASM_SIMP_TAC std_ss [IMM32_def,LENGTH]
    \\ FULL_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w] \\ SRW_TAC [] []
    \\ TRY DECIDE_TAC
    \\ Q.UNABBREV_TAC `pp`
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
         LIST_REL_def,bc_value_inv_def,x64_addr_def]
    \\ `(n2w (Num i) = (w2w:63 word -> word32) (n2w (Num i)))` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [w2w_n2w])
    \\ FULL_SIMP_TAC std_ss [] \\ Q.SPEC_TAC (`n2w (Num i):63 word`,`w`)
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (LENGTH s.code + 4 <= s.code_max_length /\ (s.code_mode = SOME F) /\
            isNumber x2 /\ small_int (getNumber x2) /\ ~(getNumber x2 < 0))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val _ = add_compiled [th]
  in th end;

val reintro_word_sub32 = SIMP_CONV (srw_ss()) [] ``-(n2w n):word32`` |> GSYM

val addr_calc_def = Define `
  addr_calc x1 x2 x3 = (n2w (Num (getNumber x2)) -
                        n2w (Num (getNumber x3)) -
                        n2w (Num (getNumber x1))) :word32`;

val zHEAP_CODE_SNOC_X2_X3_IMM32 = let
  val th1 = compose_specs ["mov r15,[r9+80]","mov r14,r1","sub r14,r2",
                           "sub r14,r0","shr r14,2"]
  val th = spec "mov [r15], r14b"
  val th = SIMP_RULE std_ss [imm8_sw2sw,zBYTE_MEMORY_def,GSYM zBYTE_MEMORY_Z_def] th
           |> Q.INST [`r15`|->`a + n2w (LENGTH (xs:word8 list))`]
           |> Q.GENL [`g`,`dg`]
           |> MATCH_MP zCODE_HEAP_SNOC |> Q.INST [`xs`|->`code`]
           |> DISCH ``a + n2w (LENGTH (code:word8 list)) = r15:word64``
           |> SIMP_RULE std_ss [] |> UNDISCH
  val thi = compose_specs ["inc r15","shr r14,8"]
  val th2 = compose_specs ["inc r15","mov [r9+80],r15"]
  val th = th |> RW [GSYM zOPTION_CODE_HEAP_def]
              |> DISCH ``SOME F = mode`` |> SIMP_RULE std_ss [] |> UNDISCH
  val th = SPEC_COMPOSE_RULE [th1,th,thi,th,thi,th,thi,th,th2]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val pc = get_pc th
  val pre = ``LENGTH s.code + 4 <= s.code_max_length /\ (s.code_mode = SOME F) /\
              isNumber x1 /\ small_int (getNumber x1) /\ ~(getNumber x1 < 0) /\
              isNumber x2 /\ small_int (getNumber x2) /\ ~(getNumber x2 < 0) /\
              isNumber x3 /\ small_int (getNumber x3) /\ ~(getNumber x3 < 0)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                 s with code := s.code ++ IMM32 (n2w (Num (getNumber x2)) -
                                                 n2w (Num (getNumber x3)) -
                                                 n2w (Num (getNumber x1))),NONE) *
                         ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.PAT_ABBREV_TAC `pp:word8 list = SNOC xx yy`
    \\ Q.EXISTS_TAC `vals with <| memory := (vals.reg9 + 0x50w =+
         vals.memory (vals.reg9 + 0x50w) + 0x4w) vals.memory ;
         reg14 := ((vals.reg1 - vals.reg2 - vals.reg0) >>> 2 >>> 8 >>> 8 >>> 8) ;
         reg15 := (vals.memory (vals.reg9 + 0x50w) + 0x4w) ;
         code_list := pp |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with code_ptr := vs.code_ptr + 4w`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ Q.ABBREV_TAC `dm = vals.memory_domain` \\ POP_ASSUM (K ALL_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory` \\ POP_ASSUM (K ALL_TAC)
    \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.PAT_ASSUM `xx = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ ASM_SIMP_TAC std_ss [IMM32_def,LENGTH]
    \\ FULL_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w] \\ SRW_TAC [] []
    \\ TRY DECIDE_TAC
    \\ Q.UNABBREV_TAC `pp`
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ Cases_on `x3` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
         LIST_REL_def,bc_value_inv_def,x64_addr_def,reintro_word_sub32]
    \\ `(n2w (Num i) = (w2w:63 word -> word32) (n2w (Num i)))` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [w2w_n2w])
    \\ `(n2w (Num i') = (w2w:63 word -> word32) (n2w (Num i')))` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [w2w_n2w])
    \\ `(n2w (Num i'') = (w2w:63 word -> word32) (n2w (Num i'')))` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [w2w_n2w])
    \\ FULL_SIMP_TAC std_ss [] \\ Q.SPEC_TAC (`n2w (Num i):63 word`,`w`)
    \\ FULL_SIMP_TAC std_ss [] \\ Q.SPEC_TAC (`n2w (Num i'):63 word`,`v`)
    \\ FULL_SIMP_TAC std_ss [] \\ Q.SPEC_TAC (`n2w (Num i''):63 word`,`xx`)
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val th = th |> RW [GSYM addr_calc_def]
  val _ = add_compiled [th]
  in th end;


(* rewind code heap by a byte *)

val zHEAP_CODE_FRONT = let
  val th = compose_specs ["sub QWORD [r9+80],1"]
  val th = SPEC_FRAME_RULE th ``zOPTION_CODE_HEAP vals.code_option
             cs.code_heap_length cs.code_heap_ptr vals.code_list``
  val lemma = prove(
    ``SPEC m p c (q * zOPTION_CODE_HEAP code_option code_heap_length
        code_heap_ptr code_list) ==>
      code_list <> [] ==>
      SPEC m p c (q * zOPTION_CODE_HEAP code_option code_heap_length
        code_heap_ptr (FRONT code_list))``,
    REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (SIMP_RULE std_ss [PULL_FORALL,AND_IMP_INTRO] SPEC_WEAKEN)
    \\ Q.EXISTS_TAC `(q *
         zOPTION_CODE_HEAP code_option code_heap_length code_heap_ptr
           code_list)` \\ FULL_SIMP_TAC std_ss [SEP_IMP_def]
    \\ Cases_on `code_option`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zOPTION_CODE_HEAP_def,zCODE_HEAP_def,
         SEP_CLAUSES,SEP_EXISTS_THM,cond_STAR]
    \\ `?y l. code_list = SNOC y l` by METIS_TAC [SNOC_CASES]
    \\ FULL_SIMP_TAC std_ss [FRONT_SNOC] \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `y::ys`
    \\ FULL_SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [SNOC_APPEND,GSYM APPEND_ASSOC,APPEND,LENGTH]
    \\ DECIDE_TAC)
  val th = MATCH_MP lemma th |> UNDISCH
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            s.code <> [])``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                           s with code := FRONT s.code,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| memory := (vals.reg9 + 0x50w =+
         vals.memory (vals.reg9 + 0x50w) - 0x1w) vals.memory ;
         code_list := FRONT vals.code_list |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with <| code_ptr := vs.code_ptr - 1w |>`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.ABBREV_TAC `dm = vals.memory_domain` \\ POP_ASSUM (K ALL_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory` \\ POP_ASSUM (K ALL_TAC)
    \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `xx = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w] \\ SRW_TAC [] []
    \\ `?y l. s.code = SNOC y l` by METIS_TAC [SNOC_CASES]
    \\ FULL_SIMP_TAC std_ss [FRONT_SNOC]
    \\ SRW_TAC [] [ADD1,GSYM word_add_n2w])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (s.code <> [])``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* read code length *)

val zHEAP_CODE_LENGTH = let
  val th = compose_specs ["mov r2,[r9+80]","sub r2,[r9+96]","shl r2,2"]
  val pc = get_pc th
  val pre = ``s.code_mode = SOME F``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,Number (& (LENGTH s.code)),
                                x4,refs,stack,s,NONE) * ~zS * ^pc`
  val blast_lemma5 = prove(
    ``(-1w * w) << 2 + v << 2 = (v - w:word64) << 2``,
    blastLib.BBLAST_TAC);
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.EXISTS_TAC `vals with <| reg2 := (vals.memory (vals.reg9 + 0x50w) -
        vals.memory (vals.reg9 + 0x60w)) << 2 |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`Data (2w * n2w (LENGTH s.code))`,
         `r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss [zOPTION_CODE_HEAP_def,zCODE_HEAP_def]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,SEP_EXISTS_THM,cond_STAR]
    \\ STRIP_TAC
    \\ `LENGTH s.code < 2**62` by (FULL_SIMP_TAC std_ss [] \\ DECIDE_TAC)
    \\ SIMP_TAC std_ss [blast_lemma5,x64_addr_def]
    \\ Q.PAT_ASSUM `bb = vs.code_ptr` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [WORD_ADD_SUB]
    \\ REVERSE STRIP_TAC THEN1
       (WORD_EVAL_TAC
        \\ SIMP_TAC std_ss [bitTheory.BITS_ZERO3]
        \\ SIMP_TAC std_ss [bitTheory.TIMES_2EXP_def]
        \\ AP_TERM_TAC
        \\ Q.MATCH_ABBREV_TAC`(x * 4) MOD b = ((2 * x) MOD c * 2) MOD b`
        \\ `b = 2 * c` by ( SIMP_TAC std_ss [Abbr`b`,Abbr`c`] )
        \\ POP_ASSUM SUBST1_TAC \\ Q.UNABBREV_TAC`b`
        \\ `(2 * x) MOD c = 2 * x` by (MATCH_MP_TAC LESS_MOD
                                       \\ UNABBREV_ALL_TAC
                                       \\ DECIDE_TAC )
        \\ POP_ASSUM SUBST1_TAC
        \\ FULL_SIMP_TAC std_ss [AC MULT_ASSOC MULT_COMM])
    \\ FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,roots_ok_def,MEM]
    \\ STRIP_TAC THEN1 (METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def] \\ Q.EXISTS_TAC `f`
    \\ `small_int (&LENGTH s.code)` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss [LIST_REL_def,bc_value_inv_def,reachable_refs_SIMP]
    \\ STRIP_TAC THEN1
      (SRW_TAC [] [] \\ REPEAT AP_TERM_TAC \\ intLib.COOPER_TAC)
    \\ REPEAT STRIP_TAC \\ FIRST_ASSUM MATCH_MP_TAC
    \\ FULL_SIMP_TAC std_ss [reachable_refs_def]
    \\ Q.LIST_EXISTS_TAC [`x`,`r`] \\ FULL_SIMP_TAC std_ss [MEM])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val _ = add_compiled [th]
  in th end;


(* set code_start *)

val zHEAP_SET_CODE_START = let
  val th = compose_specs ["mov r15,[r9+80]","mov [r9+104],r15"]
  val pc = get_pc th
  val pre = T
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s
    with <| code_start := s.code |>,NONE) * ~zS * ^pc`
  val blast_lemma5 = prove(
    ``(-1w * w) << 2 + v << 2 = (v - w:word64) << 2``,
    blastLib.BBLAST_TAC);
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.EXISTS_TAC `vals with <| reg15 := (vals.memory (vals.reg9 + 0x50w)) ;
         memory := ((vals.reg9 + 0x68w =+
                        vals.memory (vals.reg9 + 0x50w))
                         vals.memory) |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ MATCH_MP_TAC (METIS_PROVE []
         ``(b ==> b2) /\ (c /\ b1) ==> c /\ (b ==> b1 /\ b2)``)
    \\ STRIP_TAC THEN1 (SIMP_TAC (std_ss++star_ss) [])
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs with code_start_ptr := vs.code_ptr`,`r1`,`r2`,`r3`,
         `r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ STRIP_TAC
    THEN1 (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
    \\ Q.ABBREV_TAC `m = vals.memory`
    \\ Q.ABBREV_TAC `dm = vals.memory_domain`
    \\ SEP_W_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND,SEP_CLAUSES]
  val _ = add_compiled [th]
  in th end;


(* jump to code_start *)

val zHEAP_JMP_CODE_START = let
  val th = compose_specs ["mov r15,[r9+104]","jmp r15"]
  val pre = T
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS *
                         zPC (cs.code_heap_ptr + n2w (LENGTH s.code_start))`
  val blast_lemma5 = prove(
    ``(-1w * w) << 2 + v << 2 = (v - w:word64) << 2``,
    blastLib.BBLAST_TAC);
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.EXISTS_TAC `vals with <| reg15 := (vals.memory (vals.reg9 + 104w)) |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ `vals.memory (vals.reg9 + 0x68w) =
        n2w (LENGTH s.code_start) + cs.code_heap_ptr` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def]
      \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC (METIS_PROVE []
         ``(b ==> b2) /\ (c /\ b1) ==> c /\ (b ==> b1 /\ b2)``)
    \\ STRIP_TAC THEN1 (SIMP_TAC (std_ss++star_ss) [])
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC,SEP_CLAUSES] \\ SEP_R_TAC
    \\ Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO]
              |> RW [GSYM SPEC_MOVE_COND,SEP_CLAUSES]
  in th end;


(* switch code_mode from SOME T to SOME F *)

val zHEAP_CODE_UNSAFE = let
  val th = zCODE_HEAP_UNSAFE |> RW [GSYM zOPTION_CODE_HEAP_def]
                             |> RW [ASSUME ``SOME T = mode``]
  val th1 = compose_specs ["xor r15,r15"]
  val th = SPEC_COMPOSE_RULE [th,th1]
  val pc = get_pc th
  val pre = ``s.code_mode = SOME T``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                                s with code_mode := SOME F,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.EXISTS_TAC `vals with <| code_option := SOME F ; reg15 := 0w |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val _ = add_compiled [th]
  in th end;


(* switch code_mode from SOME F to SOME T *)

val zHEAP_CODE_SAFE = let
  val th1 = compose_specs ["mov r15,r0","mov r14,r1","mov r13,r2",
                           "mov r12,r3","xor r0,r0"]
  val th2 = zCODE_HEAP_SAFE |> RW [GSYM zOPTION_CODE_HEAP_def]
  val th3 = compose_specs ["mov r0,r15","mov r1,r14","mov r2,r13","mov r3,r12"]
  val th = SPEC_COMPOSE_RULE [th1,th2,th3]
  val th = th |> RW [ASSUME ``SOME F = mode``]
  val pc = get_pc th
  val pre = ``s.code_mode = SOME F``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
                                s with code_mode := SOME T,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC \\ STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ SIMP_TAC std_ss [LENGTH_SNOC]
    \\ Q.EXISTS_TAC `vals with <| code_option := SOME T ;
           reg15 := vals.reg0 ;
           reg14 := vals.reg1 ;
           reg13 := vals.reg2 ;
           reg12 := vals.reg3 |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ d ==> b /\ (c ==> d)``)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [code_heap_inv_def,heap_vars_ok_def])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
       AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val _ = add_compiled [th]
  in th end;


(* test for printing_on *)

val heap_inv_IGNORE_reg15 = prove(
  ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals ==>
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) (vals with reg15 := w)``,
  SIMP_TAC (srw_ss()) [heap_inv_def]);

val zHEAP_TEST_PRINTING_ON = let
  val th = spec "mov r15,DWORD [r9+144]"
  val th = SPEC_COMPOSE_RULE [th,spec "test r15,r15"]
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
              |> UNDISCH |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (s.local.printing_on = 0w)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ NTAC 2 STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC
      \\ POP_ASSUM MP_TAC \\ SIMP_TAC std_ss [heap_vars_ok_def]
      \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals with <| reg15 := vals.memory (vals.reg9 + 144w) |>`]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ `(vals.memory (vals.reg9 + 0x90w)) = (s.local.printing_on)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC \\ SIMP_TAC std_ss [])
    \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE STRIP_TAC
    THEN1 FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC heap_inv_IGNORE_reg15 \\ ASM_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;


(* set printing_on to 1w *)

val zHEAP_SET_PRINTING_ON = let
  val th = compose_specs ["mov r15,1","mov [r9+144],r15"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s with local := (s.local with printing_on := 1w),
       NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ NTAC 2 STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC
      \\ POP_ASSUM MP_TAC \\ SIMP_TAC std_ss [heap_vars_ok_def]
      \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals with <| reg15 := 1w ;
         memory := ((vals.reg9 + 0x90w =+ 0x1w) vals.memory) |>`]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ REVERSE STRIP_TAC
    THEN1 FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC heap_inv_IGNORE_reg15
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with printing_on := 1w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `m = vals.memory`
    \\ Q.ABBREV_TAC `dm = vals.memory_domain`
    \\ SEP_W_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;


(* set printing_on to 0w *)

val zHEAP_SET_PRINTING_OFF = let
  val th = compose_specs ["mov r15,0","mov [r9+144],r15"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s with local := (s.local with printing_on := 0w),
       NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ NTAC 2 STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC
      \\ POP_ASSUM MP_TAC \\ SIMP_TAC std_ss [heap_vars_ok_def]
      \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals with <| reg15 := 0w ;
         memory := ((vals.reg9 + 0x90w =+ 0x0w) vals.memory) |>`]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ REVERSE STRIP_TAC
    THEN1 FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC heap_inv_IGNORE_reg15
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with printing_on := 0w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,one_list_def,
        word_arith_lemma1,STAR_ASSOC] \\ SEP_R_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `m = vals.memory`
    \\ Q.ABBREV_TAC `dm = vals.memory_domain`
    \\ SEP_W_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;


(* moves *)

val move_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x1i,r1i);(x2i,r2i);(x3i,r3i);(x4i,r4i)]`]
  |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

fun zHEAP_Move ((ni,ri),(nj,rj)) = let
  (* x64_encodeLib.x64_encode "mov r0d,50000" *)
  val i = x64_encodeLib.x64_encode ("mov "^ri^" , "^rj)
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64 i
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH T
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val src = ``if ^nj = 1 then x1 else
              if ^nj = 2 then x2 else
              if ^nj = 3 then x3 else x4:bc_value``
  val th = th |> Q.SPEC
    `zHEAP (cs,if ^ni = 1 then ^src else x1,
               if ^ni = 2 then ^src else x2,
               if ^ni = 3 then ^src else x3,
               if ^ni = 4 then ^src else x4,
               refs,stack,s,NONE) * ~zS * ^pc`
  val vals_src = ``if ^nj = 1 then vals.reg0 else
                   if ^nj = 2 then vals.reg1 else
                   if ^nj = 3 then vals.reg2 else vals.reg3``
  val root_src = ``if ^nj = 1 then r1 else
                   if ^nj = 2 then r2 else
                   if ^nj = 3 then r3 else r4: 63 word heap_address``
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <|
         reg0 := if ^ni = 1 then ^vals_src else vals.reg0 ;
         reg1 := if ^ni = 2 then ^vals_src else vals.reg1 ;
         reg2 := if ^ni = 3 then ^vals_src else vals.reg2 ;
         reg3 := if ^ni = 4 then ^vals_src else vals.reg3 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
         `if ^ni = 1 then ^root_src else r1`,
         `if ^ni = 2 then ^root_src else r2`,
         `if ^ni = 3 then ^root_src else r3`,
         `if ^ni = 4 then ^root_src else r4`,
         `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
    \\ MATCH_MP_TAC move_lemma
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

val x1 = (``1:num``,"r0")
val x2 = (``2:num``,"r1")
val x3 = (``3:num``,"r2")
val x4 = (``4:num``,"r3")

fun cross_prod [] ys = []
  | cross_prod (x::xs) ys = map (fn y => (x,y)) ys :: cross_prod xs ys

val all_moves = cross_prod [x1,x2,x3,x4] [x1,x2,x3,x4] |> Lib.flatten
                |> filter (fn (x,y) => (x <> y))

val moves = map zHEAP_Move all_moves;

val zHEAP_MOVE_12 = zHEAP_Move (x2,x1)
val zHEAP_MOVE_21 = el 1 moves
val zHEAP_MOVE_32 = el 5 moves
val zHEAP_MOVE_13 = zHEAP_Move (x3,x1)
val zHEAP_MOVE_31 = zHEAP_Move (x1,x3)
val zHEAP_MOVE_32 = zHEAP_Move (x2,x3)
val zHEAP_MOVE_23 = zHEAP_Move (x3,x2)
val zHEAP_MOVE_34 = zHEAP_Move (x4,x3)
val zHEAP_MOVE_14 = zHEAP_Move (x4,x1)
val zHEAP_MOVE_41 = zHEAP_Move (x1,x4)
val zHEAP_MOVE_24 = zHEAP_Move (x4,x2)
val zHEAP_MOVE_42 = zHEAP_Move (x2,x4)
val zHEAP_MOVE_34 = zHEAP_Move (x4,x3)
val zHEAP_MOVE_43 = zHEAP_Move (x3,x4)


(* load const number *)

val swap12_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x2,r2);(x1,r1);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val swap13_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x3,r3);(x2,r2);(x1,r1);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val swap14_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x4,r4);(x2,r2);(x3,r3);(x1,r1)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val swap_1_lemmas = LIST_CONJ [swap12_lemma,swap13_lemma,swap14_lemma];

val get_tag_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1)]`,`[]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM]

val abs_ml_inv_Num = prove(
  ``abs_ml_inv (x::stack) refs (r1::roots,heap,a,sp) l /\ n < 2305843009213693952 ==>
    abs_ml_inv (Number (&n)::stack) refs (Data (0x2w * n2w n)::roots,heap,a,sp) l``,
  REPEAT STRIP_TAC
  \\ `abs_ml_inv (stack) refs (roots,heap,a,sp) l` by ALL_TAC
  THEN1 (METIS_TAC [get_tag_lemma])
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def]
  \\ FULL_SIMP_TAC (srw_ss()) [roots_ok_def,MEM]
  \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
  \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
  \\ REPEAT STRIP_TAC THEN1
   (`small_int (&n)` by ALL_TAC
    THEN1 (SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ ASM_SIMP_TAC std_ss [bc_value_inv_def] \\ SRW_TAC [] [])
  \\ `reachable_refs stack refs n'` by ALL_TAC
  \\ FULL_SIMP_TAC std_ss [reachable_refs_def,MEM,PULL_EXISTS]
  \\ NTAC 3 (POP_ASSUM MP_TAC)
  \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]
  \\ METIS_TAC []) |> GEN_ALL;

val abs_ml_inv_Num_new = prove(
  ``abs_ml_inv (x::stack) refs (r1::roots,heap,a,sp) l /\ n < 4611686018427387904 ==>
    abs_ml_inv (Number (&n)::stack) refs (Data (0x2w * n2w n)::roots,heap,a,sp) l``,
  REPEAT STRIP_TAC
  \\ `abs_ml_inv (stack) refs (roots,heap,a,sp) l` by ALL_TAC
  THEN1 (METIS_TAC [get_tag_lemma])
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def]
  \\ FULL_SIMP_TAC (srw_ss()) [roots_ok_def,MEM]
  \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
  \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
  \\ REPEAT STRIP_TAC THEN1
   (`small_int (&n)` by ALL_TAC
    THEN1 (SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ ASM_SIMP_TAC std_ss [bc_value_inv_def] \\ SRW_TAC [] [])
  \\ `reachable_refs stack refs n'` by ALL_TAC
  \\ FULL_SIMP_TAC std_ss [reachable_refs_def,MEM,PULL_EXISTS]
  \\ NTAC 3 (POP_ASSUM MP_TAC)
  \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]
  \\ METIS_TAC []) |> GEN_ALL;

fun zHEAP_Num (i,n) = let
  (* x64_encodeLib.x64_encode "mov r0d,50000" *)
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64 i
  val lemma = prove(
    ``4 * k < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (4 * k)):word32)) MOD 4294967296)) =
       n2w (4 * k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(4 * k) < 4294967296 /\ ~(2147483648 <= 4 * k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = th |> Q.INST [`rip`|->`p`,`imm32`|->`n2w (4 * k)`] |> RW [lemma]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            4 * (k:num) < 2**31)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,if ^n = 1 then Number (& k) else x1,
               if ^n = 2 then Number (& k) else x2,
               if ^n = 3 then Number (& k) else x3,
               if ^n = 4 then Number (& k) else x4,
               refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <|
         reg0 := if ^n = 1 then n2w (4 * k) else vals.reg0 ;
         reg1 := if ^n = 2 then n2w (4 * k) else vals.reg1 ;
         reg2 := if ^n = 3 then n2w (4 * k) else vals.reg2 ;
         reg3 := if ^n = 4 then n2w (4 * k) else vals.reg3 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
         `if ^n = 1 then Data (2w * n2w k) else r1`,
         `if ^n = 2 then Data (2w * n2w k) else r2`,
         `if ^n = 3 then Data (2w * n2w k) else r3`,
         `if ^n = 4 then Data (2w * n2w k) else r4`,
         `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REPEAT STRIP_TAC THEN1
     (`k < 2305843009213693952` by DECIDE_TAC
      \\ METIS_TAC [abs_ml_inv_Num,swap_1_lemmas])
    \\ `(2 * k) < 9223372036854775808` by DECIDE_TAC
    \\ ASM_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,word_mul_n2w,
          w2w_def,w2n_n2w,MULT_ASSOC]);
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (4 * (k:num) < 2**31)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_Num1 = zHEAP_Num ("B8",``1:num``)
val zHEAP_Num2 = zHEAP_Num ("B9",``2:num``)
val zHEAP_Num3 = zHEAP_Num ("BA",``3:num``)
val zHEAP_Num4 = zHEAP_Num ("BB",``4:num``)

fun up_to 0 = [] | up_to k = up_to (k-1) @ [k-1]

fun derive_const_assign th k = let
  val th = th |> INST [``k:num``|->numLib.term_of_int k]
  val th = th |> SIMP_RULE (srw_ss()) [w2w_def,w2n_n2w,SEP_CLAUSES]
  val _ = add_compiled [th];
  in () end;

val _ = map (derive_const_assign zHEAP_Num1) (up_to 256)
val _ = map (derive_const_assign zHEAP_Num2) (up_to 256)
val _ = map (derive_const_assign zHEAP_Num3) (up_to 256)
val _ = map (derive_const_assign zHEAP_Num4) (up_to 256)

val zHEAP_Num1_globals_count =
  zHEAP_Num1 |> Q.INST [`k`|->`globals_count`]
    |> CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [globals_count_def,SEP_CLAUSES]))
    |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)

val zHEAP_Num1_0 =
  zHEAP_Num1 |> Q.INST [`k`|->`0`]
    |> CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [globals_count_def,SEP_CLAUSES]))
    |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)

val zHEAP_Num2_0 =
  zHEAP_Num2 |> Q.INST [`k`|->`0`]
    |> CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [globals_count_def,SEP_CLAUSES]))
    |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)

val zHEAP_Num3_0 =
  zHEAP_Num3 |> Q.INST [`k`|->`0`]
    |> CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [globals_count_def,SEP_CLAUSES]))
    |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)


(* cons with NIL *)

val abs_ml_inv_Block_NIL = prove(
  ``abs_ml_inv (x::stack) refs (r1::roots,heap,a,sp) l /\ n < 2305843009213693952 ==>
    abs_ml_inv (Block (&n) []::stack) refs
      (Data (n2w (2 * n + 1))::roots,heap,a,sp) l``,
  REPEAT STRIP_TAC
  \\ `abs_ml_inv (stack) refs (roots,heap,a,sp) l` by ALL_TAC
  THEN1 (METIS_TAC [get_tag_lemma])
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def]
  \\ FULL_SIMP_TAC (srw_ss()) [roots_ok_def,MEM]
  \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
  \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
  \\ ASM_SIMP_TAC std_ss [bc_value_inv_def,word_mul_n2w,word_add_n2w]
  \\ REPEAT STRIP_TAC
  \\ `reachable_refs stack refs n'` by ALL_TAC
  \\ FULL_SIMP_TAC std_ss [reachable_refs_def,MEM,PULL_EXISTS]
  \\ NTAC 3 (POP_ASSUM MP_TAC)
  \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,MAP,FLAT]
  \\ METIS_TAC []) |> GEN_ALL;

fun zHEAP_Nil (i,n) = let
  (* x64_encodeLib.x64_encode "mov r0d,50000" *)
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64 i
  val lemma = prove(
    ``4 * k + 2 < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (4 * k + 2)):word32)) MOD 4294967296)) =
       n2w (4 * k + 2):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(4 * k + 2) < 4294967296 /\ ~(2147483648 <= 4 * k + 2)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = th |> Q.INST [`rip`|->`p`,`imm32`|->`n2w (4 * k + 2)`] |> RW [lemma]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            4 * (k:num) + 2 < 2**31)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,if ^n = 1 then Block (& k) [] else x1,
               if ^n = 2 then Block (& k) [] else x2,
               if ^n = 3 then Block (& k) [] else x3,
               if ^n = 4 then Block (& k) [] else x4,
               refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <|
         reg0 := if ^n = 1 then n2w (4 * k + 2) else vals.reg0 ;
         reg1 := if ^n = 2 then n2w (4 * k + 2) else vals.reg1 ;
         reg2 := if ^n = 3 then n2w (4 * k + 2) else vals.reg2 ;
         reg3 := if ^n = 4 then n2w (4 * k + 2) else vals.reg3 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
         `if ^n = 1 then Data (2w * n2w k + 1w) else r1`,
         `if ^n = 2 then Data (2w * n2w k + 1w) else r2`,
         `if ^n = 3 then Data (2w * n2w k + 1w) else r3`,
         `if ^n = 4 then Data (2w * n2w k + 1w) else r4`,
         `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REPEAT STRIP_TAC THEN1
     (`k < 2305843009213693952` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss [word_mul_n2w,word_add_n2w]
      \\ METIS_TAC [abs_ml_inv_Block_NIL,swap_1_lemmas])
    \\ `(2 * k + 1) < 9223372036854775808` by DECIDE_TAC
    \\ ASM_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,word_mul_n2w,
          w2w_def,w2n_n2w,MULT_ASSOC,word_add_n2w,MULT_ASSOC]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,MULT_ASSOC]);
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (4 * (k:num) + 2 < 2**31)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val lemmas = CONJ (EVAL ``bool_to_val F``) (EVAL ``bool_to_val T``) |> GSYM;

fun foo th = let
  val th0 = Q.INST [`k`|->`0`] th
            |> SIMP_RULE (srw_ss()) [SEP_CLAUSES] |> RW [lemmas]
  val th1 = Q.INST [`k`|->`1`] th
            |> SIMP_RULE (srw_ss()) [SEP_CLAUSES] |> RW [lemmas]
  val th2 = Q.INST [`k`|->`9`] th
            |> SIMP_RULE (srw_ss()) [SEP_CLAUSES] |> RW [lemmas]
  val th3 = Q.INST [`k`|->`10`] th
            |> SIMP_RULE (srw_ss()) [SEP_CLAUSES] |> RW [lemmas]
  val _ = add_compiled [th0];
  val _ = add_compiled [th1];
  val _ = add_compiled [th2];
  val _ = add_compiled [th3];
  in th end

val zHEAP_Nil1 = zHEAP_Nil ("B8",``1:num``) |> foo
val zHEAP_Nil2 = zHEAP_Nil ("B9",``2:num``) |> foo
val zHEAP_Nil3 = zHEAP_Nil ("BA",``3:num``) |> foo
val zHEAP_Nil4 = zHEAP_Nil ("BB",``4:num``) |> foo

val zHEAP_Nil = zHEAP_Nil ("B8",``1:num``)

(* push x1,x2,x3,x4 *)

val push_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4);(x5,r5)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM]

val side = ``NONE :(num # x64_vals -> bool) option``
val gc_side = ``SOME (\((sp :num),(vals :x64_vals)).
                  (ttt13 = vals.reg13) /\ (ttt14 = vals.reg14))``

fun zHEAP_PUSH n side = let
  val th = if n = ``1:num`` then x64_push_r0 else
           if n = ``2:num`` then x64_push_r1 else
           if n = ``3:num`` then x64_push_r2 else
           if n = ``4:num`` then x64_push_r3 else fail()
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^side) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,
                   (if ^n = 1 then x1 else
                    if ^n = 2 then x2 else
                    if ^n = 3 then x3 else
                    if ^n = 4 then x4 else ARB)::stack,s,^side) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `(vals:x64_vals) with <| stack :=
         (if ^n = 1 then ((vals:x64_vals).reg0):word64 else
          if ^n = 2 then vals.reg1 else
          if ^n = 3 then vals.reg2 else
          if ^n = 4 then vals.reg3 else ARB)::vals.stack |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`
          (if ^n = 1 then r1 else
           if ^n = 2 then r2 else
           if ^n = 3 then r3 else
           if ^n = 4 then r4 else ARB)::roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND]
    \\ MATCH_MP_TAC push_lemma \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^side) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_PUSH1 = zHEAP_PUSH ``1:num`` side
val zHEAP_PUSH2 = zHEAP_PUSH ``2:num`` side
val zHEAP_PUSH3 = zHEAP_PUSH ``3:num`` side
val zHEAP_PUSH4 = zHEAP_PUSH ``4:num`` side

val _ = add_compiled [zHEAP_PUSH1,zHEAP_PUSH2,zHEAP_PUSH3,zHEAP_PUSH4];

val zHEAP_PUSH1_GC = zHEAP_PUSH ``1:num`` gc_side
val zHEAP_PUSH2_GC = zHEAP_PUSH ``2:num`` gc_side
val zHEAP_PUSH3_GC = zHEAP_PUSH ``3:num`` gc_side
val zHEAP_PUSH4_GC = zHEAP_PUSH ``4:num`` gc_side

(* pop x1,x2,x3,x4 *)

val pop_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4);(x5,r5)]`,
              `[(x1',r1');(x2',r2');(x3',r3');(x4',r4')]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

fun zHEAP_POP n side = let
  val th = if n = ``1:num`` then x64_pop_r0 else
           if n = ``2:num`` then x64_pop_r1 else
           if n = ``3:num`` then x64_pop_r2 else
           if n = ``4:num`` then x64_pop_r3 else fail()
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^side) vals /\ stack <> [])``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val hd_stack = ``(HD stack):bc_value``
  val x1 = if n = ``1:num`` then hd_stack else ``x1:bc_value``
  val x2 = if n = ``2:num`` then hd_stack else ``x2:bc_value``
  val x3 = if n = ``3:num`` then hd_stack else ``x3:bc_value``
  val x4 = if n = ``4:num`` then hd_stack else ``x4:bc_value``
  val th = th |> Q.SPEC `zHEAP (cs,^x1,^x2,^x3,^x4,refs,TL stack,s,^side) * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val r0 = if n = ``1:num`` then ``HD vals.stack`` else ``vals.reg0``
  val r1 = if n = ``2:num`` then ``HD vals.stack`` else ``vals.reg1``
  val r2 = if n = ``3:num`` then ``HD vals.stack`` else ``vals.reg2``
  val r3 = if n = ``4:num`` then ``HD vals.stack`` else ``vals.reg3``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def] \\ Cases_on `roots`
      \\ FULL_SIMP_TAC std_ss [MAP,APPEND,NOT_CONS_NIL])
    \\ Q.EXISTS_TAC `vals with <| stack := TL vals.stack ;
                                  reg0 := ^r0 ;
                                  reg1 := ^r1 ;
                                  reg2 := ^r2 ;
                                  reg3 := ^r3 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,
         if n = ``1:num`` then `HD roots` else `r1`,
         if n = ``2:num`` then `HD roots` else `r2`,
         if n = ``3:num`` then `HD roots` else `r3`,
         if n = ``4:num`` then `HD roots` else `r4`,`TL roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Cases_on `stack` \\ FULL_SIMP_TAC std_ss []
    \\ Cases_on `roots` \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1,MAP,HD,TL,APPEND]
    \\ MATCH_MP_TAC pop_lemma \\ FULL_SIMP_TAC std_ss []
    \\ METIS_TAC [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
            |> DISCH ``(stack:bc_value list) <> []``
            |> SIMP_RULE std_ss [] |> UNDISCH
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^side) * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  in th end;

val zHEAP_POP1 = zHEAP_POP ``1:num`` side
val zHEAP_POP2 = zHEAP_POP ``2:num`` side
val zHEAP_POP3 = zHEAP_POP ``3:num`` side
val zHEAP_POP4 = zHEAP_POP ``4:num`` side

val _ = add_compiled [zHEAP_POP1,zHEAP_POP2,zHEAP_POP3,zHEAP_POP4]

val zHEAP_POP1_GC = zHEAP_POP ``1:num`` gc_side
val zHEAP_POP2_GC = zHEAP_POP ``2:num`` gc_side
val zHEAP_POP3_GC = zHEAP_POP ``3:num`` gc_side
val zHEAP_POP4_GC = zHEAP_POP ``4:num`` gc_side


(* pops *)

val pops_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]++ZIP (xs,ys)`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

val MAP_FST_ZIP = prove(
  ``!xs ys.
      (LENGTH xs = LENGTH ys) ==>
      (MAP FST (ZIP(xs,ys)) = xs) /\ (MAP SND (ZIP(xs,ys)) = ys)``,
  Induct \\ Cases_on `ys` \\ SRW_TAC [] [LENGTH,ADD1,ZIP]);

val zHEAP_POPS = let
  val th = x64_pops |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            k <= LENGTH stack /\ k < 268435456)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,DROP k stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH
      \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND] \\ DECIDE_TAC)
    \\ Q.EXISTS_TAC `vals with <| stack := DROP k vals.stack |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`DROP k roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND,HD,TL]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ `k <= LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_EQ_LENGTH
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.MATCH_ASSUM_RENAME_TAC `stack = zs1 ++ zs2`
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND,GSYM APPEND_ASSOC]
    \\ Tactical.REVERSE STRIP_TAC
    THEN1 (METIS_TAC [rich_listTheory.DROP_LENGTH_APPEND,LENGTH_MAP])
    \\ `DROP k (ys1 ++ ys2) = ys2` by METIS_TAC [rich_listTheory.DROP_LENGTH_APPEND]
    \\ `DROP k (zs1 ++ zs2) = zs2` by METIS_TAC [rich_listTheory.DROP_LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC pops_lemma
    \\ ONCE_REWRITE_TAC [CONJ_COMM]
    \\ Q.LIST_EXISTS_TAC [`ys1`,`zs1`]
    \\ STRIP_TAC THEN1 METIS_TAC []
    \\ `LENGTH zs1 = LENGTH ys1` by FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC MAP_FST_ZIP \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
            |> DISCH ``k <= LENGTH (stack:bc_value list)``
            |> DISCH ``k < 268435456:num``
            |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* load *)

val load_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x2,r2);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

val EL_LENGTH = prove(
  ``!xs. EL (LENGTH xs) (xs ++ y::ys) = y``,
  Induct \\ FULL_SIMP_TAC std_ss [LENGTH,EL,APPEND,HD,TL]);

val zHEAP_LOAD = let
  val th = x64_el_r0_imm |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            k < LENGTH stack /\ k < 268435456)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,EL k stack,x2,x3,x4,refs,stack,s,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH
      \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND] \\ DECIDE_TAC)
    \\ Q.EXISTS_TAC `vals with <| reg0 := EL k vals.stack |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`EL k roots`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND,HD,TL]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ `k < LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_LENGTH
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.MATCH_ASSUM_RENAME_TAC `stack = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND,GSYM APPEND_ASSOC,MAP]
    \\ Tactical.REVERSE STRIP_TAC
    THEN1 (METIS_TAC [EL_LENGTH,LENGTH_MAP,APPEND])
    \\ `EL k (ys1 ++ y::ys2) = y` by METIS_TAC [EL_LENGTH]
    \\ `EL k (zs1 ++ z::zs2) = z` by METIS_TAC [EL_LENGTH]
    \\ FULL_SIMP_TAC std_ss []
    \\ (move_thm
        |> Q.SPECL [`[x1]`,`[r1]`,`[x1]`,`[r1]`,`[x2;x3;x4]++xs`,`[r2;r3;r4]++rs`]
        |> SIMP_RULE std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC] |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC duplicate1_thm
    \\ (move_thm
        |> Q.SPECL [`[]`,`[]`,`[x2;x3;x4]++xs`,`[r2;r3;r4]++rs`,`[x1]`,`[r1]`]
        |> SIMP_RULE std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC] |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC load_lemma \\ METIS_TAC [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
            |> DISCH ``k < LENGTH (stack:bc_value list)``
            |> DISCH ``k < 268435456:num``
            |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;

fun gen_load k = let
  val th = zHEAP_LOAD |> Q.INST [`k`|->k] |> SIMP_RULE (srw_ss()) [IMM32_def]
  val _ = add_compiled [th]
  in th end

val _ = map gen_load [`0:num`, `1:num`, `2:num`, `3:num`,
                      `4:num`, `5:num`, `6:num`, `7:num`]


(* store *)

val store_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1)]`,`[]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

val zHEAP_STORE = let
  val th = x64_lupdate_r0_imm |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            k < LENGTH stack /\ k < 268435456)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,LUPDATE x1 k stack,s,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH
      \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND] \\ DECIDE_TAC)
    \\ Q.EXISTS_TAC `vals with <| stack := LUPDATE vals.reg0 k vals.stack |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`LUPDATE r1 k roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND,HD,TL]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ `k < LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_LENGTH
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.MATCH_ASSUM_RENAME_TAC `stack = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND,GSYM APPEND_ASSOC,MAP]
    \\ `LUPDATE r1 k (ys1 ++ y::ys2) = ys1 ++ r1::ys2` by METIS_TAC [LUPDATE_LENGTH]
    \\ `LUPDATE x1 k (zs1 ++ z::zs2) = zs1 ++ x1::zs2` by METIS_TAC [LUPDATE_LENGTH]
    \\ FULL_SIMP_TAC std_ss []
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,APPEND]
      \\ `k = LENGTH (MAP (x64_addr vs.current_heap) ys1)` by
           FULL_SIMP_TAC std_ss [LENGTH_MAP]
      \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
      \\ SIMP_TAC std_ss [LUPDATE_LENGTH] \\ SRW_TAC [] [])
    \\ (move_thm
        |> Q.SPECL [`[x1]`,`[r1]`,`[x1]`,`[r1]`,`[x2;x3;x4]++xs`,`[r2;r3;r4]++rs`]
        |> SIMP_RULE std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC] |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC duplicate1_thm
    \\ MATCH_MP_TAC store_lemma
    \\ Q.LIST_EXISTS_TAC [`z`,`y`]
    \\ (move_thm
        |> Q.SPECL [`[]`,`[]`,`[x1;x2;x3;x4]++xs`,`[r1;r2;r3;r4]++rs`,`[z]`,`[y]`]
        |> SIMP_RULE std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC] |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
            |> DISCH ``k < LENGTH (stack:bc_value list)``
            |> DISCH ``k < 268435456:num``
            |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* padding *)

val zHEAP_NOP = let
  val th = compose_specs ["xor r15,r15"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with <| reg15 := 0w |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_ID_1234 = let
  val (th,goal) = SPEC_WEAKEN_RULE zHEAP_NOP
    ``let (x1,x2,x3,x4) = ID (x1,x2,x3,x4) in
       (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * zS * zPC (p + 0x3w))``
  val lemma = prove(goal,FULL_SIMP_TAC std_ss [SEP_IMP_REFL,ID_def,LET_DEF])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;

val zHEAP_NOP2 = let
  val th = compose_specs ["add r15,0"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* main part of Shift instruction *)

val NTIMES_def = Define `
  (NTIMES 0 xs = []) /\
  (NTIMES (SUC n) xs = xs ++ NTIMES n xs)`;

val n_times_def = Define `
  (n_times 0 f x = x) /\
  (n_times (SUC n) f x = n_times n f (f x))`;

val n_times_pre_def = Define `
  (n_times_pre 0 f g x = T) /\
  (n_times_pre (SUC n) f g x = g x /\ n_times_pre n f g (f x))`;

val LENGTH_NTIMES = prove(
  ``!k xs. LENGTH (NTIMES k xs) = k * LENGTH xs``,
  Induct \\ EVAL_TAC \\ ASM_SIMP_TAC std_ss [LENGTH_APPEND,MULT_CLAUSES]
  \\ DECIDE_TAC);

val LENGTH_IMM32 = prove(
  ``LENGTH (IMM32 w) = 4``,
  EVAL_TAC);

val SPEC_NTIMES = prove(
  ``(!x t. SPEC X64_MODEL
                (p x * zPC t * cond (g x)) {(t,ys)}
                (p (f x) * zPC (t + n2w (LENGTH ys)))) ==>
    (!x t. SPEC X64_MODEL
                (p x * zPC t * cond (n_times_pre k f g x)) {(t,NTIMES k ys)}
                (p (n_times k f x) * zPC (t + n2w (LENGTH (NTIMES k ys)))))``,
  STRIP_TAC \\ Induct_on `k`
  \\ SIMP_TAC std_ss [n_times_pre_def,n_times_def,NTIMES_def,LENGTH,
      WORD_ADD_0,SEP_CLAUSES,SPEC_REFL]
  \\ FULL_SIMP_TAC std_ss [SPEC_MOVE_COND] \\ REPEAT STRIP_TAC
  \\ MATCH_MP_TAC (prog_x64Theory.SPEC_X64_MERGE_CODE
       |> RW [AND_IMP_INTRO] |> GEN_ALL)
  \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC (progTheory.SPEC_COMPOSE |> Q.SPECL [`x`,`p`,`{t}`,`m`,`{t'}`]
       |> RW [INSERT_UNION_EQ,UNION_EMPTY] |> GEN_ALL)
  \\ Q.EXISTS_TAC `(p (f x) * zPC (t + n2w (LENGTH ys)))`
  \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,GSYM word_arith_lemma1,WORD_ADD_ASSOC])
  |> Q.INST [`k`|->`i`];

val n_stores_def = Define `
  n_stores i k x1 (stack:bc_value list) =
    (n_times i
       (\(x1,stack). (HD stack,LUPDATE (HD stack) k (TL stack)))
          (x1,stack))`;

val n_stores_pre_def = Define `
  n_stores_pre i k x1 (stack:bc_value list) =
    (n_times_pre i
             ((x1,stack). (HD stack,LUPDATE (HD stack) k (TL stack)))
             ((x1,stack).
                k < 268435456  k < LENGTH (TL stack)  stack  []) (x1,stack))`;

val zHEAP_SIMPLE_Shift = let
  val th = SPEC_COMPOSE_RULE [zHEAP_POP1,zHEAP_STORE]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
  val th = CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [LENGTH,ADD1,IMM32_def])) th
  val th = SIMP_RULE std_ss [GSYM LENGTH_NIL,LENGTH_LUPDATE,APPEND] th
  val th = SIMP_RULE (std_ss++sep_cond_ss) [LENGTH_NIL] th
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``((\(x1,stack). zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS) (x1,stack) *
       zPC p * cond ((\(x1,stack). k < 268435456 /\
          k < LENGTH (TL stack) /\ stack <> []) (x1,stack)))``
  val th = MP th (prove(goal,
    SIMP_TAC (std_ss++star_ss) [SEP_IMP_def,cond_STAR,GSYM LENGTH_NIL]))
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``((\(x1,stack). zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS)
         ((\(x1,stack). (HD stack,
                         LUPDATE (HD stack) k (TL stack))) (x1:bc_value,stack))) *
       zPC (p + n2w (LENGTH (0x48w::0x58w::0x48w::0x89w::0x84w::
                             0x24w::IMM32 (n2w (8 * k)))))``
  val lemma = SIMP_CONV (std_ss++star_ss) [SEP_IMP_REFL,cond_STAR,
                 IMM32_def,LENGTH,APPEND] goal
  val th = RW [lemma] th
  val th = INST [``x1:bc_value``|->``FST (y:bc_value # bc_value list)``,
                 ``stack:bc_value list``|->``SND (y:bc_value # bc_value list)``] th
           |> RW [PAIR] |> Q.GENL [`p`,`y`]
  val th = HO_MATCH_MP SPEC_NTIMES th
  val th = th |> Q.SPEC `(x1,stack)`
              |> SIMP_RULE std_ss [LENGTH_NTIMES,LENGTH,LENGTH_APPEND,LENGTH_IMM32]
              |> RW [GSYM n_stores_def,GSYM n_stores_pre_def]
              |> CONV_RULE (DEPTH_CONV PairRules.PBETA_CONV)
              |> Q.INST [`k`|->`n`] |> SPEC_ALL
  val th1 = SPEC_COMPOSE_RULE [zHEAP_POPS,zHEAP_MOVE_21]
  val th1 = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th1
            |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32]
  val th = SPEC_COMPOSE_RULE [zHEAP_MOVE_12,th,th1]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
           |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
           |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32,LENGTH_APPEND,LENGTH_NTIMES]
  in th end;

val SND_n_stores = prove(
  ``!xs ys ts zs n x1.
      (LENGTH ts = LENGTH xs) /\ (n = LENGTH (xs ++ ys) - 1) /\
      LENGTH (xs ++ ys) < 268435457 ==>
      n_stores_pre (LENGTH xs) n x1 (xs ++ ys ++ ts ++ zs) /\
      (SND (n_stores (LENGTH xs) n x1 (xs ++ ys ++ ts ++ zs)) =
       ys ++ xs ++ zs)``,
  SIMP_TAC std_ss [] \\ Induct
  \\ Cases_on `ts` \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1] THEN1
   (FULL_SIMP_TAC std_ss [APPEND,APPEND_NIL,LENGTH] \\ EVAL_TAC
    \\ SIMP_TAC std_ss [rich_listTheory.DROP_LENGTH_APPEND])
  \\ REPEAT GEN_TAC \\ STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [n_stores_def,n_stores_pre_def,GSYM ADD1]
  \\ SIMP_TAC std_ss [n_times_def,n_times_pre_def,HD,APPEND,TL,LENGTH,ADD1]
  \\ RES_TAC \\ FULL_SIMP_TAC std_ss [GSYM CONJ_ASSOC]
  \\ REPEAT (STRIP_TAC THEN1 (SRW_TAC [] [] \\ DECIDE_TAC))
  \\ `LUPDATE h' (LENGTH (xs ++ ys)) (xs ++ ys ++ h::t ++ zs) =
      xs ++ ys ++ h'::t ++ zs` by ALL_TAC THEN1
   (`xs ++ ys ++ h::t ++ zs = (xs ++ ys) ++ h::(t ++ zs)` by ALL_TAC
    \\ FULL_SIMP_TAC std_ss [LUPDATE_LENGTH]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND])
  \\ FULL_SIMP_TAC std_ss []
  \\ `xs ++ ys ++ h'::t ++ zs = xs ++ (SNOC h' ys) ++ t ++ zs` by ALL_TAC
  THEN1 FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,SNOC_APPEND]
  \\ FULL_SIMP_TAC std_ss []
  \\ `LENGTH (xs ++ SNOC h' ys) < 268435457` by ALL_TAC
  THEN1 (FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC) \\ RES_TAC
  \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,LENGTH_SNOC]
  \\ REPEAT STRIP_TAC
  \\ `LENGTH xs + SUC (LENGTH ys) - 1 = LENGTH xs + LENGTH ys` by DECIDE_TAC
  \\ `!n. LENGTH xs + SUC (LENGTH ys) < 1 + n <=>
          LENGTH xs + LENGTH ys < n` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [SNOC_APPEND,GSYM APPEND_ASSOC,APPEND]);


(* general case of Shift *)

val n_loads_def = Define `
  n_loads i k x1 (stack:bc_value list) =
    (n_times i ((x1,stack). (EL k stack,EL k stack::stack))
             (x1,stack))`

val n_loads_pre_def = Define `
  n_loads_pre i k x1 (stack:bc_value list) =
    (n_times_pre i ((x1,stack). (EL k stack,EL k stack::stack))
             ((x1,stack). k < 268435456  k < LENGTH stack)
             (x1,stack))`;

val SND_n_loads = prove(
  ``!xs ys stack x1.
      LENGTH (ys ++ xs) < 268435457 ==>
      n_loads_pre (LENGTH xs) (LENGTH (ys++xs) - 1) x1 (ys ++ xs ++ stack) /\
      (SND (n_loads (LENGTH xs) (LENGTH (ys++xs) - 1) x1 (ys ++ xs ++ stack)) =
         xs ++ ys ++ xs ++ stack)``,
  HO_MATCH_MP_TAC SNOC_INDUCT \\ STRIP_TAC
  THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ REPEAT GEN_TAC \\ STRIP_TAC \\ REPEAT GEN_TAC
  \\ REPEAT GEN_TAC \\ STRIP_TAC \\ REPEAT GEN_TAC
  \\ FULL_SIMP_TAC std_ss [LENGTH,n_loads_def,n_loads_pre_def,LENGTH_SNOC]
  \\ ONCE_REWRITE_TAC [n_times_def,n_times_pre_def]
  \\ SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM CONJ_ASSOC]
  \\ REPEAT (STRIP_TAC THEN1 (FULL_SIMP_TAC std_ss [LENGTH_APPEND,LENGTH_SNOC]
       \\ SRW_TAC [] [] \\ DECIDE_TAC))
  \\ `LENGTH (ys ++ SNOC x xs)  1 = LENGTH (ys ++ xs)` by ALL_TAC
  THEN1 (FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
  \\ FULL_SIMP_TAC std_ss []
  \\ `(ys ++ (SNOC x xs ++ stack)) = (ys ++ xs) ++ x::stack` by ALL_TAC
  THEN1 (FULL_SIMP_TAC (srw_ss()) [])
  \\ FULL_SIMP_TAC std_ss [EL_LENGTH]
  \\ `LENGTH (ys ++ xs) = LENGTH ((x::ys) ++ xs) - 1` by ALL_TAC
  THEN1 (FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
  \\ FULL_SIMP_TAC std_ss []
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`x::ys`,`x::stack`,`x`])
  \\ MATCH_MP_TAC IMP_IMP
  \\ STRIP_TAC THEN1 DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,SNOC_APPEND]
  \\ FULL_SIMP_TAC (srw_ss()) [LENGTH_APPEND,LENGTH_SNOC,LENGTH,ADD1,
       AC ADD_COMM ADD_ASSOC,AC CONJ_COMM CONJ_ASSOC,
       METIS_PROVE [] ``p /\ p /\ q <=> p /\ q``])
  |> Q.SPECL [`xs`,`[]`] |> RW [APPEND_NIL,APPEND]

val zHEAP_GENERAL_Shift = let
  val th = SPEC_COMPOSE_RULE [zHEAP_LOAD,zHEAP_PUSH1]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
  val th = CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [LENGTH,ADD1,IMM32_def])) th
  val th = SIMP_RULE std_ss [GSYM LENGTH_NIL,LENGTH_LUPDATE,APPEND] th
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``((\(x1,stack). zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS) (x1,stack) *
       zPC p * cond ((\(x1,stack). k < 268435456 /\
          k < LENGTH stack) (x1,stack)))``
  val th = MP th (prove(goal,
    SIMP_TAC (std_ss++star_ss) [SEP_IMP_def,cond_STAR,GSYM LENGTH_NIL]))
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``((\(x1,stack). zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS)
         ((\(x1,stack). (EL k stack,
                         EL k stack::stack)) (x1:bc_value,stack))) *
       zPC (p + n2w (LENGTH (0x48w::0x8Bw::0x84w::0x24w::
                             (IMM32 (n2w (8 * k)) ++ [0x48w; 0x50w]))))``
  val lemma = SIMP_CONV (std_ss++star_ss) [SEP_IMP_REFL,cond_STAR,
                 IMM32_def,LENGTH,APPEND] goal
  val th = RW [lemma] th
  val th = INST [``x1:bc_value``|->``FST (y:bc_value # bc_value list)``,
                 ``stack:bc_value list``|->``SND (y:bc_value # bc_value list)``] th
           |> RW [PAIR] |> Q.GENL [`p`,`y`]
  val th = HO_MATCH_MP SPEC_NTIMES th
  val th = th |> Q.SPEC `(x1,stack)`
              |> SIMP_RULE std_ss [LENGTH_NTIMES,LENGTH,LENGTH_APPEND,LENGTH_IMM32]
              |> RW [GSYM n_loads_def,GSYM n_loads_pre_def]
              |> CONV_RULE (DEPTH_CONV PairRules.PBETA_CONV)
              |> Q.INST [`k`|->`n`] |> SPEC_ALL
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,th]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
            |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32]
            |> Q.INST [`i`|->`i1`,`n`|->`n1`]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_POP1]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
           |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32,LENGTH_APPEND,LENGTH_NTIMES]
  val th = SPEC_COMPOSE_RULE [zHEAP_NOP,th,zHEAP_SIMPLE_Shift]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
           |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32,LENGTH_APPEND,LENGTH_NTIMES]
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
           |> SIMP_RULE std_ss [LENGTH,LENGTH_IMM32,LENGTH_APPEND,LENGTH_NTIMES]
  val th = th |> RW [GSYM APPEND_ASSOC,APPEND]
  in th end;


(* push handler *)

val reintro_word_sub = SIMP_CONV (srw_ss()) [] ``-(n2w n):word64`` |> GSYM

val blast_lemma1 = prove(
  ``(w && 1w = 0w) ==> ((w >>> 1 << 1) = w:word64)``,
  blastLib.BBLAST_TAC)

val blast_lemma2 = prove(
  ``-(8w * w) + v && 1w = v && 1w:word64``,
  blastLib.BBLAST_TAC)

val zREAD_HANDLER = let
  val th = spec "mov r0,r11" |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
    StackPtr ((w2n (cs.stack_trunk - n2w (8 * s.handler))) DIV 2),
    x2,x3,x4,refs,stack,s,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg0 := vals.reg11`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ `cs.stack_trunk && 1w = 0w` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,stack_inv_def]
      \\ Q.PAT_ASSUM `cs.stack_trunk && 0x3w = 0x0w` MP_TAC
      \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,stack_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`Data (n2w (w2n (vals.reg11) DIV 2))`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND,HD,TL]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,reintro_word_sub]
    \\ FULL_SIMP_TAC std_ss [w2w_def,w2n_n2w]
    \\ `!w:word64. (w2n w DIV 2) < dimword (:63)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [DIV_LT_X] \\ EVAL_TAC
      \\ ASSUME_TAC (w2n_lt |> INST_TYPE [``:'a``|->``:64``])
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [w2n_lsr |> Q.SPECL [`w`,`1`] |>
         SIMP_RULE std_ss [] |> GSYM,n2w_w2n]
    \\ REVERSE STRIP_TAC THEN1
     (ONCE_REWRITE_TAC [EQ_SYM_EQ] \\ MATCH_MP_TAC blast_lemma1
      \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,blast_lemma2]
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,roots_ok_def]
    \\ FULL_SIMP_TAC (srw_ss()) [MEM]
    \\ STRIP_TAC THEN1 METIS_TAC []
    \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
    \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def]
    \\ REPEAT STRIP_TAC
    \\ FIRST_ASSUM MATCH_MP_TAC
    \\ FULL_SIMP_TAC std_ss [reachable_refs_def]
    \\ Q.LIST_EXISTS_TAC [`x`,`r`] \\ FULL_SIMP_TAC std_ss [MEM]
    \\ NTAC 2 (POP_ASSUM MP_TAC) \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;

val x64_mov_r11_r4 = let
  val th = spec "mov r11,r4" |> Q.INST [`rip`|->`p`,`r4`|->`rsp`]
  val th = SPEC_FRAME_RULE th ``zR1 zGhost_stack_top top *
       zR1 zGhost_stack_bottom base * zMEMORY64 dm m *
       cond (stack_ok rsp top base stack dm m)``
  val (th,goal) = SPEC_WEAKEN_RULE th
                  ``zPC (p + 0x3w) * zR 0xBw (base - n2w (8 * LENGTH stack)) *
                    zSTACK (base,stack)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [zSTACK_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,WORD_ADD_SUB]
    \\ FULL_SIMP_TAC std_ss [stack_ok_def]
    \\ Q.PAT_ASSUM `rsp + xx = base` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [WORD_ADD_SUB,zR_def])
  val th = MP th lemma
  val th = th |> Q.GENL (rev [`rsp`,`top`,`dm`,`m`])
              |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
                  ``zPC p * zR 0xBw r11 * zSTACK (base,stack)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zSTACK_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def])
  val th = MP th lemma
  in th end;

val zWRITE_HANDLER = let
  val th = x64_mov_r11_r4
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
            s with handler := LENGTH stack,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg11 :=
         vals.stack_bottom - n2w (8 * LENGTH vals.stack)`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,stack_inv_def]
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,APPEND,HD,TL]
    \\ FULL_SIMP_TAC std_ss [reintro_word_sub]
    \\ Q.PAT_ASSUM `xxx = cs.stack_trunk` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,ADD1,GSYM word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [word_arith_lemma1]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,ADD1,GSYM word_add_n2w]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ FULL_SIMP_TAC std_ss [WORD_NEG_ADD] \\ SRW_TAC [] [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;

val zBC_PushExc_raw =
  SPEC_COMPOSE_RULE [zHEAP_PUSH1,zREAD_HANDLER,zWRITE_HANDLER]


(* pop handler *)

val LENGTH_LESS_EQ_ALT = prove(
  ``!xs m. m <= LENGTH xs ==> ?ys zs. (xs = ys ++ zs) /\ (LENGTH zs = m)``,
  HO_MATCH_MP_TAC SNOC_INDUCT \\ SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
  \\ Cases_on `m` \\ FULL_SIMP_TAC std_ss [LENGTH_NIL,APPEND,APPEND_NIL]
  \\ RES_TAC \\ Q.LIST_EXISTS_TAC [`ys`,`zs ++ [x]`]
  \\ FULL_SIMP_TAC std_ss [APPEND,LENGTH,APPEND_ASSOC,LENGTH_APPEND,ADD1]);

val x64_mov_r4_r11 = let
  val th = compose_specs ["mov r4,r11"]
  val pre = ``w2n (base - r11:word64) DIV 8 <= LENGTH (ss:word64 list) /\
              (w2n (base - r11:word64) MOD 8 = 0)``
  val pc = get_pc th
  val th = th |> Q.INST [`r4`|->`rsp`,`df`|->`dm`,`f`|->`m`,`rip`|->`p`]
  val th = SPEC_FRAME_RULE th ``
             zMEMORY64 dm m *
             zR1 zGhost_stack_top top * zR1 zGhost_stack_bottom base *
             cond (stack_ok rsp top base ss dm m /\ ^pre)``
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``^pc * zR 0xBw r11 *
        zSTACK (base,DROP (LENGTH ss - w2n (base - r11) DIV 8) ss)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zSTACK_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`r11`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def] \\ POP_ASSUM (K ALL_TAC)
    \\ Cases_on `base - r11` \\ FULL_SIMP_TAC (std_ss) [w2n_n2w]
    \\ MP_TAC (MATCH_MP DIVISION (DECIDE ``0 < 8:num``) |> Q.SPEC `n`)
    \\ ASM_SIMP_TAC std_ss [] \\ Q.ABBREV_TAC `k = n DIV 8`
    \\ POP_ASSUM (K ALL_TAC) \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ `r11 = base - n2w (k * 8)` by ALL_TAC THEN1
      (Q.PAT_ASSUM `base - r11 = xx` (ASSUME_TAC o GSYM)
       \\ FULL_SIMP_TAC std_ss [WORD_SUB_SUB]
       \\ ONCE_REWRITE_TAC [WORD_ADD_COMM]
       \\ SIMP_TAC std_ss [WORD_ADD_SUB])
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [stack_ok_def]
    \\ IMP_RES_TAC LENGTH_LESS_EQ_ALT
    \\ POP_ASSUM (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,rich_listTheory.DROP_LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss [WORD_SUB_ADD,AC MULT_ASSOC MULT_COMM]
    \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ Q.PAT_ASSUM `base && 0x7w = 0x0w` MP_TAC
      \\ blastLib.BBLAST_TAC)
    \\ Q.EXISTS_TAC `rest ++ ys`
    \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,AC ADD_COMM ADD_ASSOC,
         AC MULT_ASSOC MULT_COMM,APPEND_ASSOC] \\ SRW_TAC [] [])
  val th = MP th lemma
  val th = th |> Q.GENL (rev [`rsp`,`top`,`dm`,`m`])
              |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zPC p * zR 0xBw r11 * zSTACK (base,ss) * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zSTACK_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def])
  val th = MP th lemma
  in th end;

val abs_ml_inv_PushExc = prove(
  ``abs_ml_inv
        (x1::x2::x3::x4::(l1 ++ StackPtr n::l2)) refs
        (r1::r2::r3::r4::roots,heap,a,sp) l ==>
    ?rr1 rr2.
       (roots = rr1 ++ Data (n2w n)::rr2) /\
       (LENGTH l1 = LENGTH rr1) /\
       (LENGTH l2 = LENGTH rr2)``,
  SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
  \\ REPEAT STRIP_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
  \\ IMP_RES_TAC EVERY2_SPLIT_ALT \\ FULL_SIMP_TAC std_ss []
  \\ Q.LIST_EXISTS_TAC [`ys1`,`ys2`]
  \\ FULL_SIMP_TAC std_ss [bc_value_inv_def]
  \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss []);

val blast_lemma_sub_sub = prove(
  ``-1w * -w = w:word64``,
  blastLib.BBLAST_TAC);

val MOD_LESS_ALT = prove(
  ``0 < k /\ m < l ==> (m MOD k < l:num)``,
  REPEAT STRIP_TAC \\ IMP_RES_TAC MOD_LESS_EQ
  \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `m`)
  \\ DECIDE_TAC);

val zBC_PopExc_raw = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec "4981EB08000000"
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE true sts th
  val th = SPEC_COMPOSE_RULE [th,x64_mov_r4_r11,x64_pop_r11]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) []
  val pc = get_pc th
  val sp = ``(w2n (cs.stack_trunk - n2w (8 * sp)) DIV 2)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,
                      l1 ++ StackPtr ^sp::l2,s,NONE) vals /\
            (LENGTH l2 = s.handler))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = RW1 [STACK_LENGTH_LEMMA] th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,l2,
            s with handler := sp,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ REPEAT GEN_TAC
    \\ STRIP_TAC \\ Q.PAT_ASSUM `xx = yy` (ASSUME_TAC o GSYM)
    \\ Q.PAT_ASSUM `8 * LENGTH xx < yy` ASSUME_TAC
    \\ `w2n (vals.stack_bottom - (vals.reg11 - 0x8w)) =
        8 * (LENGTH cs.rest_of_stack + LENGTH l2 + 3)` by ALL_TAC THEN1
     (FULL_SIMP_TAC (std_ss++sep_cond_ss) [heap_inv_def,stack_inv_def,cond_STAR]
      \\ Q.PAT_ASSUM `xx = cs.stack_trunk` (ASSUME_TAC o GSYM)
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,stack_inv_def,LENGTH,LENGTH_APPEND]
      \\ SIMP_TAC std_ss [GSYM WORD_SUB_PLUS,WORD_SUB_SUB2]
      \\ SIMP_TAC std_ss [word_add_n2w,w2n_n2w]
      \\ `(8 * LENGTH cs.rest_of_stack + (16 + (8 * LENGTH l2 + 8)))
            < dimword (:64)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `8 * LENGTH xss < nnn` MP_TAC
        \\ FULL_SIMP_TAC (srw_ss()) [LEFT_ADD_DISTRIB,ADD1]
        \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
        \\ IMP_RES_TAC EVERY2_IMP_LENGTH
        \\ POP_ASSUM (MP_TAC o GSYM)
        \\ SIMP_TAC std_ss [LENGTH,LENGTH_APPEND]
        \\ REPEAT STRIP_TAC \\ DECIDE_TAC)
      \\ FULL_SIMP_TAC std_ss [DIV_EQ_X] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [RW1 [MULT_COMM] (CONJ MULT_DIV MOD_EQ_0)]
    \\ FULL_SIMP_TAC std_ss []
    \\ `(LENGTH vals.stack - (LENGTH cs.rest_of_stack + LENGTH l2 + 3)) =
        LENGTH l1` by ALL_TAC THEN1
     (FULL_SIMP_TAC (std_ss++sep_cond_ss) [heap_inv_def,stack_inv_def,cond_STAR]
      \\ FULL_SIMP_TAC std_ss [LIST_REL_def,abs_ml_inv_def,APPEND,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC (GSYM EVERY2_IMP_LENGTH)
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| stack := TL (DROP (LENGTH l1) vals.stack) ;
                                  reg11 := HD (DROP (LENGTH l1) vals.stack) |>`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()++star_ss) []
    \\ SIMP_TAC std_ss [STAR_ASSOC]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,stack_inv_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,PULL_IMP_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
          `TL (DROP (LENGTH l1) roots)`,`heap`,`a`,`sp'`]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [reintro_word_sub]
    \\ IMP_RES_TAC abs_ml_inv_PushExc
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,
         rich_listTheory.DROP_LENGTH_APPEND,TL,HD]
    \\ `LENGTH rr1 = LENGTH (MAP (x64_addr vs.current_heap) rr1)` by
         FULL_SIMP_TAC std_ss [LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,GSYM APPEND_ASSOC,
         rich_listTheory.DROP_LENGTH_APPEND,TL,HD,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def] \\ POP_ASSUM (K ALL_TAC)
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,roots_ok_def,MEM,MEM_APPEND]
      \\ STRIP_TAC THEN1 METIS_TAC []
      \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
      \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
      \\ FULL_SIMP_TAC std_ss [EVERY2_APPEND,LENGTH_MAP,LIST_REL_def]
      \\ REPEAT STRIP_TAC \\ FIRST_ASSUM MATCH_MP_TAC
      \\ FULL_SIMP_TAC std_ss [reachable_refs_def]
      \\ Q.LIST_EXISTS_TAC [`x`,`r`]
      \\ FULL_SIMP_TAC std_ss [MEM,MEM_APPEND])
    \\ FULL_SIMP_TAC std_ss [w2w_def,w2n_n2w]
    \\ `!w:word64. (w2n w DIV 2) < dimword (:63)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [DIV_LT_X] \\ EVAL_TAC
      \\ ASSUME_TAC (w2n_lt |> INST_TYPE [``:'a``|->``:64``])
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [w2n_lsr |> Q.SPECL [`w`,`1`] |>
         SIMP_RULE std_ss [] |> GSYM,n2w_w2n]
    \\ MATCH_MP_TAC blast_lemma1
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,blast_lemma2]
    \\ Q.PAT_ASSUM `3w && cs.stack_trunk = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = RW1 [GSYM STACK_LENGTH_LEMMA] th
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, l1 ++ StackPtr ^sp::l2, s, NONE) *
      ~zS * zPC p * cond (LENGTH l2 = s.handler)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* LoadRev *)

val sw2sw_lemma =
  sw2sw_def |> INST_TYPE [``:'a``|->``:32``,``:'b``|->``:64``]
            |> SIMP_RULE (srw_ss()) [] |> GSYM

val sub_imm32_lemma = prove(
  ``(offset:num) <= 2 ** 28 ==>
    (base + sw2sw (- (n2w:num->word32) (8 * offset)) =
     base - n2w (8 * offset):word64)``,
  SIMP_TAC (srw_ss()) [sw2sw_def] \\ REPEAT STRIP_TAC
  \\ `(8 * offset) < 4294967296` by DECIDE_TAC
  \\ `(8 * offset) < 18446744073709551616` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `offset = 0` \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
  \\ `(4294967296 - 8 * offset) < 4294967296` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [bitTheory.SIGN_EXTEND_def,LET_DEF]
  \\ Cases_on `BIT 31 (4294967296 - 8 * offset)`
  THEN1 (IMP_RES_TAC (DECIDE ``m < n ==> (k + (n - m) = (k+n) - m:num)``)
         \\ FULL_SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
  \\ FULL_SIMP_TAC std_ss [bitTheory.BIT_def,bitTheory.BITS_THM2]
  \\ POP_ASSUM MP_TAC
  \\ `(4294967296 - 8 * offset) < 4294967296` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [DIV_EQ_X]
  \\ REPEAT STRIP_TAC
  \\ DECIDE_TAC);

val x64_mov_r0_r5 = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64 "488B85"
  val th = th |> Q.INST [`rip`|->`p`,`imm32`|->`- n2w (8 * offset)`,`r5`|->`base`]
  val th = RW [GSYM IMM32_def,sw2sw_lemma,UNDISCH sub_imm32_lemma] th
  val th = th |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  val th = th |> Q.INST [`base`|->`base - extra`]
  val pc = get_pc th
  val pre = ``w2n (extra + n2w (8 * offset)) DIV 8 < LENGTH (stack:word64 list) /\
              (w2n ((extra:word64) + n2w (8 * offset)) MOD 8 = 0) /\
              offset <= 2 ** 28``
  val th = th |> Q.INST [`r4`|->`rsp`,`df`|->`dm`,`f`|->`m`,`rip`|->`p`,
                         `base`|->`base-8w`]
  val th = SPEC_FRAME_RULE th ``zR1 RSP rsp *
             zR1 zGhost_stack_top top * zR1 zGhost_stack_bottom base *
             cond (stack_ok rsp top base stack dm m /\ ^pre)``
  val (th,goal) = SPEC_WEAKEN_RULE th ``(^pc * zR 0x5w (base - 8w - extra) *
      zR 0x0w (EL (w2n (extra + n2w (8 * offset)) DIV 8) (REVERSE stack)) *
      zSTACK (base,stack))``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zSTACK_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ IMP_RES_TAC stack_ok_REV_EL
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def,WORD_SUB_PLUS])
  val th = MP th lemma
  val th = th |> Q.GENL (rev [`rsp`,`top`,`dm`,`m`])
              |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zPC p * zR 0x5w (base - 0x8w - extra) *
      zR 0x0w r0 * zSTACK (base,stack) * cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zSTACK_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`rsp`,`top`,`dm`,`m`]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ IMP_RES_TAC stack_ok_REV_EL
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zR_def,WORD_SUB_PLUS])
  val th = MP th lemma
  in th end;

val LENGTH_LESS_REV = prove(
  ``!xs m. m < LENGTH xs ==> ?ys z zs. (xs = ys ++ z::zs) /\ (LENGTH zs = m)``,
  recInduct SNOC_INDUCT \\ SIMP_TAC std_ss [LENGTH,LENGTH_SNOC]
  \\ SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
  \\ Cases_on `m` \\ FULL_SIMP_TAC std_ss [LENGTH_NIL,APPEND,CONS_11,APPEND_NIL]
  THEN1 (METIS_TAC []) \\ RES_TAC \\ Q.LIST_EXISTS_TAC [`ys`,`z`,`zs ++ [x]`]
  \\ FULL_SIMP_TAC std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC,LENGTH_APPEND,ADD1]);

val LENGTH_EQ_IMP_EL = prove(
  ``(LENGTH xs = k) ==> (EL k (REVERSE xs ++ y::ys) = y)``,
  METIS_TAC [EL_LENGTH,LENGTH_MAP,LENGTH_REVERSE]);

val LENGTH_EQ_IMP_EL_MAP = prove(
  ``(LENGTH xs = k) ==> (EL k (MAP f (REVERSE xs) ++ y::ys) = y)``,
  METIS_TAC [EL_LENGTH,LENGTH_MAP,LENGTH_REVERSE]);

val EL_APPEND_LEMMA = prove(
  ``(k = LENGTH xs + l) ==> (EL k (xs ++ ys) = EL l ys)``,
  FULL_SIMP_TAC std_ss [rich_listTheory.EL_APPEND2]);

val zHEAP_LoadRev = let
  val th = x64_mov_r0_r5
           |> DISCH ``base - 8w - extra = w:word64``
           |> SIMP_RULE std_ss [] |> RW [GSYM SPEC_MOVE_COND]
           |> Q.INST [`offset`|->`offset+1`]
  val pc = get_pc th
  val pre = ``offset + s.base_offset < LENGTH (stack:bc_value list) /\
              offset < 268435456``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = th |> Q.INST [`extra`|->`8w + n2w (8 * s.base_offset) + n2w (8 * LENGTH cs.rest_of_stack)`]
  val th = RW1 [STACK_LENGTH_LEMMA] th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,EL (offset + s.base_offset) (REVERSE stack),
                                x2,x3,x4,refs,stack,s,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [stack_inv_def]
    \\ Q.PAT_ASSUM `xxx = cs.stack_trunk` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [word_add_n2w]
    \\ `8 + 8 * s.base_offset + 8 * LENGTH cs.rest_of_stack + 8 * (offset + 1) =
        8 * (2 + s.base_offset + LENGTH cs.rest_of_stack + offset)` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ `8 * (2 + s.base_offset + LENGTH cs.rest_of_stack + offset) < 2**64` by
     (`LENGTH stack = LENGTH roots` by ALL_TAC THEN1
       (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,APPEND]
        \\ IMP_RES_TAC EVERY2_IMP_LENGTH)
      \\ Q.PAT_ASSUM `8 * LENGTH vals.stack < ll` MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [w2n_n2w,EVAL ``dimword (:64)``]
    \\ FULL_SIMP_TAC std_ss [RW1 [MULT_COMM] MOD_EQ_0]
    \\ FULL_SIMP_TAC std_ss [RW1 [MULT_COMM] MULT_DIV]
    \\ STRIP_TAC THEN1
     (STRIP_TAC THEN1
        (SIMP_TAC std_ss [word_arith_lemma1] \\ NTAC 2 AP_TERM_TAC \\ DECIDE_TAC)
      \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_APPEND,LENGTH_MAP]
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
           APPEND,LIST_REL_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ DECIDE_TAC)
    \\ `(EL (2 + s.base_offset + LENGTH cs.rest_of_stack + offset)
          (REVERSE (MAP (x64_addr vs.current_heap) roots ++
            0x1w::cs.ret_address::cs.rest_of_stack))) =
         EL (offset + s.base_offset)
          (REVERSE (MAP (x64_addr vs.current_heap) roots))` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [REVERSE_APPEND,APPEND]
      \\ MATCH_MP_TAC EL_APPEND_LEMMA
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg0 := (EL (offset + s.base_offset) (REVERSE (MAP
         (x64_addr vs.current_heap) roots)))`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC
    THEN1 (SIMP_TAC (srw_ss()) [zVALS_def] \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ POP_ASSUM (K ALL_TAC)
    \\ SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`EL (offset + s.base_offset) (REVERSE roots)`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,stack_inv_def]
    \\ SIMP_TAC std_ss [CONJ_ASSOC]
    \\ REVERSE STRIP_TAC
    THEN1 FULL_SIMP_TAC std_ss [word_sub_def,AC WORD_ADD_COMM WORD_ADD_ASSOC]
    \\ REVERSE STRIP_TAC
    THEN1 FULL_SIMP_TAC std_ss [word_sub_def,AC WORD_ADD_COMM WORD_ADD_ASSOC]
    \\ SIMP_TAC std_ss [GSYM rich_listTheory.MAP_REVERSE]
    \\ `LENGTH stack = LENGTH roots` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH)
    \\ `offset + s.base_offset < LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LENGTH_LESS_REV
    \\ FULL_SIMP_TAC std_ss [REVERSE_APPEND,REVERSE_DEF]
    \\ SIMP_TAC std_ss [MAP_APPEND,MAP,GSYM APPEND_ASSOC,APPEND]
    \\ IMP_RES_TAC LENGTH_EQ_IMP_EL
    \\ ASM_SIMP_TAC std_ss [LENGTH_EQ_IMP_EL]
    \\ REVERSE STRIP_TAC
    THEN1 (MATCH_MP_TAC LENGTH_EQ_IMP_EL_MAP \\ FULL_SIMP_TAC std_ss [])
    \\ Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
    \\ FULL_SIMP_TAC std_ss [LENGTH_APPEND,LENGTH]
    \\ `LENGTH ys' = LENGTH ys` by DECIDE_TAC
    \\ Q.PAT_ASSUM `LENGTH ys' = LENGTH ys` MP_TAC
    \\ REPEAT (POP_ASSUM (K ALL_TAC))
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [roots_ok_def,MEM,MEM_APPEND]
    THEN1 (FULL_SIMP_TAC std_ss [MEM_APPEND,SUBSET_DEF,MEM_MAP] \\ METIS_TAC [])
    \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `LENGTH ys' = LENGTH ys` ASSUME_TAC
    \\ FULL_SIMP_TAC std_ss [EVERY2_APPEND,LENGTH_MAP,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [reachable_refs_def,MEM_APPEND,MEM_MAP,MEM]
    \\ METIS_TAC [])
  val th = MP th lemma
  val th = RW1 [GSYM STACK_LENGTH_LEMMA] th
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  in th end;


(* get tag *)

val (x64_get_tag_res, x64_get_tag_def, x64_get_tag_pre_def) = x64_compile `
  x64_get_tag (r0:word64,dm:word64 set,m:word64->word64) =
    if r0 && 1w = 0w then
      let r0 = r0 - 2w in (r0,dm,m)
    else
      let r0 = m (r0 + 1w) in
      let r0 = r0 && 65535w in
      let r0 = r0 >>> 2 in
        (r0,dm,m)`

val get_tag_blast = prove(
  ``!w1 w. w1 <+ 0x10000w ==> ((0x10000w * w + w1) && 0xFFFFw = w1:word64)``,
  blastLib.BBLAST_TAC);

val zHEAP_GET_TAG = let
  val th = x64_get_tag_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isBlock x1)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Number (& (getTag x1)),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isBlock_def,APPEND]
    \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss []
    THEN1
     (`(r1 = Data (2w * n2w n + 1w)) /\ n < 2**61` by ALL_TAC THEN1
         (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
            LIST_REL_def,bc_value_inv_def])
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,x64_get_tag_pre_def,x64_get_tag_def]
      \\ `(w2w (0x2w * n2w n + 0x1w:63 word) << 1 && 0x1w = 0x0w:word64) /\
          (w2w (0x2w * n2w n + 0x1w:63 word) << 1 - 0x2w:word64 =
           w2w (0x2w * n2w n:63 word) << 1)` by ALL_TAC THEN1 blastLib.BBLAST_TAC
      \\ FULL_SIMP_TAC std_ss [LET_DEF,getTag_def]
      \\ REPEAT STRIP_TAC
      \\ Q.EXISTS_TAC `vals with <| reg0 := w2w ((0x2w:63 word) * n2w n) << 1 |>`
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ STRIP_TAC THEN1
       (POP_ASSUM (K ALL_TAC)
        \\ FULL_SIMP_TAC std_ss [heap_inv_def]
        \\ Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w n)`,`r2`,`r3`,`r4`,
             `roots`,`heap`,`a`,`sp`]
        \\ FULL_SIMP_TAC (srw_ss()) [APPEND,x64_addr_def]
        \\ METIS_TAC [abs_ml_inv_Num])
      \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (std_ss++star_ss) []
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC])
    \\ `?f. bc_value_inv (Block n l) (r1,f,heap)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ METIS_TAC []) \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [x64_get_tag_def,x64_get_tag_pre_def,LET_DEF]
    \\ `(x64_addr vs.current_heap (Pointer ptr) && 0x1w) <> 0x0w` by ALL_TAC
    THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
           \\ FULL_SIMP_TAC std_ss [x64_addr_def,heap_vars_ok_def]
           \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ SIMP_TAC std_ss [CONJ_ASSOC] \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ FULL_SIMP_TAC std_ss [word_arith_lemma3,word_mul_n2w,
        AC MULT_COMM MULT_ASSOC,WORD_ADD_0] \\ SEP_R_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ SIMP_TAC std_ss [blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def])
    \\ FULL_SIMP_TAC std_ss [getTag_def,WORD_SUB_ADD,word_mul_n2w]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ `0x10000w * n2w (LENGTH xs) + 0x10w * n2w (n) &&
          0xFFFFw = 0x10w * n2w (n):word64` by ALL_TAC THEN1
     (MATCH_MP_TAC get_tag_blast \\ FULL_SIMP_TAC std_ss [word_mul_n2w,WORD_LO]
      \\ `(16 * n < 18446744073709551616)` by DECIDE_TAC
      \\ ASM_SIMP_TAC (srw_ss()) [w2n_n2w] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := ((0x10w * n2w n) >>> 2) |>`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w n)`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ Q.PAT_ASSUM `n < 4096` ASSUME_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
      \\ `n < 2305843009213693952` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ METIS_TAC [abs_ml_inv_Num])
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.PAT_ASSUM `xxx (fun2set yyy)` MP_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) [AC WORD_ADD_COMM WORD_ADD_ASSOC,
         heap_length_APPEND,LEFT_ADD_DISTRIB,GSYM word_add_n2w,heap_length_def,
         MAP,SUM]
    \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [GSYM w2n_11]
    \\ FULL_SIMP_TAC std_ss [w2n_lsr]
    \\ FULL_SIMP_TAC (srw_ss()) [w2n_n2w,w2w_def,word_mul_n2w]
    \\ `(2 * n) < 9223372036854775808 /\
        (2 * (2 * n)) < 18446744073709551616 /\
        (16 * n) < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [DIV_EQ_X] \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isBlock x1)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;


(* get length *)

val (x64_get_length_res, x64_get_length_def, x64_get_length_pre_def) = x64_compile `
  x64_get_length (r0:word64,dm:word64 set,m:word64->word64) =
    if r0 && 1w = 0w then
      let r0 = 0w in (r0,dm,m)
    else
      let r0 = m (r0 + 1w) in
      let r0 = r0 >>> 16 in
      let r0 = r0 << 2 in
        (r0,dm,m)`

val get_length_blast = prove(
  ``!w1 w. 0x10w * w1 <+ 0x10000w /\ w <+ n2w (2**32) ==>
           ((0x10000w * w + 0x10w * w1) >>> 16 = w:word64)``,
  blastLib.BBLAST_TAC);

val zHEAP_GET_LENGTH = let
  val th = x64_get_length_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isBlock x1)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Number (& (LENGTH (getContent x1))),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isBlock_def,APPEND]
    \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss []
    THEN1
     (`(r1 = Data (2w * n2w n + 1w)) /\ n < 2**61` by ALL_TAC THEN1
         (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
            LIST_REL_def,bc_value_inv_def])
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,
           x64_get_length_pre_def,x64_get_length_def]
      \\ `(w2w (0x2w * n2w n + 0x1w:63 word) << 1 && 0x1w = 0x0w:word64) /\
          (w2w (0x2w * n2w n + 0x1w:63 word) << 1 - 0x2w:word64 =
           w2w (0x2w * n2w n:63 word) << 1)` by ALL_TAC THEN1 blastLib.BBLAST_TAC
      \\ FULL_SIMP_TAC std_ss [LET_DEF,getContent_def]
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [LENGTH,cond_STAR]
      \\ Q.EXISTS_TAC `vals with <| reg0 := w2w ((0x2w:63 word) * n2w 0) << 1 |>`
      \\ STRIP_TAC THEN1
       (POP_ASSUM (K ALL_TAC)
        \\ FULL_SIMP_TAC std_ss [heap_inv_def]
        \\ Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w 0)`,`r2`,`r3`,`r4`,
             `roots`,`heap`,`a`,`sp`]
        \\ FULL_SIMP_TAC (srw_ss()) [APPEND,x64_addr_def]
        \\ MATCH_MP_TAC (abs_ml_inv_Num |> SPEC_ALL |> Q.INST [`n`|->`0`]
            |> SIMP_RULE std_ss [word_mul_n2w] |> GEN_ALL) \\ METIS_TAC [])
      \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (std_ss++star_ss) []
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC])
    \\ `?f. bc_value_inv (Block n l) (r1,f,heap)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ METIS_TAC []) \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [x64_get_length_def,x64_get_length_pre_def,LET_DEF]
    \\ `(x64_addr vs.current_heap (Pointer ptr) && 0x1w) <> 0x0w` by ALL_TAC
    THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
           \\ FULL_SIMP_TAC std_ss [x64_addr_def,heap_vars_ok_def]
           \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ FULL_SIMP_TAC std_ss [WORD_SUB_ADD]
    \\ SIMP_TAC std_ss [CONJ_ASSOC] \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [word_arith_lemma3,word_mul_n2w,
        AC MULT_COMM MULT_ASSOC,WORD_ADD_0] \\ SEP_R_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ SIMP_TAC std_ss [blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def])
    \\ FULL_SIMP_TAC std_ss [getTag_def,WORD_SUB_ADD,word_mul_n2w]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,getContent_def]
    \\ `LENGTH l < 2 ** 32` by ALL_TAC THEN1 (FULL_SIMP_TAC std_ss [])
    \\ `LENGTH xs < 2 ** 32` by ALL_TAC THEN1
      (IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [])
    \\ `((0x10000w * n2w (LENGTH xs) + 0x10w * n2w n) >>> 16):word64 =
        n2w (LENGTH xs)` by ALL_TAC THEN1
      (MATCH_MP_TAC get_length_blast
       \\ `(16 * n) < 18446744073709551616` by DECIDE_TAC
       \\ `LENGTH xs < 18446744073709551616` by DECIDE_TAC
       \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,WORD_LO]
       \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := ((0x4w * n2w (LENGTH xs))) |>`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w (LENGTH l))`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ `LENGTH l < 2305843009213693952` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
      \\ METIS_TAC [abs_ml_inv_Num])
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss []
      \\ `(2 * LENGTH l) < 9223372036854775808` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w,word_mul_n2w]
      \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
      \\ `LENGTH xs = LENGTH l` by ALL_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt rr` MP_TAC
      \\ SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ ASM_SIMP_TAC (srw_ss()) [bc_value_inv_def,BlockRep_def]
      \\ REPEAT STRIP_TAC
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH
      \\ FULL_SIMP_TAC std_ss [])
    \\ FULL_SIMP_TAC std_ss [heap_length_APPEND,heap_length_def,MAP,
         SUM,LEFT_ADD_DISTRIB,GSYM word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w]
    \\ Q.PAT_ASSUM `xxx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) [AC WORD_ADD_COMM WORD_ADD_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isBlock x1)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

(* get length byte *)

val (x64_get_length_byte_res, x64_get_length_byte_def, x64_get_length_byte_pre_def) = x64_compile `
  x64_get_length_byte (r0:word64,dm:word64 set,m:word64->word64) =
      let r0 = m (r0 + 1w) in
      let r0 = r0 >>> 11 in
      let r0 = r0 - 32w in
        (r0,dm,m)`

val heap_lookup_IMP_heap_length = prove(
  ``heap n l. (heap_lookup n heap = SOME (Bytes l)) ==>
    LENGTH (l:word8 list) + 8 * n < 8 * heap_length heap``,
  Induct THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ FULL_SIMP_TAC std_ss [heap_lookup_def,heap_length_def,MAP,SUM] >> rw[] >>
  res_tac >> simp[Bytes_def] >> simp[el_length_def] >>
  simp[LEFT_ADD_DISTRIB] >>
  simp[LENGTH_bytesToWords,LEFT_ADD_DISTRIB,MULT_DIV] >>
  qspecl_then[`3`,`LENGTH l`]mp_tac bitTheory.DIV_MULT_THM >>
  simp[] >> rw[] >>
  `LENGTH l MOD 8 < 8` by simp[] >>
  DECIDE_TAC)

val zHEAP_GET_LENGTH_BYTE = let
  val th = x64_get_length_byte_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isRefPtr x1 /\
            isByteArray (refs ' (getRefPtr x1)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Number (& (LENGTH (getByteArray (refs ' (getRefPtr x1))))),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val blast_lemma1 =
    blastLib.BBLAST_PROVE``0w  y  y < 8w  0w  z  z < 281474976710656w 
      ((z:word64 << 16 + y << 13 + 0x6w) >>> 11 = z << 5 + y << 2)``
(*
gg goal
*)
  val lemma = prove(goal,
    simp[x64_get_length_byte_def,SEP_EXISTS_THM,SEP_CLAUSES,zHEAP_def,SEP_IMP_def]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isRefPtr_def,getRefPtr_def,APPEND]
    \\ Cases_on `refs ' n` \\ FULL_SIMP_TAC std_ss [isByteArray_def,getByteArray_def]
    \\ `?f. (r1 = Pointer (f ' n)) /\ bc_ref_inv n refs (f,heap)` by ALL_TAC THEN1
      (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
        bc_value_inv_def] \\ Q.LIST_EXISTS_TAC [`f`]
      \\ ASM_SIMP_TAC std_ss []
      \\ `reachable_refs (RefPtr n::x2::x3::x4::stack) refs n` by ALL_TAC THEN1
       (FULL_SIMP_TAC std_ss [reachable_refs_def,MEM]
        \\ Q.LIST_EXISTS_TAC [`RefPtr n`,`n`]
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ res_tac)
    \\ rfs[bc_ref_inv_def,FLOOKUP_DEF]
    \\ Cases_on`n  FDOM f` >> fs[]
    \\ Cases_on`n  FDOM refs` >> fs[]
    \\ conj_tac >- (
      simp[x64_get_length_byte_pre_def,x64_addr_def] >>
      imp_res_tac heap_lookup_SPLIT >>
      fs[x64_heap_APPEND,x64_heap_def,GSYM word_mul_n2w,x64_el_def,Bytes_def,
         LET_THM,x64_payload_def] >>
      FULL_SIMP_TAC (std_ss++star_ss) [] >>
      FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def] >>
      reverse conj_tac >- (
        fs[heap_vars_ok_def] >>
        qpat_assum`X && vs.current_heap = Y`mp_tac >>
        blastLib.BBLAST_TAC ) >>
      fsrw_tac[ARITH_ss][] >>
      SEP_R_TAC )
    \\ REPEAT STRIP_TAC
    \\ simp[zVALS_def]
    \\ Q.EXISTS_TAC `vals with <| reg0 := ((0x4w * n2w (LENGTH l)))|>`
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ `LENGTH l < 8 * 281474976710664 - 72` by (
        IMP_RES_TAC heap_lookup_IMP_heap_length >>
        fs[abs_ml_inv_def,heap_ok_def] >> rfs[] >>
        DECIDE_TAC )
    \\ conj_tac >- (
      Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w (LENGTH l))`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`] >>
      simp[x64_addr_def,WORD_MUL_LSL,word_mul_n2w,w2w_def] >>
      simp[GSYM word_mul_n2w] >>
      MATCH_MP_TAC abs_ml_inv_Num >>
      map_every qexists_tac[`RefPtr n`,`Pointer (f ' n)`] >> simp[]) >>
    fs[GSYM STAR_ASSOC] >>
    qmatch_assum_abbrev_tac`(X * (Y * (Z * (zR 0x0w A * B)))) ss` >>
    qsuff_tac `A = 0x4w * n2w (LENGTH l)` >- (
      UNABBREV_ALL_TAC >> rw[] >>
      FULL_SIMP_TAC (std_ss++star_ss)[] >>
      qpat_assum`X s'`mp_tac >>
      REWRITE_TAC[GSYM APPEND_ASSOC,APPEND] ) >>
    UNABBREV_ALL_TAC >>
    qpat_assum`X s'` kall_tac >>
    imp_res_tac heap_lookup_SPLIT >>
    FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def] >>
    fs[GSYM word_mul_n2w,x64_el_def,Bytes_def,LET_THM,x64_payload_def] >>
    SEP_R_TAC >>
    simp[LENGTH_bytesToWords] >>
    qmatch_abbrev_tac`(z << 16 + y << 13 + 0x6w) >>> 11 + c = d` >>
    SUBGOAL_THEN(snd(dest_imp(concl blast_lemma1)))SUBST1_TAC THEN1 (
      match_mp_tac blast_lemma1 >>
      UNABBREV_ALL_TAC >>
      simp[word_lt_n2w,WORD_ZERO_LE] >>
      `LENGTH l MOD 8 < 8` by simp[] >>
      simp[LESS_MOD] >>
      qmatch_assum_abbrev_tac`LENGTH l < lim` >>
      `LENGTH l DIV 8 + 1 < lim` by (
        match_mp_tac LESS_SUB_ADD_LESS >> simp[Abbr`lim`] >>
        simp[DIV_LT_X] ) >>
      fs[Abbr`lim`] >> simp[] >>
      disj1_tac >>
      conj_tac >- (
        match_mp_tac bitTheory.NOT_BIT_GT_TWOEXP >>
        simp[] >>
        match_mp_tac LESS_SUB_ADD_LESS >> simp[] >>
        simp[DIV_LT_X] ) >>
      match_mp_tac LESS_SUB_ADD_LESS >> simp[] >>
      simp[DIV_LT_X] ) >>
    simp[WORD_MUL_LSL,Abbr`z`,GSYM word_add_n2w,WORD_LEFT_ADD_DISTRIB,Abbr`c`] >>
    `0x20w:Zimm = 0x4w * 0x8w` by simp[] >> pop_assum SUBST1_TAC >>
    REWRITE_TAC[GSYM WORD_MULT_ASSOC] >>
    REWRITE_TAC[GSYM WORD_LEFT_ADD_DISTRIB] >>
    simp[Abbr`d`] >> AP_TERM_TAC >>
    simp[Abbr`y`,word_mul_n2w,word_add_n2w] >>
    qspec_then`8`mp_tac DIVISION >> simp[] >>
    disch_then(qspec_then`LENGTH l`mp_tac) >>
    simp[])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isRefPtr x1 /\
            isByteArray (refs ' (getRefPtr x1)))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

(* get length value array *)

val (x64_get_length_array_res, x64_get_length_array_def, x64_get_length_array_pre_def) = x64_compile `
  x64_get_length_array (r0:word64,dm:word64 set,m:word64->word64) =
      let r0 = m (r0 + 1w) in
      let r0 = r0 >>> 14 in
        (r0,dm,m)`

val heap_lookup_IMP_heap_length = prove(
  ``heap n l. (heap_lookup n heap = SOME (RefBlock l)) ==>
    LENGTH l < heap_length heap``,
  Induct THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ FULL_SIMP_TAC std_ss [heap_lookup_def,heap_length_def,MAP,SUM] >> rw[] >>
  res_tac >> simp[RefBlock_def] >> simp[el_length_def])

val zHEAP_GET_LENGTH_ARRAY = let
  val th = x64_get_length_array_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isRefPtr x1 /\
            isValueArray (refs ' (getRefPtr x1)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Number (& (LENGTH (getValueArray (refs ' (getRefPtr x1))))),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val blast_lemma = blastLib.BBLAST_PROVE
    ``0w <= z  (z:word64) < 281474976710656w  ((z << 16 + 0x1w) >>> 14 = 0x4w * z)``
(*
gg goal
*)
  val lemma = prove(goal,
    simp[x64_get_length_array_def,SEP_EXISTS_THM,SEP_CLAUSES,zHEAP_def,SEP_IMP_def]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isRefPtr_def,getRefPtr_def,APPEND]
    \\ Cases_on `refs ' n` \\ FULL_SIMP_TAC std_ss [isValueArray_def,getValueArray_def]
    \\ `?f. (r1 = Pointer (f ' n)) /\ bc_ref_inv n refs (f,heap)` by ALL_TAC THEN1
      (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
        bc_value_inv_def] \\ Q.LIST_EXISTS_TAC [`f`]
      \\ ASM_SIMP_TAC std_ss []
      \\ `reachable_refs (RefPtr n::x2::x3::x4::stack) refs n` by ALL_TAC THEN1
       (FULL_SIMP_TAC std_ss [reachable_refs_def,MEM]
        \\ Q.LIST_EXISTS_TAC [`RefPtr n`,`n`]
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ res_tac)
    \\ rfs[bc_ref_inv_def,FLOOKUP_DEF]
    \\ Cases_on`n  FDOM f` >> fs[]
    \\ Cases_on`n  FDOM refs` >> fs[]
    \\ conj_tac >- (
      simp[x64_get_length_array_pre_def,x64_addr_def] >>
      imp_res_tac heap_lookup_SPLIT >>
      fs[x64_heap_APPEND,x64_heap_def,GSYM word_mul_n2w,x64_el_def,RefBlock_def,
         LET_THM,x64_payload_def] >>
      FULL_SIMP_TAC (std_ss++star_ss) [] >>
      FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def] >>
      reverse conj_tac >- (
        fs[heap_vars_ok_def] >>
        qpat_assum`X && vs.current_heap = Y`mp_tac >>
        blastLib.BBLAST_TAC ) >>
      fsrw_tac[ARITH_ss][] >>
      SEP_R_TAC )
    \\ REPEAT STRIP_TAC
    \\ simp[zVALS_def]
    \\ Q.EXISTS_TAC `vals with <| reg0 := ((0x4w * n2w (LENGTH l)))|>`
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ `LENGTH l = LENGTH zs` by fs[LIST_REL_EL_EQN]
    \\ `LENGTH l < 281474976710656` by (
        IMP_RES_TAC heap_lookup_IMP_heap_length >>
        fs[abs_ml_inv_def,heap_ok_def] >> rfs[] >>
        DECIDE_TAC )
    \\ conj_tac >- (
      Q.LIST_EXISTS_TAC [`vs`,`Data (2w * n2w (LENGTH l))`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`] >>
      simp[x64_addr_def,WORD_MUL_LSL,word_mul_n2w,w2w_def] >>
      simp[GSYM word_mul_n2w] >>
      MATCH_MP_TAC abs_ml_inv_Num >>
      map_every qexists_tac[`RefPtr n`,`Pointer (f ' n)`] >> simp[]) >>
    fs[GSYM STAR_ASSOC] >>
    qmatch_assum_abbrev_tac`(X * (Y * (Z * (zR 0x0w A * B)))) ss` >>
    qsuff_tac `A = 0x4w * n2w (LENGTH l)` >- (
      UNABBREV_ALL_TAC >> rw[] >>
      FULL_SIMP_TAC (std_ss++star_ss)[] >>
      qpat_assum`X s'`mp_tac >>
      REWRITE_TAC[GSYM APPEND_ASSOC,APPEND] ) >>
    UNABBREV_ALL_TAC >>
    qpat_assum`X s'` kall_tac >>
    imp_res_tac heap_lookup_SPLIT >>
    FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def] >>
    fs[GSYM word_mul_n2w,x64_el_def,RefBlock_def,LET_THM,x64_payload_def] >>
    SEP_R_TAC >>
    match_mp_tac blast_lemma >>
    simp[word_lt_n2w,WORD_ZERO_LE])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isRefPtr x1 /\
            isValueArray (refs ' (getRefPtr x1)))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

(* el *)

val el_lemma1 =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3)]`,`[(x1,r1);(x2,r2)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

val el_lemma2 =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2)]`,`[(x2,r2);(x1,r1)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,FORALL_PROD] |> GEN_ALL

val zHEAP_EL = let
  val th = compose_specs ["mov r0,[r1+2*r0+9]"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isBlock x2 /\ isNumber x1 /\ 0 <= getNumber x1 /\
            getNumber x1 < & LENGTH (getContent x2))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,EL (Num (getNumber x1)) (getContent x2),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isBlock_def,APPEND,getContent_def]
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isNumber_def,APPEND,getNumber_def]
    \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss []
    THEN1 (FULL_SIMP_TAC std_ss [LENGTH] \\ `F` by intLib.COOPER_TAC)
    \\ `Num i < LENGTH l` by intLib.COOPER_TAC
    \\ `abs_ml_inv (Block n l::Number i::x3::x4::stack) refs
         (r2::r1::r3::r4::roots,heap,a,sp) cs.heap_limit` by
       (MATCH_MP_TAC el_lemma2 \\ fs [] \\ REPEAT STRIP_TAC \\ fs [])
    \\ IMP_RES_TAC (el_thm |> Q.INST [`i`|->`Num j`])
    \\ NTAC 3 (POP_ASSUM (K ALL_TAC))
    \\ Q.PAT_ASSUM `heap_el r (Num i) heap = (y,T)` (ASSUME_TAC o GSYM)
    \\ Q.PAT_ASSUM `r2::r1::r3::r4::roots = r::roots2` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [CONS_11]
    \\ `?f. bc_value_inv (Block n l) (r2,f,heap)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ METIS_TAC []) \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [heap_el_def]
    \\ FULL_SIMP_TAC (srw_ss()) [BlockRep_def]
    \\ Cases_on `Num i < LENGTH xs` \\ FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,WORD_SUB_ADD]
    \\ `r1 = Data (2w * n2w (Num i))` by ALL_TAC THEN1
     (`small_int i /\ ~(i < 0)` by ALL_TAC THEN1
        (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
            bc_value_inv_def])
    \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ `(2 * Num i) < 9223372036854775808` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ IMP_RES_TAC LESS_LENGTH \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ Q.MATCH_ASSUM_RENAME_TAC `xs = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,one_list_APPEND,one_list_def,
         LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,AC WORD_ADD_COMM WORD_ADD_ASSOC,
         AC WORD_MULT_ASSOC WORD_MULT_COMM]
    \\ SEP_R_TAC \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [WORD_AND_COMM]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def])
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := x64_addr vs.current_heap z |>`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`z`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ `EL (Num i) (zs1 ++ z::zs2) = z` by METIS_TAC [EL_LENGTH]
      \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ REPEAT STRIP_TAC
      \\ MATCH_MP_TAC el_lemma1
      \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
    \\ STRIP_TAC THEN1
      (FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w,word_mul_n2w,MULT_ASSOC])
    \\ Q.PAT_ASSUM `xxx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
    \\ NTAC 2 (FULL_SIMP_TAC (srw_ss()++star_ss) [one_list_APPEND,one_list_def]
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC,SEP_CLAUSES,APPEND,GSYM APPEND_ASSOC]
      \\ FULL_SIMP_TAC std_ss [word_add_n2w,word_mul_n2w,LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,LEFT_ADD_DISTRIB,heap_length_APPEND,
           AC WORD_ADD_ASSOC WORD_ADD_COMM,word_mul_n2w,AC MULT_COMM MULT_ASSOC,
           heap_length_def]))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isBlock x2 /\ isNumber x1 /\ 0 <= getNumber x1 /\
            getNumber x1 < & LENGTH (getContent x2))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

val el_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2)]`,`[(x1,r1)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM] |> GEN_ALL

val zHEAP_EL_swapped = let
  val th = compose_specs ["mov r0,[r0+2*r1+9]"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isBlock x1 /\ isNumber x2 /\ 0 <= getNumber x2 /\
            getNumber x2 < & LENGTH (getContent x1))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,EL (Num (getNumber x2)) (getContent x1),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isBlock_def,APPEND,getContent_def]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def,APPEND,getNumber_def]
    \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss []
    THEN1 (FULL_SIMP_TAC std_ss [LENGTH] \\ `F` by intLib.COOPER_TAC)
    \\ `Num i < LENGTH l` by intLib.COOPER_TAC
    \\ IMP_RES_TAC (el_thm |> Q.INST [`i`|->`Num j`])
    \\ NTAC 3 (POP_ASSUM (K ALL_TAC))
    \\ Q.PAT_ASSUM `heap_el r (Num i) heap = (y,T)` (ASSUME_TAC o GSYM)
    \\ Q.PAT_ASSUM `r1::r2::r3::r4::roots = r::roots2` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [CONS_11]
    \\ `?f. bc_value_inv (Block n l) (r1,f,heap)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ METIS_TAC []) \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [heap_el_def]
    \\ FULL_SIMP_TAC (srw_ss()) [BlockRep_def]
    \\ Cases_on `Num i < LENGTH xs` \\ FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,WORD_SUB_ADD]
    \\ `r2 = Data (2w * n2w (Num i))` by ALL_TAC THEN1
     (`small_int i /\ ~(i < 0)` by ALL_TAC THEN1
        (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
            bc_value_inv_def])
    \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ `(2 * Num i) < 9223372036854775808` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ IMP_RES_TAC LESS_LENGTH \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ Q.MATCH_ASSUM_RENAME_TAC `xs = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,one_list_APPEND,one_list_def,
         LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,AC WORD_ADD_COMM WORD_ADD_ASSOC,
         AC WORD_MULT_ASSOC WORD_MULT_COMM]
    \\ SEP_R_TAC \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [WORD_AND_COMM]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def])
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := x64_addr vs.current_heap z |>`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`z`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ `EL (Num i) (zs1 ++ z::zs2) = z` by METIS_TAC [EL_LENGTH]
      \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ METIS_TAC [el_lemma])
    \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
    \\ STRIP_TAC THEN1
      (FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w,word_mul_n2w,MULT_ASSOC])
    \\ Q.PAT_ASSUM `xxx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
    \\ NTAC 2 (FULL_SIMP_TAC (srw_ss()++star_ss) [one_list_APPEND,one_list_def]
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC,SEP_CLAUSES,APPEND,GSYM APPEND_ASSOC]
      \\ FULL_SIMP_TAC std_ss [word_add_n2w,word_mul_n2w,LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,LEFT_ADD_DISTRIB,heap_length_APPEND,
           AC WORD_ADD_ASSOC WORD_ADD_COMM,word_mul_n2w,AC MULT_COMM MULT_ASSOC,
           heap_length_def]))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isBlock x1 /\ isNumber x2 /\ 0 <= getNumber x2 /\
            getNumber x2 < & LENGTH (getContent x1))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

(* sub1 *)

val isNumber_EXISTS = prove(
  ``!x. isNumber x <=> ?i. x = Number i``,
  Cases \\ SIMP_TAC (srw_ss()) [isNumber_def]);

val small_int_IMP = prove(
  ``small_int i /\ ~(i < 0) ==> (2 * Num i) < dimword (:63)``,
  SIMP_TAC (srw_ss()) [small_int_def] \\ intLib.COOPER_TAC);

fun zHEAP_SUB1 n = let
  val th = if n = ``1:num`` then compose_specs ["sub r0,4"] else
           if n = ``2:num`` then compose_specs ["sub r1,4"] else
           if n = ``3:num`` then compose_specs ["sub r2,4"] else
           if n = ``4:num`` then compose_specs ["sub r3,4"] else fail()
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            small_int (getNumber ^x) /\
            (getNumber ^x <> 0) /\ ~(getNumber ^x < 0) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       if ^n = 1 then Number (getNumber x1 - 1) else x1,
       if ^n = 2 then Number (getNumber x2 - 1) else x2,
       if ^n = 3 then Number (getNumber x3 - 1) else x3,
       if ^n = 4 then Number (getNumber x4 - 1) else x4,
       refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [isNumber_EXISTS]
    \\ FULL_SIMP_TAC std_ss [getNumber_def]
    \\ `if ^n = 1 then (r1 = Data (0x2w * n2w (Num i))) else
        if ^n = 2 then (r2 = Data (0x2w * n2w (Num i))) else
        if ^n = 3 then (r3 = Data (0x2w * n2w (Num i))) else
        if ^n = 4 then (r4 = Data (0x2w * n2w (Num i))) else ARB` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,LIST_REL_def]
      \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC std_ss [getNumber_def]
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [bc_value_inv_def])
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ IMP_RES_TAC small_int_IMP
    \\ FULL_SIMP_TAC std_ss [w2n_n2w,MULT_ASSOC]
    \\ `n2w (4 * Num i) - 0x4w = n2w (4 * Num (i - 1)):word64` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [small_int_def]
      \\ `Num i <> 0` by intLib.COOPER_TAC
      \\ ASM_SIMP_TAC std_ss [word_arith_lemma2] \\ AP_TERM_TAC
      \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with
         <| reg0 := (if ^n = 1 then vals.reg0 - 4w else vals.reg0) ;
            reg1 := (if ^n = 2 then vals.reg1 - 4w else vals.reg1) ;
            reg2 := (if ^n = 3 then vals.reg2 - 4w else vals.reg2) ;
            reg3 := (if ^n = 4 then vals.reg3 - 4w else vals.reg3) |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
      \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC])
    \\ SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
          `if ^n = 1 then Data (n2w (2 * Num (i-1))) else r1`,
          `if ^n = 2 then Data (n2w (2 * Num (i-1))) else r2`,
          `if ^n = 3 then Data (n2w (2 * Num (i-1))) else r3`,
          `if ^n = 4 then Data (n2w (2 * Num (i-1))) else r4`,
          `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,w2n_n2w]
    \\ `(2 * Num (i - 1)) < 9223372036854775808` by ALL_TAC THEN1
     (Q.PAT_ASSUM `i <> 0` MP_TAC
      \\ Q.PAT_ASSUM `small_int i` MP_TAC
      \\ REPEAT (POP_ASSUM (K ALL_TAC))
      \\ FULL_SIMP_TAC (srw_ss()) [small_int_def]
      \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def,word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ `i - 1 = & (Num (i - 1))` by
     (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ POP_ASSUM (fn th => SIMP_TAC std_ss [Once th])
    \\ `Num (i - 1) < 4611686018427387904` by intLib.COOPER_TAC
    \\ `(2 * Num (i  1)) < 9223372036854775808` by intLib.COOPER_TAC
    \\ ASM_SIMP_TAC std_ss [MULT_ASSOC]
    \\ METIS_TAC [swap_1_lemmas,abs_ml_inv_Num_new])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (small_int (getNumber ^x) /\
            (getNumber ^x <> 0) /\ isNumber ^x /\ ~(getNumber ^x < 0))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val sub1_1 = zHEAP_SUB1 ``1:num``;
val sub1_2 = zHEAP_SUB1 ``2:num``;
val sub1_3 = zHEAP_SUB1 ``3:num``;
val sub1_4 = zHEAP_SUB1 ``4:num``;


(* add1 *)

fun zHEAP_ADD1 n = let
  val th = if n = ``1:num`` then compose_specs ["add r0,4"] else
           if n = ``2:num`` then compose_specs ["add r1,4"] else
           if n = ``3:num`` then compose_specs ["add r2,4"] else
           if n = ``4:num`` then compose_specs ["add r3,4"] else fail()
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            small_int (getNumber ^x) /\
            small_int (getNumber ^x + 1) /\ ~(getNumber ^x < 0) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       if ^n = 1 then Number (getNumber x1 + 1) else x1,
       if ^n = 2 then Number (getNumber x2 + 1) else x2,
       if ^n = 3 then Number (getNumber x3 + 1) else x3,
       if ^n = 4 then Number (getNumber x4 + 1) else x4,
       refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [isNumber_EXISTS]
    \\ FULL_SIMP_TAC std_ss [getNumber_def]
    \\ `if ^n = 1 then (r1 = Data (0x2w * n2w (Num i))) else
        if ^n = 2 then (r2 = Data (0x2w * n2w (Num i))) else
        if ^n = 3 then (r3 = Data (0x2w * n2w (Num i))) else
        if ^n = 4 then (r4 = Data (0x2w * n2w (Num i))) else ARB` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,LIST_REL_def]
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def])
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ IMP_RES_TAC small_int_IMP
    \\ FULL_SIMP_TAC std_ss [w2n_n2w,MULT_ASSOC]
    \\ `n2w (4 * Num i) + 0x4w = n2w (4 * Num (i + 1)):word64` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [small_int_def]
      \\ ASM_SIMP_TAC std_ss [word_arith_lemma1] \\ AP_TERM_TAC
      \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with
         <| reg0 := (if ^n = 1 then vals.reg0 + 4w else vals.reg0) ;
            reg1 := (if ^n = 2 then vals.reg1 + 4w else vals.reg1) ;
            reg2 := (if ^n = 3 then vals.reg2 + 4w else vals.reg2) ;
            reg3 := (if ^n = 4 then vals.reg3 + 4w else vals.reg3) |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
      \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC])
    \\ SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
          `if ^n = 1 then Data (n2w (2 * Num (i+1))) else r1`,
          `if ^n = 2 then Data (n2w (2 * Num (i+1))) else r2`,
          `if ^n = 3 then Data (n2w (2 * Num (i+1))) else r3`,
          `if ^n = 4 then Data (n2w (2 * Num (i+1))) else r4`,
          `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,w2n_n2w]
    \\ `(2 * Num (i + 1)) < 9223372036854775808` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def,word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ `i + 1 = & (Num (i + 1))` by
     (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ POP_ASSUM (fn th => SIMP_TAC std_ss [Once th])
    \\ `Num (i + 1) < 4611686018427387904` by intLib.COOPER_TAC
    \\ `(2 * Num (i + 1)) < 9223372036854775808` by intLib.COOPER_TAC
    \\ ASM_SIMP_TAC std_ss [MULT_ASSOC]
    \\ METIS_TAC [swap_1_lemmas,abs_ml_inv_Num_new])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (small_int (getNumber ^x) /\ small_int (getNumber ^x + 1) /\
            ~(getNumber ^x < 0) /\ isNumber ^x)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val add1_1 = zHEAP_ADD1 ``1:num``;
val add1_2 = zHEAP_ADD1 ``2:num``;
val add1_3 = zHEAP_ADD1 ``3:num``;
val add1_4 = zHEAP_ADD1 ``4:num``;


(* DIV 2 *)

val n2w_lsr = prove(
  ``!m n. n < dimword (:'a) ==> ((n2w n) >>> m = n2w (n DIV 2 ** m) :'a word)``,
  FULL_SIMP_TAC std_ss [GSYM w2n_11,w2n_lsr,w2n_n2w] \\ REPEAT STRIP_TAC
  \\ `(n DIV 2 ** m) < dimword (:'a)` by ALL_TAC
  \\ FULL_SIMP_TAC std_ss [DIV_LT_X]
  \\ `0 < (2:num)**m` by FULL_SIMP_TAC std_ss [bitTheory.ZERO_LT_TWOEXP]
  \\ Cases_on `(2:num)**m` \\ FULL_SIMP_TAC std_ss []
  \\ FULL_SIMP_TAC std_ss [MULT_CLAUSES]
  \\ DECIDE_TAC);

val NumDIV = prove(
  ``~(i < 0) ==> (4 * Num i DIV 8 = Num (i / 2))``,
  Cases_on `i` \\ SRW_TAC [] []
  \\ STRIP_ASSUME_TAC (MATCH_MP DIVISION (DECIDE ``0<2:num``) |> Q.SPEC `n`)
  \\ Q.PAT_ASSUM `n = kkk` (fn th => SIMP_TAC std_ss [Once th])
  \\ ONCE_REWRITE_TAC [MULT_COMM]
  \\ SRW_TAC [] [RIGHT_ADD_DISTRIB]
  \\ SIMP_TAC std_ss [GSYM MULT_ASSOC]
  \\ MATCH_MP_TAC (MP_CANON DIV_MULT)
  \\ DECIDE_TAC);

fun zHEAP_DIV2 n = let
  val th = if n = ``1:num`` then compose_specs ["shr r0,3","shl r0,2"] else
           if n = ``2:num`` then compose_specs ["shr r1,3","shl r1,2"] else
           if n = ``3:num`` then compose_specs ["shr r2,3","shl r2,2"] else
           if n = ``4:num`` then compose_specs ["shr r3,3","shl r3,2"] else fail()
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            small_int (getNumber ^x) /\ ~(getNumber ^x < 0) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       if ^n = 1 then Number (getNumber x1 / 2) else x1,
       if ^n = 2 then Number (getNumber x2 / 2) else x2,
       if ^n = 3 then Number (getNumber x3 / 2) else x3,
       if ^n = 4 then Number (getNumber x4 / 2) else x4,
       refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [isNumber_EXISTS]
    \\ FULL_SIMP_TAC std_ss [getNumber_def]
    \\ `if ^n = 1 then (r1 = Data (0x2w * n2w (Num i))) else
        if ^n = 2 then (r2 = Data (0x2w * n2w (Num i))) else
        if ^n = 3 then (r3 = Data (0x2w * n2w (Num i))) else
        if ^n = 4 then (r4 = Data (0x2w * n2w (Num i))) else ARB` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,LIST_REL_def]
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def])
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ IMP_RES_TAC small_int_IMP
    \\ FULL_SIMP_TAC std_ss [w2n_n2w,MULT_ASSOC]
    \\ `(0x4w * n2w (4 * Num i) >>> 3 = n2w (4 * Num (i / 2)):word64) /\
        (n2w (4 * Num i) >>> 3 << 2 = n2w (4 * Num (i / 2)):word64)` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) []
      \\ `4 * Num i < 2 * 9223372036854775808` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ `4 * Num i < dimword (:64)` by FULL_SIMP_TAC (srw_ss()) []
      \\ IMP_RES_TAC n2w_lsr \\ FULL_SIMP_TAC std_ss [word_mul_n2w,WORD_MUL_LSL]
      \\ AP_TERM_TAC \\ AP_TERM_TAC
      \\ MATCH_MP_TAC NumDIV \\ FULL_SIMP_TAC std_ss [])
    \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with
         <| reg0 := (if ^n = 1 then vals.reg0 >>> 3 << 2 else vals.reg0) ;
            reg1 := (if ^n = 2 then vals.reg1 >>> 3 << 2 else vals.reg1) ;
            reg2 := (if ^n = 3 then vals.reg2 >>> 3 << 2 else vals.reg2) ;
            reg3 := (if ^n = 4 then vals.reg3 >>> 3 << 2 else vals.reg3) |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
      \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC])
    \\ SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
          `if ^n = 1 then Data (n2w (2 * Num (i/2))) else r1`,
          `if ^n = 2 then Data (n2w (2 * Num (i/2))) else r2`,
          `if ^n = 3 then Data (n2w (2 * Num (i/2))) else r3`,
          `if ^n = 4 then Data (n2w (2 * Num (i/2))) else r4`,
          `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,WORD_MUL_LSL,w2w_def,w2n_n2w]
    \\ `(2 * Num (i / 2)) < 4611686018427387904` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def,word_mul_n2w]
    \\ `Num (i / 2) < 2305843009213693952` by intLib.COOPER_TAC
    \\ `(2 * Num (i / 2)) < 9223372036854775808` by intLib.COOPER_TAC
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ `i / 2 = & (Num (i / 2))` by
     (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
     \\ POP_ASSUM (fn th => SIMP_TAC std_ss [Once th])
    \\ METIS_TAC [swap_1_lemmas,abs_ml_inv_Num])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (small_int (getNumber ^x) /\
            ~(getNumber ^x < 0) /\ isNumber ^x)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val div2_1 = zHEAP_DIV2 ``1:num``;
val div2_2 = zHEAP_DIV2 ``2:num``;
val div2_3 = zHEAP_DIV2 ``3:num``;
val div2_4 = zHEAP_DIV2 ``4:num``;


(* is EVEN *)

val EVEN_SPLIT = prove(
  ``!n. n = 2 * (n DIV 2) + (if EVEN n then 0 else 1)``,
  ONCE_REWRITE_TAC [MULT_COMM] \\ REPEAT STRIP_TAC
  \\ STRIP_ASSUME_TAC (Q.SPEC `n` (MATCH_MP DIVISION (DECIDE ``0<2:num``)))
  \\ Q.PAT_ASSUM `n = kkk` (fn th => SIMP_TAC std_ss [Once th])
  \\ SIMP_TAC std_ss [arithmeticTheory.EVEN_MOD2]
  \\ DECIDE_TAC);

val EVEN_LEMMA = prove(
  ``(0x4w && n2w (4 * n) = 0x0w:word64) <=> EVEN n``,
  `n = 2 * (n DIV 2) + (if EVEN n then 0 else 1)` by FULL_SIMP_TAC std_ss [EVEN_SPLIT]
  \\ POP_ASSUM (fn th => SIMP_TAC std_ss [Once th])
  \\ Cases_on `EVEN n` \\ FULL_SIMP_TAC std_ss []
  \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
  \\ blastLib.BBLAST_TAC);

fun zHEAP_IS_EVEN n = let
  val th = if n = ``1:num`` then spec "test r0,4" else
           if n = ``2:num`` then spec "test r1,4" else
           if n = ``3:num`` then spec "test r2,4" else
           if n = ``4:num`` then spec "test r3,4" else fail()
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ~(getNumber ^x < 0) /\ small_int (getNumber ^x) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (EVEN (Num (getNumber ^x)))) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val reg = ``if ^n = 1 then vals.reg0 else
              if ^n = 2 then vals.reg1 else
              if ^n = 3 then vals.reg2 else
              if ^n = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `EVEN (Num (getNumber ^x)) <=> (^reg && 4w = 0x0w)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
      \\ FULL_SIMP_TAC std_ss [getNumber_def,x64_addr_def]
      \\ `(2 * (Num i)) < dimword (:63)` by IMP_RES_TAC small_int_IMP
      \\ REVERSE (Cases_on `i`) \\ FULL_SIMP_TAC (srw_ss()) []
      \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword,w2w_def]
      \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC] \\ METIS_TAC [EVEN_LEMMA])
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (~(getNumber ^x < 0) /\ small_int (getNumber ^x) /\ isNumber ^x)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val zHEAP_IS_EVEN_1 = zHEAP_IS_EVEN ``1:num``;
val zHEAP_IS_EVEN_2 = zHEAP_IS_EVEN ``2:num``;
val zHEAP_IS_EVEN_3 = zHEAP_IS_EVEN ``3:num``;
val zHEAP_IS_EVEN_4 = zHEAP_IS_EVEN ``4:num``;


(* compare with zero *)

fun zHEAP_IS_ZERO n = let
  val th = if n = ``1:num`` then spec "test r0,r0" else
           if n = ``2:num`` then spec "test r1,r1" else
           if n = ``3:num`` then spec "test r2,r2" else
           if n = ``4:num`` then spec "test r3,r3" else fail()
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ~(getNumber ^x < 0) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (getNumber ^x = 0)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val reg = ``if ^n = 1 then vals.reg0 else
              if ^n = 2 then vals.reg1 else
              if ^n = 3 then vals.reg2 else
              if ^n = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(getNumber ^x = 0) <=> (^reg = 0x0w)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
      \\ REVERSE (Cases_on `small_int i`) \\ FULL_SIMP_TAC std_ss [] THEN1
       (`i <> 0` by ALL_TAC THEN1
          (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
        \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [x64_addr_def,heap_vars_ok_def]
        \\ blastLib.BBLAST_TAC)
      \\ Cases_on `i = 0`
      THEN1 (FULL_SIMP_TAC std_ss [x64_addr_def] \\ EVAL_TAC)
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
      \\ REVERSE (Cases_on `i`) \\ FULL_SIMP_TAC (srw_ss()) []
      THEN1 (FULL_SIMP_TAC (srw_ss()) [small_int_def,getNumber_def])
      \\ `(2 * n) < dimword (:63)` by IMP_RES_TAC small_int_IMP
      \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword]
      \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC]
      \\ `(4 * n) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (~(getNumber ^x < 0) /\ isNumber ^x)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val zHEAP_IS_ZERO_1 = zHEAP_IS_ZERO ``1:num``;
val zHEAP_IS_ZERO_2 = zHEAP_IS_ZERO ``2:num``;
val zHEAP_IS_ZERO_3 = zHEAP_IS_ZERO ``3:num``;
val zHEAP_IS_ZERO_4 = zHEAP_IS_ZERO ``4:num``;


(* compare with const *)

fun zHEAP_IS_CONST n k = let
  val k = k |> numSyntax.term_of_int
  val kk = ``^k * 4`` |> EVAL |> concl |> rand
  val kk_str = kk |> numSyntax.int_of_term |> int_to_string
  val th = if n = ``1:num`` then spec ("cmp r0," ^ kk_str) else
           if n = ``2:num`` then spec ("cmp r1," ^ kk_str) else
           if n = ``3:num`` then spec ("cmp r2," ^ kk_str) else
           if n = ``4:num`` then spec ("cmp r3," ^ kk_str) else fail()
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ~(getNumber ^x < 0) /\ isNumber ^x)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (getNumber ^x = &(^k))) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val reg = ``if ^n = 1 then vals.reg0 else
              if ^n = 2 then vals.reg1 else
              if ^n = 3 then vals.reg2 else
              if ^n = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(getNumber ^x = &(^k)) <=> (^reg = n2w (^kk))` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
      \\ REVERSE (Cases_on `small_int i`) \\ FULL_SIMP_TAC std_ss [] THEN1
       (`i <> &(^k)` by ALL_TAC THEN1
          (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
        \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [x64_addr_def,heap_vars_ok_def]
        \\ blastLib.BBLAST_TAC)
      \\ Cases_on `i = &(^k)`
      THEN1 (FULL_SIMP_TAC std_ss [x64_addr_def] \\ EVAL_TAC)
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,
           w2n_n2w,getNumber_def]
      \\ `(2 * Num i) < dimword (:63)` by IMP_RES_TAC small_int_IMP
      \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword]
      \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC]
      \\ `(4 * Num i) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (~(getNumber ^x < 0) /\ isNumber ^x)``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val _ = map (zHEAP_IS_CONST ``1:num``) (map ord (explode "let(struct)sig[end];"))
val _ = map (zHEAP_IS_CONST ``1:num``) (tl (up_to 60));
val _ = map (zHEAP_IS_CONST ``2:num``) (tl (up_to 10));
val _ = map (zHEAP_IS_CONST ``3:num``) (tl (up_to 10));
val _ = map (zHEAP_IS_CONST ``4:num``) (tl (up_to 10));

val _ = zHEAP_IS_CONST ``1:num`` 92;

val zHEAP_1EQ0 = zHEAP_IS_CONST ``1:num`` 0;
val zHEAP_2EQ0 = zHEAP_IS_CONST ``2:num`` 0;
val zHEAP_3EQ0 = zHEAP_IS_CONST ``3:num`` 0;
val zHEAP_4EQ0 = zHEAP_IS_CONST ``4:num`` 0;


(* compare small_ints *)

val small_int_IMP_NUM = prove(
  ``small_int i ==> ?n. (i = &n) /\ n < 2 ** 62``,
  Cases_on `i` \\ fs [small_int_def]);

fun zHEAP_CMP_SMALL_INT (i,j) = let
  val n = i |> numSyntax.term_of_int
  val m = j |> numSyntax.term_of_int
  val rn = i |> (fn n => "r" ^ int_to_string (n - 1))
  val rm = j |> (fn n => "r" ^ int_to_string (n - 1))
  val th = spec ("cmp " ^ rn ^ "," ^ rm)
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val y = ``if ^m = 1:num then x1 else
            if ^m = 2 then x2 else
            if ^m = 3 then x3 else
            if ^m = 4 then x4 else ARB:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            (~small_int (getNumber ^x) ==> small_int (getNumber ^y)) /\
            isNumber ^x /\ isNumber ^y)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (getNumber ^x = getNumber ^y)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val regn = ``if ^n = 1 then vals.reg0 else
               if ^n = 2 then vals.reg1 else
               if ^n = 3 then vals.reg2 else
               if ^n = 4 then vals.reg3 else ARB``
  val regm = ``if ^m = 1 then vals.reg0 else
               if ^m = 2 then vals.reg1 else
               if ^m = 3 then vals.reg2 else
               if ^m = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(getNumber ^x = getNumber ^y) <=> (^regn = ^regm)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
      \\ Q.MATCH_ASSUM_RENAME_TAC `xxx = Number j`
      \\ Cases_on `small_int i` \\ Cases_on `small_int j`
      \\ FULL_SIMP_TAC std_ss [] THEN1
       (FULL_SIMP_TAC std_ss [x64_addr_def]
        \\ REVERSE (Cases_on `i < 0:int`) \\ REVERSE (Cases_on `j < 0:int`)
        \\ FULL_SIMP_TAC std_ss [] THEN1
         (`(2 * Num i) < dimword (:63)` by IMP_RES_TAC small_int_IMP
          \\ `(2 * Num j) < dimword (:63)` by IMP_RES_TAC small_int_IMP
          \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
          \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword]
          \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC]
          \\ `(4 * Num i) < 18446744073709551616` by DECIDE_TAC
          \\ `(4 * Num j) < 18446744073709551616` by DECIDE_TAC
          \\ FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
        \\ `!k. ~(&k < 0:int)` by intLib.COOPER_TAC
        \\ FULL_SIMP_TAC std_ss [EVAL ``0<0:int``]
        THEN1 (fs [small_int_def] \\ `F` by intLib.COOPER_TAC)
        THEN1 (fs [small_int_def] \\ `F` by intLib.COOPER_TAC)
        \\ IMP_RES_TAC small_int_IMP_NUM \\ fs [])
      \\ `i <> j` by (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [x64_addr_def]
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond ((small_int (getNumber ^x) \/ small_int (getNumber ^y)) /\
            isNumber ^x /\ isNumber ^y)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM] \\ Cases_on `small_int (getNumber ^x)`
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

fun n_times 0 f x = x | n_times n f x = n_times (n-1) f (f x)
val regs = (up_to 4) |> map (fn n => n+1)
val reg_combs = map (fn n => map (fn m => (n,m)) (n_times n tl (tl (up_to 5)))) regs
  |> flatten

val zHEAP_CMP_SMALL_INT_12 = zHEAP_CMP_SMALL_INT (1,2)
val _ = map zHEAP_CMP_SMALL_INT reg_combs;


(* less-than for smallints *)

val zHEAP_SMALL_INT_LESS = let
  val th = spec ("cmp r1,r0")
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_ZF`` th
  val pc = get_pc th
  val x = ``x2:bc_value``
  val y = ``x1:bc_value``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ~(getNumber ^x < 0) /\ ~(getNumber ^y < 0) /\
            small_int (getNumber ^x) /\ small_int (getNumber ^y) /\
            isNumber ^x /\ isNumber ^y)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_ZF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_CF (SOME (getNumber x2 < getNumber x1)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ REVERSE (`(getNumber x2 < getNumber x1) <=> (vals.reg1 <+ vals.reg0)` by ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
         bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
    \\ Q.MATCH_ASSUM_RENAME_TAC `xxx = Number j`
    \\ Cases_on `small_int i` \\ Cases_on `small_int j`
    \\ FULL_SIMP_TAC std_ss [] \\ IMP_RES_TAC small_int_IMP
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
    \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword]
    \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC,WORD_LO]
    \\ `(4 * Num i) < 18446744073709551616` by DECIDE_TAC
    \\ `(4 * Num j) < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [small_int_def]
    \\ intLib.COOPER_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond ((small_int (getNumber x1) /\ small_int (getNumber x2)) /\
            ~(getNumber ^x < 0) /\ ~(getNumber ^y < 0) /\
            isNumber x1 /\ isNumber x2)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM] \\ Cases_on `small_int (getNumber ^x)`
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;


(* compare small_int with const *)

fun zHEAP_LESS_SMALL_INT_CONST (i,c) = let
  val n = i |> numSyntax.term_of_int
  val m = c |> numSyntax.term_of_int
  val rn = i |> (fn n => "r" ^ int_to_string (n - 1))
  val rm = c |> (fn n => int_to_string (n * 4))
  val th = spec ("cmp " ^ rn ^ "," ^ rm)
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_ZF`` th
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val pre = ``~(getNumber ^x < 0) /\ small_int (getNumber ^x) /\ isNumber ^x``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      zS1 Z_CF (SOME (getNumber ^x < & (^m))) * ~zS1 Z_OF *
      ~zS1 Z_SF * ~zS1 Z_ZF * ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val regn = ``if ^n = 1 then vals.reg0 else
               if ^n = 2 then vals.reg1 else
               if ^n = 3 then vals.reg2 else
               if ^n = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(getNumber ^x < & ^m) <=> (^regn <+ n2w (4 * ^m))` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isNumber_EXISTS,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def,getNumber_def]
      \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
      \\ Q.MATCH_ASSUM_RENAME_TAC `xxx = Number j`
      \\ `(2 * Num j) < dimword (:63)` by ALL_TAC
      THEN1 (FULL_SIMP_TAC (srw_ss()) [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w,n2w_11,ZERO_LT_dimword]
      \\ FULL_SIMP_TAC (srw_ss()) [MULT_ASSOC]
      \\ `(4 * Num j) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO]
      \\ FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM] \\ Cases_on `small_int (getNumber ^x)`
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

fun zHEAP_LESS_CONST c = let
  val _ = zHEAP_LESS_SMALL_INT_CONST (1,c)
  val _ = zHEAP_LESS_SMALL_INT_CONST (2,c)
  val _ = zHEAP_LESS_SMALL_INT_CONST (3,c)
  val _ = zHEAP_LESS_SMALL_INT_CONST (4,c)
  in () end

fun pow2 0 = 1
  | pow2 n = 2 * pow2 (n - 1)

val _ = map zHEAP_LESS_CONST [pow2 1, pow2 2, pow2 3, pow2 4,
                              pow2 8, pow2 12, pow2 15, pow2 28]

val _ = zHEAP_LESS_CONST
          (globals_count_def |> concl |> rand |> numSyntax.int_of_term);


(* shift small_int *)

fun zHEAP_SHIFT_SMALL_INT (i,c) = let
  val n = i |> numSyntax.term_of_int
  val m = c |> numSyntax.term_of_int
  val rn = i |> (fn n => "r" ^ int_to_string (n - 1))
  val rm = c |> (fn n => int_to_string n)
  val th = compose_specs ["shl " ^ rn ^ "," ^ rm]
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val res = ``getNumber ^x * & (2 ** ^m)``
  val pre = ``~(getNumber ^x < 0) /\
              small_int (getNumber ^x) /\ small_int ^res /\ isNumber ^x``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       if ^n = 1 then Number ^res else x1,
       if ^n = 2 then Number ^res else x2,
       if ^n = 3 then Number ^res else x3,
       if ^n = 4 then Number ^res else x4,
       refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val regn = ``if ^n = 1 then vals.reg0 else
               if ^n = 2 then vals.reg1 else
               if ^n = 3 then vals.reg2 else
               if ^n = 4 then vals.reg3 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals with
          <| reg0 := if ^n = 1 then vals.reg0 << ^m else vals.reg0 ;
             reg1 := if ^n = 2 then vals.reg1 << ^m else vals.reg1 ;
             reg2 := if ^n = 3 then vals.reg2 << ^m else vals.reg2 ;
             reg3 := if ^n = 4 then vals.reg3 << ^m else vals.reg3 |> `]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Cases_on `if ^n = 1 then x1 else
                 if ^n = 2 then x2 else
                 if ^n = 3 then x3 else
                 if ^n = 4 then x4 else ARB`
    \\ FULL_SIMP_TAC std_ss [getNumber_def,isNumber_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
          `if ^n = 1 then Data (0x2w * n2w (Num i) << ^m) else r1`,
          `if ^n = 2 then Data (0x2w * n2w (Num i) << ^m) else r2`,
          `if ^n = 3 then Data (0x2w * n2w (Num i) << ^m) else r3`,
          `if ^n = 4 then Data (0x2w * n2w (Num i) << ^m) else r4`,
          `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
    \\ SIMP_TAC std_ss [PULL_EXISTS]
    \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [reachable_refs_SIMP]
    \\ SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [roots_ok_def]
    THEN1 (FULL_SIMP_TAC (srw_ss()) [MEM] \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w,WORD_MUL_LSL]
    THEN1 (FULL_SIMP_TAC std_ss [small_int_def]
           \\ SRW_TAC [] []
           \\ FULL_SIMP_TAC std_ss [word_mul_n2w,WORD_MUL_LSL]
           \\ AP_THM_TAC \\ AP_TERM_TAC \\ intLib.COOPER_TAC)
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,WORD_MUL_LSL]
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM] \\ Cases_on `small_int (getNumber ^x)`
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

fun zHEAP_SHIFT_BY_INT c = let
  val _ = zHEAP_SHIFT_SMALL_INT (1,c)
  val _ = zHEAP_SHIFT_SMALL_INT (2,c)
  val _ = zHEAP_SHIFT_SMALL_INT (3,c)
  val _ = zHEAP_SHIFT_SMALL_INT (4,c)
  in () end

val _ = map zHEAP_SHIFT_BY_INT [1,2,3]


(* cmp against bool_to_val F *)

val zHEAP_CMP_FALSE = let
  val th = spec ("cmp r0,42")
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isBlock x1)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (x1 = bool_to_val F)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(x1 = bool_to_val F) <=> (vals.reg0 = 42w)` by ALL_TAC
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ Cases_on `x1` \\ FULL_SIMP_TAC (srw_ss()) [isBlock_def]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
         bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def,word_mul_n2w,w2w_def,w2n_n2w]
    \\ REVERSE (Cases_on `l = []`) \\ FULL_SIMP_TAC std_ss [] THEN1
     (FULL_SIMP_TAC std_ss [x64_addr_def]
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def]
      \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ Cases_on `n = 10` \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
    \\ SIMP_TAC (srw_ss()) [word_add_n2w,w2w_def,w2n_n2w]
    \\ `(2 * n + 1) < 9223372036854775808` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC (srw_ss()) [WORD_MUL_LSL,word_mul_n2w,n2w_11]
    \\ REWRITE_TAC [GSYM (EVAL ``(2:num) * 2**63``)]
    \\ `(0:num) < 2 /\ (0:num) < 2**63` by EVAL_TAC
    \\ IMP_RES_TAC MOD_COMMON_FACTOR
    \\ FULL_SIMP_TAC std_ss []
    \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isBlock x1)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;


(* swaps *)

fun zHEAP_SWAP (i,j) = let
  val _ = (i < j) orelse fail()
  val n = i |> numSyntax.term_of_int
  val m = j |> numSyntax.term_of_int
  val rn = i |> (fn n => "r" ^ int_to_string (n - 1))
  val rm = j |> (fn n => "r" ^ int_to_string (n - 1))
  val th = spec ("xchg " ^ rm ^ "," ^ rn)
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val x = ``if ^n = 1:num then x1 else
            if ^n = 2 then x2 else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB:bc_value``
  val y = ``if ^m = 1:num then x1 else
            if ^m = 2 then x2 else
            if ^m = 3 then x3 else
            if ^m = 4 then x4 else ARB:bc_value``
  val target = ``zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       if ^n = 1 then ^y else if ^m = 1 then ^x else x1,
       if ^n = 2 then ^y else if ^m = 2 then ^x else x2,
       if ^n = 3 then ^y else if ^m = 3 then ^x else x3,
       if ^n = 4 then ^y else if ^m = 4 then ^x else x4,
       refs,stack,s,NONE) * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val regn = ``if ^n = 1 then vals.reg0 else
               if ^n = 2 then vals.reg1 else
               if ^n = 3 then vals.reg2 else
               if ^n = 4 then vals.reg3 else ARB``
  val regm = ``if ^m = 1 then vals.reg0 else
               if ^m = 2 then vals.reg1 else
               if ^m = 3 then vals.reg2 else
               if ^m = 4 then vals.reg3 else ARB``
  val rn =   ``if ^n = 1 then r1:63 word heap_address else
               if ^n = 2 then r2 else
               if ^n = 3 then r3 else
               if ^n = 4 then r4 else ARB``
  val rm =   ``if ^m = 1 then r1:63 word heap_address else
               if ^m = 2 then r2 else
               if ^m = 3 then r3 else
               if ^m = 4 then r4 else ARB``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with
        <| reg0 := if ^n = 1 then ^regm else if ^m = 1 then ^regn else vals.reg0 ;
           reg1 := if ^n = 2 then ^regm else if ^m = 2 then ^regn else vals.reg1 ;
           reg2 := if ^n = 3 then ^regm else if ^m = 3 then ^regn else vals.reg2 ;
           reg3 := if ^n = 4 then ^regm else if ^m = 4 then ^regn else vals.reg3 |>`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
          `if ^n = 1 then ^rm else if ^m = 1 then ^rn else r1`,
          `if ^n = 2 then ^rm else if ^m = 2 then ^rn else r2`,
          `if ^n = 3 then ^rm else if ^m = 3 then ^rn else r3`,
          `if ^n = 4 then ^rm else if ^m = 4 then ^rn else r4`,
          `roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt rr` MP_TAC
    \\ MATCH_MP_TAC move_lemma
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end;

val _ = map zHEAP_SWAP reg_combs;

val zHEAP_SWAP_12 = zHEAP_SWAP (1,2)
val zHEAP_SWAP_13 = zHEAP_SWAP (1,3)
val zHEAP_SWAP_14 = zHEAP_SWAP (1,4)


(* isBlock *)

val (x64_is_block_cert, x64_is_block_def) = x64_decompile_no_status "x64_is_block" `
  test r0, 1
  jne PTR
  mov r15,r0
  not r15
  test r15,2
  jmp EXIT
PTR:
  mov r15,[r0+1]
  test r15,7
EXIT: `;

val FST_IF = prove(
  ``!b. FST (if b then (x,y) else (x2,y2)) = if b then x else x2``,
  Cases \\ SIMP_TAC std_ss []);

val SND_IF = prove(
  ``!b. SND (if b then (x,y) else (x2,y2)) = if b then y else y2``,
  Cases \\ SIMP_TAC std_ss []);

val PULL_IMP_EXISTS = METIS_PROVE []
  ``(P ==> ?x. Q x) <=> ?x. P ==> Q x``

val heap_inv_ignore_reg15 = prove(
  ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) (vals with reg15 := w) =
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals``,
  SIMP_TAC (srw_ss()) [heap_inv_def]);

val zHEAP_isBlock = let
  val th =
    x64_is_block_cert
    |> SIMP_RULE std_ss [LET_DEF,x64_is_block_def]
    |> CONV_RULE (DEPTH_CONV PairRules.PBETA_CONV)
    |> SIMP_RULE std_ss [FST_IF,SND_IF]
    |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
    |> UNDISCH
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``zPC p * ~zS * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            canCompare x1)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,
       refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (isBlock x1)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = METIS_PROVE []
    ``!p3. (p3 ==> p2) /\ p1 /\ p3 ==> p1 /\ p2``
  val blast_lemma = blastLib.BBLAST_PROVE
    ``(0x1w && w << 1) = 0x0w:word64``
  val blast_lemma2 = blastLib.BBLAST_PROVE
    ``(0x7w && 0x10000w * w + 0x1w)  0x0w:word64``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ GEN_TAC
    \\ FULL_SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.PAT_ABBREV_TAC `pat = if vals.reg0 && 0x1w = 0x0w
                               then ~vals.reg0 else yy`
    \\ Q.EXISTS_TAC `vals with reg15 := pat`
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_ignore_reg15,SEP_CLAUSES,zVALS_def]
    \\ STRIP_TAC \\ MATCH_MP_TAC lemma
    \\ Q.EXISTS_TAC `
        (if 0x1w && vals.reg0 = 0x0w then SOME (0x2w && ~vals.reg0 = 0x0w)
         else SOME (0x7w && vals.memory (vals.reg0 + 0x1w) = 0x0w)) =
        SOME (isBlock x1)`
    \\ CONJ_TAC THEN1 FULL_SIMP_TAC (std_ss++star_ss) []
    \\ UNABBREV_ALL_TAC
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,APPEND,abs_ml_inv_def,
         bc_stack_ref_inv_def,LIST_REL_def]
    \\ Q.PAT_ASSUM `bc_value_inv x1 (r1,f,heap)` ASSUME_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [canCompare_def,isBlock_def]
    THEN1 (Cases_on `small_int i`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      THEN1 blastLib.BBLAST_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `(0x1w && vs.current_heap + n2w ptr << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w ptr << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,DataOnly_def,x64_payload_def,LET_DEF,word_mul_n2w]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ Cases_on `i < 0:int` \\ ASM_SIMP_TAC std_ss [b2w_def]
      \\ blastLib.BBLAST_TAC)
    THEN1 (Cases_on `l = []`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      THEN1 blastLib.BBLAST_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `(0x1w && vs.current_heap + n2w ptr << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w ptr << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,BlockRep_def,x64_payload_def,LET_DEF,word_mul_n2w]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ blastLib.BBLAST_TAC)
    THEN1 (FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      \\ `(0x1w && vs.current_heap + n2w (f ' n) << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w (f ' n) << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `reachable_refs (RefPtr n::x2::x3::x4::stack) refs n` by ALL_TAC THEN1
       (SIMP_TAC std_ss [reachable_refs_def]
        \\ FULL_SIMP_TAC std_ss [MEM] \\ Q.EXISTS_TAC `RefPtr n`
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ RES_TAC
      \\ `FLOOKUP f n = SOME (f ' n)` by ( simp[FLOOKUP_DEF] )
      \\ `FLOOKUP refs n = SOME (refs ' n)` by ( fs[FLOOKUP_DEF,SUBSET_DEF] )
      \\ Cases_on`refs ' n` \\ FULL_SIMP_TAC (srw_ss()) [bc_ref_inv_def]
      THEN1 (
        IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,RefBlock_def,x64_payload_def,LET_DEF,word_mul_n2w]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ MATCH_ACCEPT_TAC blast_lemma2)
      THEN (
        IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,RefBlock_def,x64_payload_def,LET_DEF,word_mul_n2w,
           Bytes_def]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ simp[GSYM word_add_n2w,GSYM word_mul_n2w]
      \\ blastLib.BBLAST_TAC)))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * zPC p *
      cond (canCompare x1) * ~zS``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end


(* isNumber *)

val (x64_is_number_cert, x64_is_number_def) = x64_decompile_no_status "x64_is_number" `
  test r0, 1
  jne PTR
  test r0,3
  jmp EXIT
PTR:
  mov r15,[r0+1]
  test r15,4
  jne EXIT
  not r15
  test r15,2
EXIT: `;

val FST_SND_IF = prove(
  ``(FST (if b then x else y) = if b then FST x else FST y) 
    (SND (if b then x else y) = if b then SND x else SND y)``,
  rw[])

val zHEAP_isNumber = let
  val th =
    x64_is_number_cert
    |> SIMP_RULE std_ss [LET_DEF,x64_is_number_def]
    |> CONV_RULE (DEPTH_CONV PairRules.PBETA_CONV)
    |> SIMP_RULE std_ss [FST_SND_IF]
    |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
    |> UNDISCH
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``zPC p * ~zS * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            canCompare x1)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,
       refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (isNumber x1)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = METIS_PROVE []
    ``!p3. (p3 ==> p2) /\ p1 /\ p3 ==> p1 /\ p2``
  val blast_lemma = blastLib.BBLAST_PROVE
    ``(0x1w && w << 1) = 0x0w:word64``
  val blast_lemma2 = blastLib.BBLAST_PROVE
    ``((0x2w && ~w) <> 0x0w:word64) <=> ~(w ' 1)``
  val blast_lemma3 = blastLib.BBLAST_PROVE
    ``(0x2w && ~(0x10000w * w + 0x1w))  0x0w:word64``
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ GEN_TAC
    \\ FULL_SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.PAT_ABBREV_TAC `pat = if vals.reg0 && 0x1w = 0x0w
                               then vals.reg15 else yy`
    \\ Q.EXISTS_TAC `vals with reg15 := pat`
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_ignore_reg15,SEP_CLAUSES,zVALS_def]
    \\ STRIP_TAC \\ MATCH_MP_TAC lemma
    \\ Q.PAT_ABBREV_TAC `wit:bool option = if X then SOME y else Z`
    \\ Q.EXISTS_TAC `wit = SOME (isNumber x1)`
    \\ CONJ_TAC THEN1 FULL_SIMP_TAC (std_ss++star_ss) []
    \\ UNABBREV_ALL_TAC
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,APPEND,abs_ml_inv_def,
         bc_stack_ref_inv_def,LIST_REL_def]
    \\ Q.PAT_ASSUM `bc_value_inv x1 (r1,f,heap)` ASSUME_TAC
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [canCompare_def,isNumber_def]
    THEN1 (Cases_on `small_int i`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      THEN1 blastLib.BBLAST_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `(0x1w && vs.current_heap + n2w ptr << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w ptr << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,DataOnly_def,x64_payload_def,LET_DEF,word_mul_n2w]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ Cases_on `i < 0:int` \\ ASM_SIMP_TAC std_ss [b2w_def]
      \\ blastLib.BBLAST_TAC)
    THEN1 (Cases_on `l = []`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      THEN1 blastLib.BBLAST_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `(0x1w && vs.current_heap + n2w ptr << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w ptr << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,BlockRep_def,x64_payload_def,LET_DEF,word_mul_n2w]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w]
      \\ SIMP_TAC std_ss [blast_lemma2] \\ blastLib.BBLAST_TAC)
    THEN1 (FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def,blast_lemma]
      \\ `(0x1w && vs.current_heap + n2w (f ' n) << 3 - 0x1w) <> 0x0w /\
          (0x7w && vs.current_heap + n2w (f ' n) << 3 = 0x0w)` by ALL_TAC THEN1
       (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
        \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
        \\ blastLib.BBLAST_TAC)
      \\ FULL_SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ `reachable_refs (RefPtr n::x2::x3::x4::stack) refs n` by ALL_TAC THEN1
       (SIMP_TAC std_ss [reachable_refs_def]
        \\ FULL_SIMP_TAC std_ss [MEM] \\ Q.EXISTS_TAC `RefPtr n`
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ RES_TAC
      \\ `FLOOKUP f n = SOME (f ' n)` by ( simp[FLOOKUP_DEF] )
      \\ `FLOOKUP refs n = SOME (refs ' n)` by ( fs[FLOOKUP_DEF,SUBSET_DEF] )
      \\ Cases_on`refs ' n` \\ FULL_SIMP_TAC (srw_ss()) [bc_ref_inv_def]
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,WORD_MUL_LSL,
           x64_el_def,RefBlock_def,x64_payload_def,LET_DEF,word_mul_n2w,Bytes_def]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
      \\ rw[] \\ ((MATCH_ACCEPT_TAC blast_lemma3) ORELSE
        (qsuff_tac`F`>-rw[]>>
         pop_assum mp_tac >>
         blastLib.BBLAST_TAC))))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * zPC p *
      cond (canCompare x1) * ~zS``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end


(* isSmall *)

val isSmall_def = Define `
  (isSmall (Number i) = small_int i) /\
  (isSmall (Block tag l) = (l = [])) /\
  (isSmall _ = F)`;

fun zHEAP_isSmall i = let
  val rn = "r" ^ ((i - 1) |> int_to_string)
  val n = i |> numSyntax.term_of_int
  val th = spec ("test "^rn^",1")
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val x = ``if ^n = 1 then x1 else
            if ^n = 2 then (x2:bc_value) else
            if ^n = 3 then x3 else
            if ^n = 4 then x4 else ARB``
  val pre = ``canCompare ^x``
  val target = ``zPC p * ~zS * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,
       refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (isSmall ^x)) *
      ~zS1 Z_PF * ^pc`
  val reg = ``if ^n = 1 then vals.reg0 else
              if ^n = 2 then vals.reg1 else
              if ^n = 3 then vals.reg2 else
              if ^n = 4 then vals.reg3 else ARB``
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ GEN_TAC
    \\ FULL_SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_CLAUSES,zVALS_def]
    \\ REPEAT STRIP_TAC
    \\ `isSmall ^x = (0x1w && ^reg = 0x0w)` by ALL_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM (K ALL_TAC)
    \\ Cases_on `^x` \\ FULL_SIMP_TAC (srw_ss()) [canCompare_def,isSmall_def]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,
         bc_stack_ref_inv_def,APPEND,LIST_REL_def]
    THEN1 (Cases_on `small_int i`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
      THEN1 blastLib.BBLAST_TAC
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
      \\ blastLib.BBLAST_TAC)
    THEN1 (Cases_on `l = []`
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
      THEN1 blastLib.BBLAST_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD]
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
      \\ blastLib.BBLAST_TAC)
    THEN1 (FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,WORD_MUL_LSL]
      \\ blastLib.BBLAST_TAC))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * zPC p *
      cond (^pre) * ~zS``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end

val _ = map zHEAP_isSmall [1,2,3,4];


(* explode single Block *)

val (res,push_els_loop_def,push_els_loop_pre_def) = x64_compile `
  push_els_loop (x1,x2,x3,x4:bc_value,stack) =
    if getNumber x2 = 0 then (x1,x2,x3,x4,stack) else
      let x2 = Number (getNumber x2 - 1) in
      let x1 = x3 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let stack = x1::stack in
      let x1 = Number 1 in
      let stack = x1::stack in
        push_els_loop (x1,x2,x3,x4,stack)`

val (push_els_cert,push_els_def,push_els_pre_def) = x64_compile `
  push_els (x1:bc_value,x4,stack) =
    let x3 = x1 in
    let x1 = Number (&LENGTH (getContent x1)) in
    let x2 = x1 in
    let (x1,x2,x3,x4,stack) = push_els_loop (x1,x2,x3,x4,stack) in
    let x1 = x2 in
      (x1,x2,x3,x4,stack)`

val TAKE_SUC = prove(
  ``!k l.
      k + 1 <= LENGTH l ==>
      (TAKE (k + 1) l = TAKE k l ++ [EL k l])``,
  Induct THEN1 (Cases_on `l` \\ EVAL_TAC) \\ Cases_on `l`
  THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [ADD1])
  \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1]
  \\ FULL_SIMP_TAC std_ss [GSYM ADD1,rich_listTheory.TAKE,APPEND,CONS_11,EL,HD,TL]);

val push_els_loop_thm = prove(
  ``!k stack x1.
      k <= LENGTH l /\ small_int (& k) ==>
      ?x1i. push_els_loop_pre (x1,Number (& k),Block tag l,x4,stack) /\
           (push_els_loop (x1,Number (& k),Block tag l,x4,stack) =
             (x1i,Number 0, Block tag l,x4,
              FLAT (MAP (\x. [Number 1; x]) (TAKE k l)) ++ stack))``,
  Induct \\ SIMP_TAC std_ss [TAKE_0,MAP,FLAT,APPEND]
  \\ ONCE_REWRITE_TAC [push_els_loop_def,push_els_loop_pre_def]
  \\ FULL_SIMP_TAC std_ss [getNumber_def,isNumber_def,LET_DEF]
  \\ FULL_SIMP_TAC std_ss [integerTheory.INT_EQ_CALCULATE,ADD1,EVAL ``0<0:int``]
  \\ REPEAT STRIP_TAC
  \\ `(&(k + 1) - 1 = & k) /\ 0 <= &k /\ k <= LENGTH l /\
      small_int (&k) /\ k < LENGTH l /\ ~(&(k + 1) < 0:int) /\
      &k < &LENGTH l /\ (Num (& k) = k)` by ALL_TAC THEN1
    (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
  \\ FULL_SIMP_TAC std_ss [getContent_def,isBlock_def]
  \\ IMP_RES_TAC TAKE_SUC
  \\ FULL_SIMP_TAC std_ss [MAP_APPEND,FLAT_APPEND,MAP,FLAT,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]);

val push_els_thm = prove(
  ``isBlock x1 /\ small_int (& (LENGTH (getContent x1))) ==>
    push_els_pre (x1,x4,stack) /\
    (push_els (x1,x4,stack) =
       (Number 0,Number 0,x1,x4,
        FLAT (MAP (\x. [Number 1; x]) (getContent x1)) ++ stack))``,
  Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isBlock_def,getContent_def]
  \\ FULL_SIMP_TAC std_ss [push_els_def,push_els_pre_def,LET_DEF,
       isBlock_def,getContent_def]
  \\ REPEAT STRIP_TAC
  \\ ASSUME_TAC (GEN_ALL push_els_loop_thm)
  \\ SEP_I_TAC "push_els_loop"
  \\ POP_ASSUM MP_TAC
  \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [TAKE_LENGTH_ID]);

val Block_size_small_int = prove(
  ``!x1. isBlock x1 /\ heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals ==>
         small_int (&LENGTH (getContent x1)) /\ small_int (& (getTag x1))``,
  Cases \\ SIMP_TAC std_ss [isBlock_def,getContent_def,getTag_def]
  \\ SIMP_TAC std_ss [heap_inv_def] \\ STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,APPEND,
       LIST_REL_def,bc_value_inv_def]
  \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss [LENGTH]
  THEN1 (ASM_SIMP_TAC (srw_ss()) [small_int_def] \\ DECIDE_TAC)
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [BlockRep_def,x64_heap_APPEND,
       x64_el_def,x64_payload_def,LET_DEF,cond_STAR,x64_heap_def]
  \\ IMP_RES_TAC EVERY2_IMP_LENGTH
  \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC std_ss [small_int_def]
  \\ STRIP_TAC THEN1 intLib.COOPER_TAC
  \\ ASM_SIMP_TAC (srw_ss()) [small_int_def]
  \\ DECIDE_TAC);

val zHEAP_EXPLODE_BLOCK = let
  val tm = push_els_thm |> concl |> dest_imp |> fst
  val th = DISCH tm push_els_cert
           |> SIMP_RULE std_ss [push_els_thm,LET_DEF,SEP_CLAUSES]
           |> SIMP_RULE std_ss [GSYM SPEC_MOVE_COND]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      cond (isBlock x1))``
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_IMP_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,cond_STAR,SEP_CLAUSES,
         SEP_EXISTS_THM,STAR_ASSOC] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC Block_size_small_int \\ ASM_SIMP_TAC std_ss [])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;


(* explode single Block in REVERSE *)

val (res,push_els2_loop_def,push_els2_loop_pre_def) = x64_compile `
  push_els2_loop (x1,x2,x3,x4:bc_value,stack) =
    if getNumber x2 = 0 then (x1,x2,x3,x4,stack) else
      let x2 = Number (getNumber x2 - 1) in
      let x1 = x3 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let stack = x1::stack in
        push_els2_loop (x1,x2,x3,x4,stack)`

val (push_els2_cert,push_els2_def,push_els2_pre_def) = x64_compile `
  push_els2 (x1:bc_value,x4,stack) =
    let x3 = x1 in
    let x1 = Number (&LENGTH (getContent x1)) in
    let x2 = x1 in
    let (x1,x2,x3,x4,stack) = push_els2_loop (x1,x2,x3,x4,stack) in
    let x1 = x2 in
      (x1,x2,x3,x4,stack)`

val TAKE_SUC = prove(
  ``!k l.
      k + 1 <= LENGTH l ==>
      (TAKE (k + 1) l = TAKE k l ++ [EL k l])``,
  Induct THEN1 (Cases_on `l` \\ EVAL_TAC) \\ Cases_on `l`
  THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [ADD1])
  \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1]
  \\ FULL_SIMP_TAC std_ss [GSYM ADD1,rich_listTheory.TAKE,APPEND,CONS_11,EL,HD,TL]);

val push_els2_loop_thm = prove(
  ``!k stack x1.
      k <= LENGTH l /\ small_int (& k) ==>
      ?x1i. push_els2_loop_pre (x1,Number (& k),Block tag l,x4,stack) /\
           (push_els2_loop (x1,Number (& k),Block tag l,x4,stack) =
             (x1i,Number 0, Block tag l,x4,TAKE k l ++ stack))``,
  Induct \\ SIMP_TAC std_ss [TAKE_0,MAP,FLAT,APPEND]
  \\ ONCE_REWRITE_TAC [push_els2_loop_def,push_els2_loop_pre_def]
  \\ FULL_SIMP_TAC std_ss [getNumber_def,isNumber_def,LET_DEF]
  \\ FULL_SIMP_TAC std_ss [integerTheory.INT_EQ_CALCULATE,ADD1,EVAL ``0<0:int``]
  \\ REPEAT STRIP_TAC
  \\ `(&(k + 1) - 1 = & k) /\ 0 <= &k /\ k <= LENGTH l /\
      small_int (&k) /\ k < LENGTH l /\ ~(&(k + 1) < 0:int) /\
      &k < &LENGTH l /\ (Num (& k) = k)` by ALL_TAC THEN1
    (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
  \\ FULL_SIMP_TAC std_ss [getContent_def,isBlock_def]
  \\ IMP_RES_TAC TAKE_SUC
  \\ FULL_SIMP_TAC std_ss [MAP_APPEND,FLAT_APPEND,MAP,FLAT,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]);

val push_els2_thm = prove(
  ``isBlock x1 /\ small_int (& (LENGTH (getContent x1))) ==>
    push_els2_pre (x1,x4,stack) /\
    (push_els2 (x1,x4,stack) =
       (Number 0,Number 0,x1,x4,getContent x1 ++ stack))``,
  Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isBlock_def,getContent_def]
  \\ FULL_SIMP_TAC std_ss [push_els2_def,push_els2_pre_def,LET_DEF,
       isBlock_def,getContent_def]
  \\ REPEAT STRIP_TAC
  \\ ASSUME_TAC (GEN_ALL push_els2_loop_thm)
  \\ SEP_I_TAC "push_els2_loop"
  \\ POP_ASSUM MP_TAC
  \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [TAKE_LENGTH_ID]);

val zHEAP_EXPLODE_BLOCK_SIMPLE = let
  val tm = push_els2_thm |> concl |> dest_imp |> fst
  val th = DISCH tm push_els2_cert
           |> SIMP_RULE std_ss [push_els2_thm,LET_DEF,SEP_CLAUSES]
           |> SIMP_RULE std_ss [GSYM SPEC_MOVE_COND]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      cond (isBlock x1))``
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_IMP_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,cond_STAR,SEP_CLAUSES,
         SEP_EXISTS_THM,STAR_ASSOC] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC Block_size_small_int \\ ASM_SIMP_TAC std_ss [])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;

(* explode two Blocks *)

val (_,push_els2_loop_def,push_els2_loop_pre_def) = x64_compile `
  push_els2_loop (x1,x2,x3,x4:bc_value,stack) =
    if getNumber x2 = 0 then (x1,x2,x3,x4,stack) else
      let x2 = Number (getNumber x2 - 1) in
      let x1 = x3 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let stack = x1::stack in
      let x1 = x4 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let stack = x1::stack in
      let x1 = Number 1 in
      let stack = x1::stack in
        push_els2_loop (x1,x2,x3,x4,stack)`

val (push_els2_cert,push_els2_def,push_els2_pre_def) = x64_compile `
  push_els2 (x1:bc_value,x4,stack) =
    let x3 = x1 in
    let x1 = Number (&LENGTH (getContent x1)) in
    let x2 = x1 in
    let (x1,x2,x3,x4,stack) = push_els2_loop (x1,x2,x3,x4,stack) in
    let x1 = x2 in
      (x1,x2,x3,x4,stack)`

val TAKE_SUC2 = prove(
  ``!k l.
      k + 1 <= LENGTH l /\ (LENGTH l2 = LENGTH l) ==>
      (TAKE (k + 1) (ZIP (l,l2)) = TAKE k (ZIP (l,l2)) ++ [(EL k l,EL k l2)])``,
  REPEAT STRIP_TAC
  \\ `k + 1 <= LENGTH (ZIP(l,l2))` by METIS_TAC [LENGTH_ZIP]
  \\ IMP_RES_TAC TAKE_SUC
  \\ FULL_SIMP_TAC std_ss [] \\ AP_TERM_TAC
  \\ `k < LENGTH l` by DECIDE_TAC
  \\ SIMP_TAC std_ss [CONS_11]
  \\ MATCH_MP_TAC EL_ZIP
  \\ FULL_SIMP_TAC std_ss []);

val push_els2_loop_thm = prove(
  ``!k stack x1.
      k <= LENGTH l1 /\ small_int (& k) /\ (LENGTH l2 = LENGTH l1) ==>
      ?x1i. push_els2_loop_pre (x1,Number (& k),Block tag1 l1,Block tag2 l2,stack) /\
           (push_els2_loop (x1,Number (& k),Block tag1 l1,Block tag2 l2,stack) =
             (x1i,Number 0, Block tag1 l1,Block tag2 l2,
              FLAT (MAP (\(x,y). [Number 1; y; x])
                (TAKE k (ZIP(l1,l2)))) ++ stack))``,
  Induct \\ SIMP_TAC std_ss [TAKE_0,MAP,FLAT,APPEND]
  \\ ONCE_REWRITE_TAC [push_els2_loop_def,push_els2_loop_pre_def]
  \\ FULL_SIMP_TAC std_ss [getNumber_def,isNumber_def,LET_DEF]
  \\ FULL_SIMP_TAC std_ss [integerTheory.INT_EQ_CALCULATE,ADD1,EVAL ``0<0:int``]
  \\ REPEAT STRIP_TAC
  \\ `(&(k + 1) - 1 = & k) /\ 0 <= &k /\ k <= LENGTH l1 /\
      small_int (&k) /\ k < LENGTH l1 /\ ~(&(k + 1) < 0:int) /\
      &k < &LENGTH l1 /\ (Num (& k) = k)` by ALL_TAC THEN1
    (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
  \\ FULL_SIMP_TAC std_ss [getContent_def,isBlock_def]
  \\ `k + 1 <= LENGTH (ZIP(l1,l2))` by METIS_TAC [LENGTH_ZIP]
  \\ IMP_RES_TAC TAKE_SUC2
  \\ FULL_SIMP_TAC std_ss [MAP_APPEND,FLAT_APPEND,MAP,FLAT,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]);

val explode_result_def = Define `
  explode_result (x1,x4,stack) =
    (Number 0,Number 0,x1,x4,
        FLAT (MAP (\(x,y). [Number 1; y; x])
                ((ZIP(getContent x1,getContent x4)))) ++ stack)`;

val push_els2_thm = prove(
  ``isBlock x1 /\ isBlock x4 /\ small_int (& (LENGTH (getContent x1))) /\
    (LENGTH (getContent x1) = LENGTH (getContent x4)) ==>
    push_els2_pre (x1,x4,stack) /\
    (push_els2 (x1,x4,stack) = explode_result (x1,x4,stack))``,
  Cases_on `x1` \\ Cases_on `x4`
  \\ FULL_SIMP_TAC std_ss [isBlock_def,getContent_def,explode_result_def]
  \\ FULL_SIMP_TAC std_ss [push_els2_def,push_els2_pre_def,LET_DEF,
       isBlock_def,getContent_def]
  \\ REPEAT STRIP_TAC
  \\ ASSUME_TAC (GEN_ALL push_els2_loop_thm)
  \\ SEP_I_TAC "push_els2_loop"
  \\ POP_ASSUM MP_TAC
  \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC
  \\ `LENGTH l' = LENGTH (ZIP (l,l'))` by METIS_TAC [LENGTH_ZIP]
  \\ FULL_SIMP_TAC std_ss [TAKE_LENGTH_ID]);

val zHEAP_EXPLODE_TWO_BLOCKS = let
  val tm = push_els2_thm |> concl |> dest_imp |> fst
  val th = DISCH tm push_els2_cert
           |> SIMP_RULE std_ss [push_els2_thm,SEP_CLAUSES]
           |> SIMP_RULE std_ss [GSYM SPEC_MOVE_COND]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      cond (isBlock x1 /\ isBlock x4 /\
            (LENGTH (getContent x1) = LENGTH (getContent x4))))``
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_IMP_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,cond_STAR,SEP_CLAUSES,
         SEP_EXISTS_THM,STAR_ASSOC] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC Block_size_small_int \\ METIS_TAC [])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;


(* RefPtr equality *)

val RefPtrEq_def = Define `
  RefPtrEq x (y:bc_value) = (x = y)`;

val heap_lookup_IMP_heap_length = prove(
  ``(heap_lookup n heap = SOME x) ==>
    n <= heap_length heap``,
  REPEAT STRIP_TAC \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC std_ss [heap_lookup_def,heap_length_APPEND]
  \\ DECIDE_TAC);

val zHEAP_RefPtrEq = let
  val th = spec "cmp r0,r1"
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val th = th |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``zPC p * ~zS * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isRefPtr x1 /\ isRefPtr x2)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,
       refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (RefPtrEq x1 x2)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isRefPtr_def]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isRefPtr_def]
    \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ GEN_TAC
    \\ FULL_SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_CLAUSES,zVALS_def,RefPtrEq_def]
    \\ REPEAT STRIP_TAC
    \\ `(n = n') = (vals.reg0 = vals.reg1)` by ALL_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,
         bc_stack_ref_inv_def,APPEND,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
    \\ FULL_SIMP_TAC std_ss [WORD_EQ_ADD_CANCEL,word_sub_def]
    \\ FULL_SIMP_TAC std_ss [INJ_DEF]
    \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE (`f ' n = f ' n'` by ALL_TAC) THEN1 RES_TAC
    \\ `reachable_refs (RefPtr n::RefPtr n'::x3::x4::stack) refs n`  by
     (SIMP_TAC std_ss [reachable_refs_def] \\ Q.EXISTS_TAC `RefPtr n`
      \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
    \\ `reachable_refs (RefPtr n::RefPtr n'::x3::x4::stack) refs n'`  by
     (SIMP_TAC std_ss [reachable_refs_def] \\ Q.EXISTS_TAC `RefPtr n'`
      \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
    \\ RES_TAC \\ FULL_SIMP_TAC std_ss [bc_ref_inv_def,heap_ok_def,
         WORD_MUL_LSL,word_mul_n2w,n2w_11]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ `f ' n <= cs.heap_limit /\
        f ' n' <= cs.heap_limit` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [isSomeDataElement_def]
      \\ IMP_RES_TAC heap_lookup_IMP_heap_length \\ DECIDE_TAC)
    \\ `(8 * f ' n) < 18446744073709551616` by DECIDE_TAC
    \\ `(8 * f ' n') < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * zPC p *
      cond (isRefPtr x1 /\ isRefPtr x2) * ~zS``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  val _ = add_compiled [th];
  in th end


(* block length comparison *)

val (get_lengths_cert,get_lengths_def,get_lengths_pre_def) = x64_compile `
  get_lengths (x1,x2) =
    let x1 = Number (&LENGTH (getContent x1)) in
    let (x1,x2) = (x2,x1) in
    let x1 = Number (&LENGTH (getContent x1)) in
      (x1,x2)`

val zHEAP_LENGTH_COMPARE = let
  val th = get_lengths_cert
    |> SIMP_RULE std_ss [get_lengths_def,get_lengths_pre_def,LET_DEF]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_CMP_SMALL_INT_12]
  val th = th |> SIMP_RULE std_ss [isNumber_def,getNumber_def,
                   integerTheory.INT_EQ_CALCULATE,Once EQ_SYM_EQ]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      cond (isBlock x1 /\ isBlock x2))``
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_IMP_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,cond_STAR,SEP_CLAUSES,
         SEP_EXISTS_THM,STAR_ASSOC] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC Block_size_small_int \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC (srw_ss()) [])
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_PUSH2,th,zHEAP_POP2,zHEAP_POP1]
  val th = th |> SIMP_RULE std_ss [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
  val _ = add_compiled [th];
  in th end;


(* block tag comparison *)

val (get_tags_cert,get_tags_def,get_tags_pre_def) = x64_compile `
  get_lengths (x1,x2) =
    let x1 = Number (& (getTag x1)) in
    let (x1,x2) = (x2,x1) in
    let x1 = Number (& (getTag x1)) in
      (x1,x2)`

val zHEAP_TAG_COMPARE = let
  val th = get_tags_cert
    |> SIMP_RULE std_ss [get_tags_def,get_tags_pre_def,LET_DEF]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_CMP_SMALL_INT_12]
  val th = th |> SIMP_RULE std_ss [isNumber_def,getNumber_def,
                   integerTheory.INT_EQ_CALCULATE,Once EQ_SYM_EQ]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      cond (isBlock x1 /\ isBlock x2))``
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_IMP_def,cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,cond_STAR,SEP_CLAUSES,
         SEP_EXISTS_THM,STAR_ASSOC] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC Block_size_small_int \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC (srw_ss()) [])
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_PUSH2,th,zHEAP_POP2,zHEAP_POP1]
  val th = th |> SIMP_RULE std_ss [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
  val _ = add_compiled [th];
  in th end;


(* number equality *)

val (_,array_eq_def,array_eq_pre_def) = x64_compile `
  array_eq (r0:word64,r14:word64,r15:word64,dm:word64 set,m:word64->word64) =
    if r0 = 0w then let r0 = 4w:word64 in (r0,r14,r15,dm,m) else
      let r12 = m r14 in
      let r13 = m r15 in
        if r12 <> r13 then
          let r0 = 0w in (r0,r14,r15,dm,m)
        else
          let r0 = r0 - 1w in
          let r14 = r14 + 8w in
          let r15 = r15 + 8w in
            array_eq (r0,r14,r15,dm,m)`

val (num_eq_cert,num_eq_def,num_eq_pre_def) = x64_compile `
  num_eq (r0:word64,r1,r12:word64,r13,dm:word64 set,m:word64->word64,ss) =
    let r14 = r0 + 1w in
    let r15 = r1 + 1w in
    let ss = r12::ss in
    let ss = r13::ss in
    let r12 = m r14 in
    let r13 = m r15 in
      if r12 <> r13 then
        let (r13,ss) = (HD ss, TL ss) in
        let (r12,ss) = (HD ss, TL ss) in
        let r0 = 0w in
          (r0,r1,r12,r13,dm,m,ss)
      else
        let r0 = r12 >>> 16 in
        let r14 = r14 + 8w in
        let r15 = r15 + 8w in
        let (r0,r14,r15,dm,m) = array_eq (r0,r14,r15,dm,m) in
        let (r13,ss) = (HD ss, TL ss) in
        let (r12,ss) = (HD ss, TL ss) in
          (r0,r1,r12,r13,dm,m,ss)`

val array_eq_thm = prove(
  ``!xs ys a b p1 p2.
      (LENGTH ys = LENGTH xs) /\ LENGTH xs < dimword(:64) /\
      (a && 0x7w = 0x0w) /\ (b && 0x7w = 0x0w) /\
      (one_list a xs * p1) (fun2set (m,dm)) /\
      (one_list b ys * p2) (fun2set (m,dm)) ==>
      ?r14' r15'.
        array_eq_pre (n2w (LENGTH xs), a, b, dm, m) /\
        (array_eq (n2w (LENGTH xs), a, b, dm, m) =
          (if xs = ys then 4w else 0w, r14', r15', dm, m))``,
  Induct \\ Cases_on `ys` \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1]
  \\ ONCE_REWRITE_TAC [array_eq_def,array_eq_pre_def]
  \\ SIMP_TAC std_ss [CONS_11,n2w_11,ZERO_LT_dimword,LET_DEF,one_list_def]
  \\ REPEAT STRIP_TAC
  \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `h' = h` \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC std_ss [GSYM word_add_n2w,WORD_ADD_SUB]
  \\ SEP_I_TAC "array_eq"
  \\ `LENGTH xs < dimword (:64)` by DECIDE_TAC
  \\ SEP_F_TAC \\ REPEAT STRIP_TAC
  \\ SEP_F_TAC \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [blast_align_lemma]);

val heap_lookup_DataOnly_IMP = prove(
  ``(x64_heap vs.current_heap heap vs.current_heap vs.current_heap *
        one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs)
         (fun2set (vals.memory,vals.memory_domain)) /\
    (heap_lookup ptr heap = SOME (DataOnly x y)) ==>
    ?pp t1 t2. (x64_el (vs.current_heap + n2w (8 * ptr)) (DataOnly x y) t1 t2 * pp)
         (fun2set (vals.memory,vals.memory_domain))``,
  REPEAT STRIP_TAC \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,SEP_CLAUSES]
  \\ METIS_TAC [STAR_COMM,STAR_ASSOC]);

val SHIFT_LEMMA = prove(
  ``(y << 16 + 0x2w + b2w b1 = x << 16 + 0x2w + b2w b2) /\
    x <+ n2w (2**48) /\ y <+ n2w (2**48) ==>
    (x = y:word64) /\ (b1 = b2)``,
  Cases_on `b1` \\ Cases_on `b2` \\ FULL_SIMP_TAC std_ss [b2w_def]
  \\ blastLib.BBLAST_TAC) |> SIMP_RULE std_ss [];

val SHIFT_SHIFT_LEMMA = prove(
  ``w <+ n2w (2**48) ==> (((w:word64) << 16 + 0x2w + b2w b) >>> 16 = w)``,
  Cases_on `b` \\ FULL_SIMP_TAC std_ss [b2w_def] \\ blastLib.BBLAST_TAC)
  |> SIMP_RULE std_ss [];

val mw_thm = prove(
  ``mw = n2mw``,
  SIMP_TAC std_ss [FUN_EQ_THM] \\ HO_MATCH_MP_TAC mw_ind
  \\ REPEAT STRIP_TAC \\ ONCE_REWRITE_TAC [mw_def,multiwordTheory.n2mw_def]
  \\ SRW_TAC [] []);

val zHEAP_BigNumEq = let
  val th = num_eq_cert
  val pc = get_pc th
  val side = ``isNumber x1 /\ ~isSmall x1 /\ isNumber x2 /\ ~isSmall x2``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ^side)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,Number (if getNumber x2 = getNumber x1 then 1 else 0),
               x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ `?r0 r1 r12 r13 dm m ss.
          num_eq
            (vals.reg0,vals.reg1,vals.reg12,vals.reg13,
             vals.memory_domain,vals.memory,vals.stack) =
          (r0,r1,r12,r13,dm,m,ss)` by METIS_TAC [PAIR]
    \\ FULL_SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL] \\ NTAC 4 STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| reg0 := r0 ; reg1 := r1 ;
         reg12 := r12 ; reg13 := r13 ; reg14 := x' ; reg15 := x ;
         memory := m ; memory_domain := dm ; stack := ss |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ SIMP_TAC (srw_ss()++star_ss) [zVALS_def]
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b1 /\ b3 ==> (b1 /\ (b2 ==> b3))``)
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isNumber_def]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def]
    \\ FULL_SIMP_TAC std_ss [getNumber_def,isSmall_def]
    \\ Q.PAT_ASSUM `xx = yy` (MP_TAC o GSYM)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`Data (if i = i' then 2w else 0w)`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss []
    \\ `abs_ml_inv (Number (if i' = i then 1 else 0)::Number i'::x3::x4::stack)
         refs (Data (if i = i' then 0x2w else 0x0w)::r2::r3::r4::roots,heap,a,sp)
          cs.heap_limit` by ALL_TAC THEN1
     (Cases_on `i' = i` \\ FULL_SIMP_TAC std_ss []
      \\ TRY (MATCH_MP_TAC (abs_ml_inv_Num |> SPEC_ALL |> Q.INST [`n`|->`1`]
                      |> SIMP_RULE std_ss [word_mul_n2w] |> GEN_ALL))
      \\ TRY (MATCH_MP_TAC (abs_ml_inv_Num |> SPEC_ALL |> Q.INST [`n`|->`0`]
                      |> SIMP_RULE std_ss [word_mul_n2w] |> GEN_ALL))
      \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def]
    \\ IMP_RES_TAC heap_lookup_DataOnly_IMP \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ FULL_SIMP_TAC std_ss [DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,x64_addr_def]
    \\ SIMP_TAC std_ss [WORD_MUL_LSL,word_mul_n2w]
    \\ SIMP_TAC std_ss [num_eq_pre_def,num_eq_def,LET_DEF]
    \\ SIMP_TAC std_ss [HD,TL,NOT_CONS_NIL,WORD_SUB_ADD]
    \\ Cases_on `vals.memory (vs.current_heap + n2w (8 * ptr)) <>
                 vals.memory (vs.current_heap + n2w (8 * ptr'))`
    \\ FULL_SIMP_TAC std_ss [] THEN1
     (SEP_R_TAC \\ SIMP_TAC std_ss [blast_align_lemma,GSYM word_mul_n2w]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ REPEAT STRIP_TAC
      \\ SRW_TAC [] [])
    \\ SEP_R_TAC \\ SIMP_TAC std_ss [blast_align_lemma,GSYM word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def]
    \\ Q.ABBREV_TAC `i1 = mw (Num (ABS i)):word64 list`
    \\ Q.ABBREV_TAC `i2 = mw (Num (ABS i')):word64 list`
    \\ `n2w (LENGTH i1) <+ 0x1000000000000w:word64 /\
        n2w (LENGTH i2) <+ 0x1000000000000w:word64` by
     (`LENGTH i1 < 18446744073709551616` by DECIDE_TAC
      \\ `LENGTH i2 < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO])
    \\ `(LENGTH i1 = LENGTH i2) /\ ((i' < 0) = (i < 0))` by ALL_TAC THEN1
     (IMP_RES_TAC SHIFT_LEMMA \\ REPEAT (Q.PAT_ASSUM `!xx.bb` (K ALL_TAC))
      \\ `LENGTH i1 < 18446744073709551616` by DECIDE_TAC
      \\ `LENGTH i2 < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO])
    \\ FULL_SIMP_TAC std_ss []
    \\ `(n2w (LENGTH i2) << 16 + 0x2w + b2w (i < 0)) >>> 16 =
        n2w (LENGTH i2):word64` by ALL_TAC THEN1
     (MATCH_MP_TAC SHIFT_SHIFT_LEMMA
      \\ `LENGTH i2 < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO])
    \\ FULL_SIMP_TAC std_ss []
    \\ ASSUME_TAC (array_eq_thm |> GEN_ALL)
    \\ Q.PAT_ASSUM `LENGTH i1 = LENGTH i2` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss []
    \\ SEP_I_TAC "array_eq"
    \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `i2:word64 list`)
    \\ POP_ASSUM (MP_TAC o Q.SPECL [
         `one (vs.current_heap + n2w (8 * ptr),
            n2w (LENGTH (i1:word64 list)) << 16 + 0x2w + b2w (i < 0)) * pp'`,
         `one (vs.current_heap + n2w (8 * ptr'),
            n2w (LENGTH (i2:word64 list)) << 16 + 0x2w + b2w (i < 0)) * pp`])
    \\ MATCH_MP_TAC IMP_IMP \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (std_ss++star_ss) [blast_align_lemma,GSYM word_mul_n2w,
        AC WORD_ADD_COMM WORD_ADD_ASSOC]
      \\ SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss [] \\ REPEAT STRIP_TAC
    \\ UNABBREV_ALL_TAC
    \\ FULL_SIMP_TAC std_ss [mw_thm,multiwordTheory.n2mw_11]
    \\ `(Num (ABS i) = Num (ABS i')) = (i = i')` by intLib.COOPER_TAC
    \\ ASM_SIMP_TAC std_ss [] \\ SRW_TAC [] [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^side)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  val _ = add_compiled [th];
  in th end;


(* recursive equality *)

val (pop_all_cert,pop_all_def,pop_all_pre_def) = x64_compile `
  pop_all (stack:bc_value list) =
    let (x2,stack) = (HD stack, TL stack) in
      if getNumber x2 = 0 then
        (x2,stack)
      else
        let (x2,stack) = (HD stack, TL stack) in
        let (x2,stack) = (HD stack, TL stack) in
          pop_all stack`

val closure_tag = rhs(concl(EVAL``&closure_tag``))

val (_,equal_loop_def,equal_loop_pre_def) = x64_compile `
  equal_loop (x1:bc_value,x2,x3,x4,stack:bc_value list) =
    let (x1,stack) = (HD stack, TL stack) in
      if getNumber x1 = 0 then
        let x1 = bool_to_val T in
          (x1,x2,x3,x4,stack)
      else
        let (x2,stack) = (HD stack, TL stack) in
        let (x1,stack) = (HD stack, TL stack) in
          if isNumber x1 then (* number case *)
            let (x1,x2) = (x2,x1) in
            if ~(isNumber x1) then
              let x1 = bool_to_val F in
              let (x2,stack) = pop_all stack in
                (x1,x2,x3,x4,stack)
            else
              if isSmall x1 then
                if getNumber x1 = getNumber x2 then
                  equal_loop (x1,x2,x3,x4,stack)
                else
                  let x1 = bool_to_val F in
                  let (x2,stack) = pop_all stack in
                    (x1,x2,x3,x4,stack)
              else
              let (x1,x2) = (x2,x1) in
              if isSmall x1 then
                let x1 = bool_to_val F in
                let (x2,stack) = pop_all stack in
                  (x1,x2,x3,x4,stack)
              else
                let x1 = Number (if getNumber x2 = getNumber x1 then 1 else 0) in
                  if getNumber x1 = 0 then
                    let x1 = bool_to_val F in
                    let (x2,stack) = pop_all stack in
                      (x1,x2,x3,x4,stack)
                  else
                    equal_loop (x1,x2,x3,x4,stack)
          else if isBlock x1 then (* block case *)
            let (x1,x2) = (x2,x1) in
            if ~isBlock x1 then
              let x1 = bool_to_val F in
              let (x2,stack) = pop_all stack in
                (x1,x2,x3,x4,stack)
             else (* both are blocks *)
               if getTag x1 = getTag x2 then
                 let x3 = x1 in
                 let x1 = Number (& (getTag x1)) in
                 if getNumber x1 = ^closure_tag then
                   let x1 = Number 0 in
                   let (x2,stack) = pop_all stack in
                     (x1,x2,x3,x4,stack)
                 else
                   let x1 = x3 in
                     if LENGTH (getContent x1) = LENGTH (getContent x2) then
                       let x4 = x2 in
                       let (x1,x4) = (x4,x1) in
                       let (x1,x2,x3,x4,stack) = explode_result (x1,x4,stack) in
                         equal_loop (x1,x2,x3,x4,stack)
                     else
                       let x1 = bool_to_val F in
                       let (x2,stack) = pop_all stack in
                         (x1,x2,x3,x4,stack)
               else
                 let x1 = Number (& (getTag x1)) in
                 if getNumber x1 = ^closure_tag then
                   let x1 = Number 0 in
                   let (x2,stack) = pop_all stack in
                     (x1,x2,x3,x4,stack)
                 else
                   let x1 = x2 in
                   let x1 = Number (& (getTag x1)) in
                   if getNumber x1 = ^closure_tag then
                     let x1 = Number 0 in
                     let (x2,stack) = pop_all stack in
                       (x1,x2,x3,x4,stack)
                   else
                     let x1 = bool_to_val F in
                     let (x2,stack) = pop_all stack in
                       (x1,x2,x3,x4,stack)
          else (* ref case *)
            let (x1,x2) = (x2,x1) in
            if isNumber x1 \/ isBlock x1 then
              let x1 = bool_to_val F in
              let (x2,stack) = pop_all stack in
                (x1,x2,x3,x4,stack)
            else if RefPtrEq x1 x2 then
              equal_loop (x1,x2,x3,x4,stack)
            else
              let x1 = bool_to_val F in
              let (x2,stack) = pop_all stack in
                (x1,x2,x3,x4,stack:bc_value list)`

val (equal_full_cert,equal_full_def,equal_full_pre_def) = x64_compile `
  equal_full (x1,x2,x3,x4,stack) =
    let stack = x4::stack in
    let stack = x3::stack in
    let stack = x2::stack in
    let x3 = Number 0 in
    let stack = x3::stack in
    let stack = x2::stack in
    let stack = x1::stack in
    let x3 = Number 1 in
    let stack = x3::stack in
    let (x1,x2,x3,x4,stack) = equal_loop (x1,x2,x3,x4,stack) in
    let (x2,stack) = (HD stack, TL stack) in
    let (x3,stack) = (HD stack, TL stack) in
    let (x4,stack) = (HD stack, TL stack) in
      (x1,x2,x3,x4,stack)`

val eq_stack_def = Define `
  (eq_stack [] = [Number 0]) /\
  (eq_stack ((x,y)::xs) = Number 1 :: x :: y :: eq_stack xs)`;

val pop_all_eq_stack = prove(
  ``!xs stack. pop_all_pre (eq_stack xs ++ stack) /\
               (pop_all (eq_stack xs ++ stack) = (Number 0,stack))``,
  Induct \\ ONCE_REWRITE_TAC [pop_all_def,pop_all_pre_def] \\ TRY Cases
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,eq_stack_def,HD,APPEND,
       isNumber_def,getNumber_def,TL]);

val bc_equal_def = bytecodeTerminationTheory.bc_equal_def

val bc_equal_list_SING = prove(
  ``!x y. bc_equal_list [x] [y] = bc_equal x y``,
  Cases \\ Cases \\ SIMP_TAC (srw_ss()) [bc_equal_def]
  \\ SRW_TAC [] [] \\ Cases_on `bc_equal_list l l'` \\ SRW_TAC [] []);

val bc_equal_list_ZIP = prove(
  ``!l l' t.
      (LENGTH l' = LENGTH l) ==>
      ((case bc_equal_list l' l of
          Eq_val T => bc_equal_list (MAP FST t) (MAP SND t)
        | Eq_val F => Eq_val F
        | Eq_closure => Eq_closure
        | Eq_type_error => Eq_type_error) =
       bc_equal_list (MAP FST (ZIP(l',l) ++ t)) (MAP SND (ZIP(l',l) ++ t)))``,
  Induct \\ Cases_on `l'` \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1]
  \\ SIMP_TAC (srw_ss()) [bc_equal_def] \\ REPEAT STRIP_TAC
  \\ Cases_on `bc_equal h h'` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ Cases_on `b` \\ FULL_SIMP_TAC (srw_ss()) []);

val FLAT_MAP_APPEND = prove(
  ``!xs t.
      (FLAT (MAP (\(x,y). [Number 1; y; x]) xs) ++ eq_stack t =
       eq_stack ((MAP (\(x,y). (y,x)) xs) ++ t))``,
  Induct \\ ASM_SIMP_TAC (srw_ss()) [FORALL_PROD,eq_stack_def]);

val MAP_ZIP_SWAP = prove(
  ``!xs ys.
      (LENGTH xs = LENGTH ys) ==>
      (MAP (\(x,y). (y,x)) (ZIP (xs,ys)) = ZIP (ys,xs))``,
  Induct \\ Cases_on `ys` \\ FULL_SIMP_TAC std_ss [LENGTH,ADD1,ZIP,MAP]);

val bc_value1_size_APPEND = prove(
  ``!xs ys. bc_value1_size (xs ++ ys) =
            bc_value1_size xs + bc_value1_size ys``,
  Induct \\ ASM_SIMP_TAC std_ss [bc_value_size_def,APPEND,ADD_ASSOC]);

val equal_loop_thm = prove(
  ``!xs res x1 x2 x3 x4 stack.
      (bc_equal_list (MAP FST xs) (MAP SND xs) <> Eq_type_error) ==>
      ?x2i x3i x4i.
        equal_loop_pre (x1,x2,x3,x4,eq_stack xs ++ stack) /\
        (equal_loop (x1,x2,x3,x4,eq_stack xs ++ stack) =
           (bc_equality_result_to_val
              (bc_equal_list (MAP FST xs) (MAP SND xs)),x2i,x3i,x4i,stack))``,
  STRIP_TAC \\ completeInduct_on `bc_value1_size (MAP FST xs)`
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ Cases_on `xs` \\ SIMP_TAC std_ss [eq_stack_def,APPEND]
  THEN1 (ONCE_REWRITE_TAC [equal_loop_def,equal_loop_pre_def]
    \\ SIMP_TAC std_ss [LET_DEF,HD,TL,getNumber_def,isNumber_def] \\ EVAL_TAC)
  \\ Cases_on `h` \\ FULL_SIMP_TAC std_ss [eq_stack_def,MAP]
  \\ ONCE_REWRITE_TAC [equal_loop_def,equal_loop_pre_def]
  \\ SIMP_TAC std_ss [LET_DEF,HD,TL,getNumber_def,isNumber_def]
  \\ SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  \\ Cases_on `isNumber r` \\ FULL_SIMP_TAC std_ss [] THEN1
   (REVERSE (Cases_on `isNumber q`)
    \\ FULL_SIMP_TAC std_ss [pop_all_eq_stack,bc_equal_def] THEN1
     (Cases_on `r` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
      \\ Cases_on `q` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
      \\ FULL_SIMP_TAC (srw_ss()) [bc_equal_def])
    \\ Cases_on `r` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
    \\ Cases_on `q` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
    \\ FULL_SIMP_TAC std_ss [getNumber_def,isSmall_def]
    \\ Q.ABBREV_TAC `j = i'` \\ POP_ASSUM (K ALL_TAC)
    \\ Cases_on `small_int j` \\ FULL_SIMP_TAC std_ss [] THEN1
     (Cases_on `i = j` \\ FULL_SIMP_TAC (srw_ss()) [bc_equal_def]
      \\ `bc_value1_size (MAP FST t) <
          bc_value1_size (Number j::MAP FST t)` by ALL_TAC
      THEN1 (EVAL_TAC \\ DECIDE_TAC)
      \\ Q.PAT_ASSUM `!xx.bbb` (MP_TAC o Q.SPEC `t`)
      \\ FULL_SIMP_TAC std_ss [])
    \\ Cases_on `small_int i` \\ FULL_SIMP_TAC std_ss [] THEN1
     (`i <> j` by ALL_TAC THEN1
         (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [bc_equal_def] \\ EVAL_TAC)
    \\ REVERSE (Cases_on `i = j`)
    \\ FULL_SIMP_TAC std_ss [bc_equal_def,EVAL ``1=0:int``] THEN1 EVAL_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SEP_I_TAC "equal_loop" \\ POP_ASSUM MP_TAC \\ ASM_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC IMP_IMP
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ EVAL_TAC \\ DECIDE_TAC)
  \\ Cases_on `isBlock r` \\ FULL_SIMP_TAC std_ss [] THEN1
   (REVERSE (Cases_on `isBlock q`)
    \\ FULL_SIMP_TAC std_ss [pop_all_eq_stack,bc_equal_def] THEN1
     (Cases_on `r` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
      \\ Cases_on `q` \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def]
      \\ FULL_SIMP_TAC (srw_ss()) [bc_equal_def,isBlock_def])
    \\ Cases_on `r` \\ Cases_on `q`
    \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def,isBlock_def]
    \\ FULL_SIMP_TAC std_ss [getTag_def,getContent_def,bc_equal_def]
    \\ REVERSE (Cases_on `n' = n`) \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
     (Cases_on `n' = 2` \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
      \\ Cases_on `n = 2` \\ FULL_SIMP_TAC std_ss [] \\ EVAL_TAC)
    \\ Cases_on `n = 2` \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
    \\ SIMP_TAC std_ss [explode_result_def,getContent_def]
    \\ REVERSE (Cases_on `LENGTH l' = LENGTH l`)
    \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
    \\ FULL_SIMP_TAC std_ss [bc_equal_list_ZIP,APPEND_ASSOC]
    \\ FULL_SIMP_TAC std_ss [FLAT_MAP_APPEND,MAP_ZIP_SWAP]
    \\ SEP_I_TAC "equal_loop" \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [MAP_FST_ZIP,MAP_APPEND]
      \\ FULL_SIMP_TAC std_ss [bc_value_size_def,bc_value1_size_APPEND]
      \\ DECIDE_TAC) \\ FULL_SIMP_TAC std_ss [])
  \\ Cases_on `r` \\ Cases_on `q`
  \\ FULL_SIMP_TAC std_ss [isNumber_def,canCompare_def,isBlock_def]
  \\ FULL_SIMP_TAC (srw_ss()) [bc_equal_def,pop_all_eq_stack,RefPtrEq_def]
  \\ REVERSE (Cases_on `n' = n`) \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
  \\ FULL_SIMP_TAC std_ss [isRefPtr_def]
  \\ `bc_value1_size (MAP FST t) <
      bc_value1_size (RefPtr n::MAP FST t)` by ALL_TAC
  THEN1 (EVAL_TAC \\ DECIDE_TAC)
  \\ Q.PAT_ASSUM `!xx.bbb` (MP_TAC o Q.SPEC `t`)
  \\ FULL_SIMP_TAC std_ss [])
  |> Q.SPEC `[(x1,x2)]`
  |> SIMP_RULE std_ss [eq_stack_def,MAP,APPEND,bc_equal_list_SING]

val equal_full_thm = prove(
  ``(bc_equal x1 x2 <> Eq_type_error) ==>
    equal_full_pre (x1,x2,x3,x4,stack) /\
    (equal_full (x1,x2,x3,x4,stack) =
       (bc_equality_result_to_val (bc_equal x1 x2),x2,x3,x4,stack))``,
  SIMP_TAC std_ss [equal_full_def,equal_full_pre_def,LET_DEF]
  \\ ASSUME_TAC (GEN_ALL equal_loop_thm) \\ SEP_I_TAC "equal_loop"
  \\ STRIP_TAC \\ FULL_SIMP_TAC (srw_ss()) [HD,TL]);

val zHEAP_RAW_EQUAL = equal_full_cert
  |> DISCH ``bc_equal x1 x2 <> Eq_type_error``
  |> SIMP_RULE std_ss [equal_full_thm,LET_DEF,SEP_CLAUSES]
  |> RW [GSYM SPEC_MOVE_COND];


(* prove that GC is no-op *)

val zHEAP_GC = let
  val th = zHEAP_GC_RAW
  val th =
    SPEC_COMPOSE_RULE [zHEAP_PUSH1_GC, zHEAP_PUSH2_GC,
                       zHEAP_PUSH3_GC, zHEAP_PUSH4_GC, th,
                       zHEAP_POP4_GC, zHEAP_POP3_GC,
                       zHEAP_POP2_GC, zHEAP_POP1_GC]
  val th = th |> REWRITE_RULE [HD,TL,NOT_CONS_NIL,SEP_CLAUSES]
  in th end;


(* next char -- calls getchar *)

val heap_inv_IMP = prove(
  ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,SOME f) vals ==> ?sp. f (sp,vals)``,
  SIMP_TAC std_ss [heap_inv_def] \\ REPEAT STRIP_TAC \\ METIS_TAC []);

val x64_getchar_thm = prog_x64_extraTheory.x64_getchar_thm;

val getchar_lemma = let
  val load_r0 = compose_specs ["mov r0,[r9+32]"]
  val mov_r10_r0 = compose_specs ["mov r10,r0"]
  val th1 = SPEC_COMPOSE_RULE [ x64_push_r0, x64_push_r1, x64_push_r2,
    x64_push_r3, x64_push_r6, x64_push_r7, x64_push_r8, x64_push_r9,
    x64_push_r11, load_r0, x64_call_r0, x64_getchar_thm,
    mov_r10_r0, x64_pop_r11, x64_pop_r9, x64_pop_r8,
    x64_pop_r7, x64_pop_r6, x64_pop_r3, x64_pop_r2, x64_pop_r1,
    x64_pop_r0]
    |> REWRITE_RULE [TL,HD,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
    |> SIMP_RULE (std_ss++sep_cond_ss) []
    |> Q.INST [`po`|->`cs.putchar_ptr`,
               `input`|->`MAP (n2w o ORD) (DROP 1 s.input)`,
               `output`|->`MAP (n2w o ORD) s.output`]
  in th1 end

val zHEAP_NEXT_INPUT = let
  val th = getchar_lemma |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL]
    \\ SIMP_TAC std_ss [STAR_ASSOC,SEP_IMP_def,cond_STAR]
    \\ REPEAT STRIP_TAC \\ IMP_RES_TAC heap_inv_IMP
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,
         one_list_def,word_arith_lemma1,SEP_CLAUSES]
    \\ SEP_R_TAC \\ NTAC 2 (POP_ASSUM MP_TAC)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_CLAUSES])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs, x1, x2, x3, x4, refs, stack,
    (s with input := DROP 1 s.input),NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| input_stream := DROP 1 vals.input_stream ;
          reg10 := (HD
             (SNOC (~0x0w)
                (MAP w2w (MAP ((n2w:num->word8) o ORD) (DROP 1 s.input))))) |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ `vals.memory (vs.base_ptr + 32w) = cs.getchar_ptr` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Cases_on `s.input`
    \\ FULL_SIMP_TAC (srw_ss()) [DROP_def,MAP,HD,HD,APPEND,SNOC_APPEND,not_0w_def]
    \\ Cases_on `t`
    \\ FULL_SIMP_TAC (srw_ss()) [DROP_def,MAP,HD,HD,APPEND,SNOC_APPEND,not_0w_def]
    \\ `ORD h' < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ FULL_SIMP_TAC (srw_ss()) [w2w_def,n2w_w2n])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;

val zHEAP_READ_INPUT = let
  val th = compose_specs ["mov r0,r10","shl r0,2"]
  val pc = get_pc th
  val pre = ``s.input <> ""``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
    Number (& (ORD (HD s.input))),
    x2, x3, x4, refs, stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val blast = blastLib.BBLAST_PROVE
    ``!w:word64. w <+ 512w ==> (0x7FCw && 0x4w * w = 0x4w * w)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [MAP,HD,APPEND]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Cases_on `s.input` \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.EXISTS_TAC `vals with reg0 := (n2w (ORD h) << 2)`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) []
      \\ FULL_SIMP_TAC (std_ss++star_ss) [APPEND,GSYM APPEND_ASSOC])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
         `Data (2w * n2w ((ORD h)))`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ SIMP_TAC std_ss [x64_addr_def]
    \\ REVERSE STRIP_TAC THEN1
     (`ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
      \\ `2 * ORD h < 9223372036854775808` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,WORD_MUL_LSL,MULT_ASSOC,w2w_n2w,
          bitTheory.BITS_THM])
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x1`,`r1`] \\ ASM_SIMP_TAC std_ss []
    \\ `ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ SRW_TAC [] [] \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;

val zHEAP_READ_INPUT_DIGIT = let
  val th = compose_specs ["mov r0,r10","sub r0,48","shl r0,2"]
  val pc = get_pc th
  val pre = ``s.input <> "" /\ 48 <= ORD (HD s.input)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
    Number (& (ORD (HD s.input) - 48)),
    x2, x3, x4, refs, stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val blast = blastLib.BBLAST_PROVE
    ``!w:word64. w <+ 512w ==> (0x7FCw && 0x4w * w = 0x4w * w)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [MAP,HD,APPEND]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Cases_on `s.input` \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.EXISTS_TAC `vals with reg0 := ((n2w (ORD h) - 48w) << 2)`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) []
      \\ FULL_SIMP_TAC (std_ss++star_ss) [APPEND,GSYM APPEND_ASSOC])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,
         `Data (2w * n2w ((ORD h) - 48))`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ SIMP_TAC std_ss [x64_addr_def]
    \\ REVERSE STRIP_TAC THEN1
     (`ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
      \\ `2 * (ORD h - 48) < 9223372036854775808` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,WORD_MUL_LSL,MULT_ASSOC,w2w_n2w,
           bitTheory.BITS_THM,LEFT_SUB_DISTRIB]
      \\ `~(4 * ORD h < 192)` by DECIDE_TAC
      \\ IMP_RES_TAC (MATCH_MP (METIS_PROVE [] ``(x = if b then x1 else x2) ==>
                   (~b ==> (x2 = x))``) (word_arith_lemma2 |> SPEC_ALL
                      |> INST_TYPE [``:'a``|->``:64``]))
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x1`,`r1`] \\ ASM_SIMP_TAC std_ss []
    \\ `ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ SRW_TAC [] [] \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;

val zHEAP_CMP_INPUT = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec "4981FA"
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_ZF`` th
  val lemma = prove(
    ``k < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (k)):word32)))) =
       n2w (k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(k) < 4294967296 /\ ~(2147483648 <= k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = th |> Q.INST [`imm32`|->`n2w k`] |> RW [lemma]
  val pc = get_pc th
  val pre = ``s.input <> "" /\ (k:num) < 2**31``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_ZF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_CF (SOME (ORD (HD s.input) < k)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(ORD (HD s.input) < k) <=> (vals.reg10 <+ n2w k)` by ALL_TAC
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
    \\ Cases_on `s.input` \\ FULL_SIMP_TAC std_ss [HD,MAP,APPEND]
    \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO]
    \\ `ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ `ORD h < 18446744073709551616 /\
        k < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p * cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th |> Q.GEN `k`
  fun store_cmp x =
    SPEC (numSyntax.term_of_int x) th |> SIMP_RULE (srw_ss()) [w2w_n2w]
    |> (fn th => (add_compiled [th]; th))
  val xs = map store_cmp (upto 1 255)
  in th end;

val zHEAP_INPUT_EQ = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec "4981FA"
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_CF`` th
  val lemma = prove(
    ``k < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (k)):word32)))) =
       n2w (k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(k) < 4294967296 /\ ~(2147483648 <= k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = th |> Q.INST [`imm32`|->`n2w k`] |> RW [lemma]
  val pc = get_pc th
  val pre = ``s.input <> "" /\ (k:num) < 256``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_CF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_ZF (SOME (HD s.input = CHR k)) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(HD s.input = CHR k) <=> (vals.reg10 = n2w k)` by ALL_TAC
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
    \\ Cases_on `s.input` \\ FULL_SIMP_TAC std_ss [HD,MAP,APPEND]
    \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO]
    \\ `ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ `ORD h < 18446744073709551616 /\
        k < 18446744073709551616` by DECIDE_TAC
    \\ Cases_on `h`
    \\ FULL_SIMP_TAC std_ss [GSYM ORD_11,ORD_CHR])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p * cond (^pre)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th |> Q.GEN `k`
  fun store_cmp x =
    SPEC (numSyntax.term_of_int x) th |> SIMP_RULE (srw_ss()) [w2w_n2w]
    |> (fn th => (add_compiled [th]; th))
  val xs = map store_cmp (upto 0 255)
  in th end;

val zHEAP_EMPTY_INPUT = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec "4981FA"
  val th = th |> Q.INST [`rip`|->`p`]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_ZF`` th
  val lemma = prove(
    ``k < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (k)):word32)))) =
       n2w (k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(k) < 4294967296 /\ ~(2147483648 <= k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = th |> Q.INST [`imm32`|->`n2w k`] |> RW [lemma]
  val th = th |> Q.INST [`k`|->`256`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      ~zS1 Z_ZF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_CF (SOME (s.input <> "")) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`vals`]
    \\ `(s.input <> "") <=> (vals.reg10 <+ 256w)` by ALL_TAC
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,AC STAR_COMM STAR_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,abs_ml_inv_def,APPEND,
           bc_stack_ref_inv_def,LIST_REL_def,bc_value_inv_def]
    \\ Cases_on `s.input` \\ FULL_SIMP_TAC std_ss [HD,MAP,APPEND]
    THEN1 EVAL_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO]
    \\ `ORD h < 256` by FULL_SIMP_TAC std_ss [ORD_BOUND]
    \\ `ORD h < 18446744073709551616` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma |> SIMP_RULE (srw_ss()) [w2w_n2w]
  val _ = add_compiled [th]
  in th end;


(* print char -- calls putchar *)

val load_char_lemma = let
  val ((r7,_,_),_) = prog_x64Lib.x64_spec "BF"
  val blast_lemma = blastLib.BBLAST_PROVE
    ``(w2w ((w2w imm8):word32) = imm8:word8) /\
      (w2w (((w2w imm8):word32) >>> 8) = 0w:word8) /\
      (w2w (((w2w imm8):word32) >>> 16) = 0w:word8) /\
      (w2w (((w2w imm8):word32) >>> 24) = 0w:word8)``
  val r7 = r7 |> Q.INST [`imm32`|->`w2w (c:word8)`] |> RW [blast_lemma]
  val lemma = prove(
    ``!c:word8. (n2w (SIGN_EXTEND 32 64 (w2n c) MOD 4294967296) = (w2w c):word64)``,
    Cases \\ FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,w2w_n2w,
        bitTheory.BITS_THM2,bitTheory.BIT_def]
    \\ `n < 4294967296 /\ ~(2147483648 <= n)` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [LET_DEF,DIV_EQ_X]);
  val r7 = SIMP_RULE (srw_ss()) [w2n_w2w,lemma] r7
  in r7 end

val putchar_lemma = let
  val ((load_r0,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r0,[r9+24]")
  val th1 = SPEC_COMPOSE_RULE [ x64_push_r0, x64_push_r1, x64_push_r2,
    x64_push_r3, x64_push_r6, x64_push_r7, x64_push_r8, x64_push_r9,
    x64_push_r10, x64_push_r11, load_char_lemma, load_r0, x64_call_r0,
    x64_putchar_thm, x64_pop_r11, x64_pop_r10, x64_pop_r9, x64_pop_r8,
    x64_pop_r7, x64_pop_r6, x64_pop_r3, x64_pop_r2, x64_pop_r1, x64_pop_r0]
    |> REWRITE_RULE [TL,HD,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
    |> SIMP_RULE (std_ss++sep_cond_ss) []
    |> Q.INST [`pi`|->`cs.getchar_ptr`,
               `input`|->`MAP (n2w o ORD) (DROP 1 s.input)`,
               `output`|->`MAP (n2w o ORD) s.output`]
  in th1 end

val zHEAP_PUT_CHAR = let
  val th = putchar_lemma |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL]
    \\ SIMP_TAC std_ss [STAR_ASSOC,SEP_IMP_def,cond_STAR]
    \\ REPEAT STRIP_TAC \\ IMP_RES_TAC heap_inv_IMP
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,
         one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ NTAC 2 (POP_ASSUM MP_TAC)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_CLAUSES])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs, x1, x2, x3, x4, refs, stack,
    (s with output := s.output ++ [CHR (w2n (c:word8))]),NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| output_stream := vals.output_stream ++ [c] |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ `vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
    \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ ASSUME_TAC (Q.ISPEC `c:word8` w2n_lt)
    \\ FULL_SIMP_TAC (srw_ss()) [ORD_CHR,STAR_ASSOC]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

fun install_print_char c = let
  val th = zHEAP_PUT_CHAR
    |> INST [``c:word8``|->``n2w (^(numSyntax.term_of_int c)):word8``]
  in add_compiled [SIMP_RULE (srw_ss()) [] th] end

val _ = map install_print_char (upto 1 255);

val zHEAP_COND_PUT_CHAR = let
  val th1 = zHEAP_TEST_PRINTING_ON
  val ((th2,_,_),x) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "je 52")
  fun the (SOME x) = x | the _ = fail()
  val (th2a,_,_) = the x
  val th3 = zHEAP_PUT_CHAR
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val f = HIDE_STATUS_RULE true sts
  val g = RW [SPEC_MOVE_COND] o SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thA = SPEC_COMPOSE_RULE [SPEC_COMPOSE_RULE [th1,th2a] |> f, th3] |> g
  val thB = SPEC_COMPOSE_RULE [th1,th2] |> f |> g
  val pc = get_pc (UNDISCH_ALL thA)
  val c = thA |> concl |> rand |> rator |> rand
  val thB = MATCH_MP SPEC_SUBSET_CODE (thB |> UNDISCH) |> SPEC c
              |> SIMP_RULE (srw_ss()) [INSERT_SUBSET,EMPTY_SUBSET] |> DISCH_ALL
  val lemma = prove(
    ``(b ==> SPEC m p c q1) /\
      (~b ==> SPEC m p c q2) ==>
      SPEC m p c (if b then q1 else q2)``,
    Cases_on `b` \\ FULL_SIMP_TAC std_ss []);
  val th = MATCH_MP lemma (CONJ thB thA)
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``zHEAP
          (cs,x1,x2,x3,x4,refs,stack,
           s with output := if s.local.printing_on = 0x0w then s.output else
             STRCAT s.output (STRING (CHR (w2n (c:word8))) ""),
           NONE) * zS * ^pc``
  val lemma = prove(goal,
    SRW_TAC [] [SEP_IMP_REFL]
    \\ `(s with output := s.output) = s` by ALL_TAC THEN1
      (Cases_on `s` \\ SRW_TAC [] (TypeBase.updates_of ``:zheap_state``))
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_IMP_REFL])
  val th = MP th lemma
  in th end;


(* put char from reg *)

val putchar_lemma = let
  val load_r7 = compose_specs ["mov r7,r0","shr r7,2"]
  val ((load_r0,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r0,[r9+24]")
  val th1 = SPEC_COMPOSE_RULE [x64_push_r0, x64_push_r1, x64_push_r2,
    x64_push_r3, x64_push_r6, x64_push_r7, x64_push_r8, x64_push_r9,
    x64_push_r10, x64_push_r11, load_r7, load_r0, x64_call_r0]
  val th1 = th1 |> DISCH ``r0 >>> 2 = w2w (c:word8):word64``
                |> SIMP_RULE std_ss [] |> RW [GSYM SPEC_MOVE_COND]
  val th1 = SPEC_COMPOSE_RULE [th1,x64_putchar_thm,
    x64_pop_r11, x64_pop_r10, x64_pop_r9, x64_pop_r8,
    x64_pop_r7, x64_pop_r6, x64_pop_r3, x64_pop_r2, x64_pop_r1, x64_pop_r0]
    |> REWRITE_RULE [TL,HD,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
    |> SIMP_RULE (std_ss++sep_cond_ss) []
    |> Q.INST [`pi`|->`cs.getchar_ptr`,
               `input`|->`MAP (n2w o ORD) (DROP 1 s.input)`,
               `output`|->`MAP (n2w o ORD) s.output`]
  in th1 end

val zHEAP_PUT_CHAR = let
  val th = putchar_lemma |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isNumber x1 /\ 0 <= getNumber x1 /\ getNumber x1 < 256)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL]
    \\ SIMP_TAC std_ss [STAR_ASSOC,SEP_IMP_def,cond_STAR]
    \\ REPEAT STRIP_TAC \\ IMP_RES_TAC heap_inv_IMP
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,
         one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ NTAC 2 (POP_ASSUM MP_TAC)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_CLAUSES])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = th |> Q.INST [`c`|->`n2w (Num (getNumber x1))`]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs, x1, x2, x3, x4, refs, stack,
    (s with output := s.output ++ [CHR (Num (getNumber x1))]),NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vs.base_ptr + 0x18w && 0x7w = 0x0w)` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_FORALL] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,LIST_REL_def]
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def]
    \\ `small_int i` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
    \\ `~(i < 0)` by intLib.COOPER_TAC
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ STRIP_TAC THEN1
     (Cases_on `i` \\ FULL_SIMP_TAC (srw_ss()) [small_int_def]
      \\ NTAC 250 (TRY (Cases_on `n`) \\ TRY (Cases_on `n'`)
                   \\ SIMP_TAC (srw_ss()) []
                   \\ FULL_SIMP_TAC std_ss [ADD1,GSYM ADD_ASSOC])
      \\ `F` by DECIDE_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC
         `vals with <| output_stream := vals.output_stream ++ [n2w (Num i)] |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ POP_ASSUM MP_TAC
    \\ ASM_SIMP_TAC (srw_ss()) [x64_addr_def]
    \\ `vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def,abs_ml_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,PULL_EXISTS]
    \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss []
    \\ `Num i < 256` by intLib.COOPER_TAC
    \\ IMP_RES_TAC ORD_CHR \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isNumber x1 /\ 0 <= getNumber x1 /\ getNumber x1 < 256)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;


(* print error message *)

fun zHEAP_PRINT_MSG msg = let
  val th = SPEC_COMPOSE_RULE [load_char_lemma,x64_call_r15,x64_putchar_thm]
  val th = th |> Q.INST [`c`|->`n2w (ORD chr)`] |> Q.GEN `chr`
  fun spec_for_char c = th |> SPEC (stringSyntax.fromMLchar c)
  val th = SPEC_COMPOSE_RULE (map spec_for_char (explode msg))
  val lemma = prove(
    ``(n2w (ORD c) :: [] = MAP (n2w o ORD) [c]) /\
      (n2w (ORD c) :: MAP (n2w o ORD) cs = MAP (n2w o ORD) (c::cs))``,
    SIMP_TAC std_ss [MAP])
  val th = th |> SIMP_RULE std_ss [GSYM APPEND_ASSOC,APPEND]
              |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss()) []))
              |> RW [lemma]
  val lemma = th
  val ((load_r15,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r15,[r9+24]")
  val th1 = SPEC_COMPOSE_RULE [ x64_push_r0, x64_push_r1, x64_push_r2,
    x64_push_r3, x64_push_r6, x64_push_r7, x64_push_r8, x64_push_r9,
    x64_push_r10, x64_push_r11, x64_push_r15, load_r15, lemma,
    x64_pop_r15, x64_pop_r11, x64_pop_r10, x64_pop_r9, x64_pop_r8, x64_pop_r7,
    x64_pop_r6, x64_pop_r3, x64_pop_r2, x64_pop_r1, x64_pop_r0]
    |> REWRITE_RULE [TL,HD,NOT_CONS_NIL,SEP_CLAUSES,STAR_ASSOC]
    |> SIMP_RULE (std_ss++sep_cond_ss) []
    |> Q.INST [`pi`|->`cs.getchar_ptr`,
               `input`|->`MAP (n2w o ORD) (DROP 1 s.input)`,
               `output`|->`MAP (n2w o ORD) s.output`]
    |> RW [GSYM MAP_APPEND]
  val th = th1 |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL]
    \\ SIMP_TAC std_ss [STAR_ASSOC,SEP_IMP_def,cond_STAR]
    \\ REPEAT STRIP_TAC \\ IMP_RES_TAC heap_inv_IMP
    \\ FULL_SIMP_TAC std_ss [heap_inv_def,x64_store_def,
         one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ NTAC 2 (POP_ASSUM MP_TAC)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_CLAUSES])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val msg_tm = stringSyntax.fromMLstring msg
  val th = th |> Q.SPEC `zHEAP (cs, x1, x2, x3, x4, refs, stack,
    (s with output := s.output ++ ^msg_tm),NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| output_stream :=
         vals.output_stream ++ MAP (n2w o ORD) ^msg_tm |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ `vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr` by ALL_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [x64_store_def,one_list_def,SEP_CLAUSES]
      \\ SEP_R_TAC \\ SIMP_TAC std_ss []) \\ FULL_SIMP_TAC std_ss []
    \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val _ = add_compiled [th]
  in th end;

val error_msg = error_msg_def |> concl |> rand |> stringSyntax.fromHOLstring;

val zHEAP_PRINT_ERROR_MSG = zHEAP_PRINT_MSG error_msg
                              |> RW [GSYM error_msg_def]

val print_fn = zHEAP_PRINT_MSG "<fn>"
val print_ref = zHEAP_PRINT_MSG "<ref>"
val print_true = zHEAP_PRINT_MSG "true"
val print_false = zHEAP_PRINT_MSG "false"
val print_cons = zHEAP_PRINT_MSG "<constructor>"
val _ = zHEAP_PRINT_MSG "<vector>"

val _ = zHEAP_PRINT_MSG "\\n"
val _ = zHEAP_PRINT_MSG "\\t"
val _ = zHEAP_PRINT_MSG "\\\\"
val _ = zHEAP_PRINT_MSG "\""

(* terminate, i.e. clean up and call return pointer *)

val (x64_pop_stack_res, x64_pop_stack_def, x64_pop_stack_pre_def) = x64_compile `
  x64_pop_stack (ss:word64 list) =
    let (r15,ss) = (HD ss,TL ss) in
      if r15 = 1w then let ss = r15::ss in (ss) else
        x64_pop_stack (ss)`

val x64_pop_stack_thm = prove(
  ``!xs ys.
      EVERY (\x. x <> 1w) xs ==>
      x64_pop_stack_pre (xs ++ 1w :: ys) /\
      (x64_pop_stack (xs ++ 1w :: ys) = 1w::ys)``,
  Induct \\ SIMP_TAC std_ss [APPEND,EVERY_DEF]
  \\ ONCE_REWRITE_TAC [x64_pop_stack_def, x64_pop_stack_pre_def]
  \\ ASM_SIMP_TAC std_ss [LET_DEF,HD,TL,NOT_CONS_NIL]);

val x64_addr_NOT_1 = prove(
  ``!h a. (a && 7w = 0w) ==> x64_addr a h <> 0x1w``,
  Cases  \\ FULL_SIMP_TAC std_ss [x64_addr_def] \\ blastLib.BBLAST_TAC);

val zHEAP_POP_ENTIRE_STACK = let
  val th = x64_pop_stack_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,[],s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ `EVERY (\x. x <> 1w) (MAP (x64_addr vs.current_heap) roots)` by
     (FULL_SIMP_TAC std_ss [EVERY_MEM,MEM_MAP,PULL_EXISTS,heap_vars_ok_def]
      \\ METIS_TAC [x64_addr_NOT_1])
    \\ IMP_RES_TAC x64_pop_stack_thm \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with <| stack := 1w::cs.ret_address::cs.rest_of_stack ;
                                  reg15 := x |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (pop_thm |> GEN_ALL)
    \\ Q.LIST_EXISTS_TAC [`stack`,`roots`]
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ FULL_SIMP_TAC std_ss []
    \\ (move_thm
        |> Q.SPECL [`[]`,`[]`] |> Q.INST [`stack`|->`[]`,`roots`|->`[]`]
        |> SIMP_RULE std_ss [APPEND,LENGTH,GSYM APPEND_ASSOC,APPEND_NIL]
        |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [APPEND,LENGTH])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_TERMINATE = let
  val th = SPEC_COMPOSE_RULE [x64_pop_r15,x64_ret]
  val th = th |> Q.INST [`rip`|->`p`]
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,[],s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP_OUTPUT (cs,s.output)`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ `LENGTH roots = 0` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [LENGTH_NIL,MAP,APPEND,HD,TL,NOT_CONS_NIL]
    \\ SIMP_TAC std_ss [zHEAP_OUTPUT_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals with <| stack := cs.rest_of_stack
                                                    ; reg15 := 1w |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,SEP_CLAUSES]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,[],s,NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [zHEAP_POP_ENTIRE_STACK,th]
  in th end;


(* terminate with error message *)

val zHEAP_TERMINATE_WITH_ERROR = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jmp [r9+40]")
  val th = th |> Q.INST [`rip`|->`p`]
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS *
                         zPC cs.error_ptr`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES] \\ STRIP_TAC
    \\ POP_ASSUM (fn th => MP_TAC th THEN ASSUME_TAC th)
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ `(vals.memory (vs.base_ptr + 40w) = cs.error_ptr)` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
           \\ SEP_R_TAC)
    \\ `(vs.base_ptr + 40w) IN vals.memory_domain` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
           \\ SEP_R_TAC) \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def,SEP_CLAUSES]
    \\ FULL_SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th1 = MP th lemma
  val th = SPEC_COMPOSE_RULE [zHEAP_PRINT_ERROR_MSG,zHEAP_TERMINATE]
  val (th,goal) = SPEC_WEAKEN_RULE th ``zHEAP_ERROR cs``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zHEAP_ERROR_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `s.output`
    \\ FULL_SIMP_TAC (srw_ss()) [rich_listTheory.IS_PREFIX_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val (_,_,code,_) = dest_spec (concl th)
  val error_code_def = Define `error_code (p:word64) = ^code`;
  val th = th |> RW [GSYM error_code_def]
  val th = SPEC_COMPOSE_RULE [th1,th]
  in th end;


(* allocator space test *)

val heap_lookup_IMP_heap_length = prove(
  ``!heap a k. (heap_lookup a heap = SOME (Unused k)) ==>
               k < heap_length heap``,
  Induct THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ FULL_SIMP_TAC std_ss [heap_lookup_def,heap_length_def,MAP,SUM]
  \\ SRW_TAC [] [el_length_def] \\ RES_TAC \\ DECIDE_TAC);

val abs_ml_inv_SP_LESS_LIMIT = prove(
  ``abs_ml_inv stack refs (roots,heap,a,sp) limit ==> sp <= limit``,
  Cases_on `sp = 0`
  \\ ASM_SIMP_TAC std_ss [abs_ml_inv_def,unused_space_inv_def,heap_ok_def]
  \\ REPEAT STRIP_TAC \\ IMP_RES_TAC heap_lookup_IMP_heap_length
  \\ DECIDE_TAC);

val (zHEAP_ALLOC_TEST_SUCCESS,zHEAP_ALLOC_TEST_FAILURE) = let
  val ((th1,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r15,r7")
  val ((th2,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "sub r15,r6")
  val ((th3,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "cmp r15,r14")
  val ((th4,_,_),x) = prog_x64Lib.x64_spec_memory64 "73"
  val (th4i,_,_) = case x of SOME t => t | _ => fail()
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val thA = SPEC_COMPOSE_RULE [th1,th2,th3,th4]
  val thA = HIDE_STATUS_RULE true sts thA
  val thB = SPEC_COMPOSE_RULE [th1,th2,th3,th4i]
  val thB = HIDE_STATUS_RULE true sts thB
  (* success case *)
  val th = thA |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,precond_def]
               |> UNDISCH |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val inv = ``SOME (\(sp:num,vals).
                (vals.reg13 = ret) /\
                (vals.reg14 = n2w (8 * needed)) /\ needed <= sp /\
                 needed < 2 ** 34)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val rw_lemma = prove(``w - 1w - (v - 1w) = w - v:word64``,
                       blastLib.BBLAST_TAC);
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ SIMP_TAC std_ss [rw_lemma]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,GSYM word_mul_n2w,
           WORD_LEFT_ADD_DISTRIB,WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [Once WORD_ADD_COMM,WORD_ADD_SUB]
      \\ SIMP_TAC std_ss [word_mul_n2w,WORD_LO]
      \\ `(8 * sp) < 18446744073709551616` by
        (IMP_RES_TAC abs_ml_inv_SP_LESS_LIMIT \\ DECIDE_TAC)
      \\ `(8 * needed) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [w2n_n2w]
      \\ DECIDE_TAC)
    \\ Q.EXISTS_TAC `vals with <| reg15 := vals.reg7 - vals.reg6 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
  val thA = MP th lemma
  (* failure case *)
  val th = thB |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,precond_def]
               |> UNDISCH |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val inv = ``SOME (\(sp:num,vals).
                (vals.reg13 = ret) /\
                (vals.reg14 = n2w (8 * needed)) /\ ~(needed <= sp) /\
                 needed < 2 ** 34)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
set_goal([],goal)
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ SIMP_TAC std_ss [rw_lemma]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,GSYM word_mul_n2w,
           WORD_LEFT_ADD_DISTRIB,WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [Once WORD_ADD_COMM,WORD_ADD_SUB]
      \\ SIMP_TAC std_ss [word_mul_n2w,WORD_LO]
      \\ `(8 * sp) < 18446744073709551616` by
        (IMP_RES_TAC abs_ml_inv_SP_LESS_LIMIT \\ DECIDE_TAC)
      \\ `(8 * needed) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [w2n_n2w]
      \\ DECIDE_TAC)
    \\ Q.EXISTS_TAC `vals with <| reg15 := vals.reg7 - vals.reg6 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
  val thB = MP th lemma
  in (thA,thB) end;

val heap_inv_IMP_NONE = prove(
  ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,x) vals ==>
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals``,
  SIMP_TAC std_ss [heap_inv_def] \\ STRIP_TAC
  \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
  \\ FULL_SIMP_TAC std_ss []);

val zHEAP_JMP_r13 = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jmp r13")
  val inv = ``SOME (\(sp,vals). (vals.reg13 = ret) /\ P (sp:num,vals))``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS * zPC ret`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ ASM_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_CALL_ALLOC = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r13, [r9+48]")
  val th = SPEC_COMPOSE_RULE [th,x64_call_r13,x64_pop_r13]
           |> SIMP_RULE std_ss [NOT_CONS_NIL,HD,TL,SEP_CLAUSES]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val inv1 = ``SOME (\(sp:num,vals). (n2w (8 * needed) = vals.reg14))``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv1) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 0x30w) = cs.alloc_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals).
                (p + 0x7w = vals.reg13) /\
                (n2w (8 * needed) = vals.reg14))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg13 := p + 7w |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv1) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_ALLOC_FAIL_OR_RETURN = let
  val th = zHEAP_ALLOC_TEST_FAILURE |> Q.INST [`imm8`|->`4w`]
  val pc = get_pc th
  val (th,goal) =
    SPEC_WEAKEN_RULE th ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zHEAP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ IMP_RES_TAC heap_inv_IMP_NONE)
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [th,zHEAP_TERMINATE_WITH_ERROR]
  val inv = th |> concl |> find_term (can (match_term ``SOME (x:'a)``))
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val thB = MP th lemma
  val th = zHEAP_ALLOC_TEST_SUCCESS |> Q.INST [`imm8`|->`4w`]
  val lemma = EVAL ``(9 + (2 + SIGN_EXTEND 8 64 (w2n (0x4w:word8))))``
  val th = th |> RW [lemma]
  val lemma = zHEAP_JMP_r13 |> Q.INST [`P`|->`\(sp,vals).
       (vals.reg14 = n2w (8 * needed)) /\ needed <= sp /\ needed < 2 ** 34`]
    |> SIMP_RULE std_ss []
  val th = SPEC_COMPOSE_RULE [th |> SIMP_RULE std_ss [],lemma]
  val inv = th |> concl |> find_term (can (match_term ``SOME (x:'a)``))
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val (th,goal) = SPEC_WEAKEN_RULE th ``(zHEAP
        (cs,x1,x2,x3,x4,refs,stack,s,
         SOME (\(sp,vals). needed <= sp)) * ~zS * zPC ret)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ METIS_TAC [])
  val thA = MP th lemma
  val lemma = SPEC_MERGE |> SPEC_ALL |> Q.INST [`m`|->`SEP_F`]
                         |> RW [SEP_CLAUSES]
  val th = MATCH_MP lemma (CONJ thA thB)
  val inv = ``SOME
           (\(sp:num,vals).
              (vals.reg13 = ret) /\ (vals.reg14 = n2w (8 * needed)) /\
              needed < 2**34)``
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,SEP_DISJ_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_CLAUSES,
         SEP_EXISTS_THM,cond_STAR]
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ Cases_on `needed <= sp` THEN1
     (DISJ1_TAC
      \\ Q.EXISTS_TAC `vals` \\ FULL_SIMP_TAC std_ss []
      \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
      \\ FULL_SIMP_TAC std_ss []) THEN1
     (DISJ2_TAC
      \\ Q.EXISTS_TAC `vals` \\ FULL_SIMP_TAC std_ss []
      \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
      \\ FULL_SIMP_TAC std_ss []))
  val th = MP th lemma
  val th = RW [INSERT_UNION_EQ,UNION_EMPTY] th
  val th = th |> DISCH ``needed < (2**34):num``
              |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val th = RW1 [EQ_SYM_EQ] th
  val th1 = zHEAP_GC |> Q.INST [`ttt13`|->`ret`,`ttt14`|->`n2w (8 * needed)`]
  val th = SPEC_COMPOSE_RULE [th1,th]
  val th = SPEC_COMPOSE_RULE [zHEAP_CALL_ALLOC,th]
  val th = abbreviate_code "alloc" ``cs.alloc_ptr`` th
  in th end;

val heap_inv_WEAKEN = prove(
  ``(!sp vals. p (sp,vals) ==> q (sp,vals)) ==>
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,SOME p) vals ==>
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,SOME q) vals``,
  FULL_SIMP_TAC std_ss [heap_inv_def] \\ REPEAT STRIP_TAC \\ METIS_TAC [])
  |> GEN_ALL;

val zHEAP_ALLOC = let
  val th1 = zHEAP_ALLOC_FAIL_OR_RETURN
  val th = zHEAP_ALLOC_TEST_FAILURE
  val pc = get_pc th
  val post = th1 |> concl |> rator |> rator |> rand
                 |> subst [``p:word64``|->(pc |> rand)]
  val (th,goal) = SPEC_WEAKEN_RULE th post
  val lemma = prove(goal,
    SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ POP_ASSUM (K ALL_TAC) \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC heap_inv_WEAKEN
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val thGC = SPEC_COMPOSE_RULE [th,th1] |> Q.INST [`imm8`|->`7w`]
  val th = zHEAP_ALLOC_TEST_SUCCESS |> Q.INST [`imm8`|->`7w`]
  val lemma = EVAL ``(9 + (2 + SIGN_EXTEND 8 64 (w2n (0x7w:word8))))``
  val th = th |> RW [lemma]
  val (_,_,c,post) = thGC |> concl |> dest_spec
  val (th,goal) = SPEC_WEAKEN_RULE th post
  val lemma = prove(goal,
    SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ SIMP_TAC std_ss [SEP_DISJ_def] \\ DISJ1_TAC
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ POP_ASSUM (K ALL_TAC) \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC heap_inv_WEAKEN
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = MATCH_MP SPEC_SUBSET_CODE th |> SPEC c
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [INSERT_SUBSET,IN_INSERT,IN_UNION,EMPTY_SUBSET])
  val th = MP th lemma
  val th1 = thGC |> DISCH_ALL |> SIMP_RULE std_ss [] |> RW [GSYM SPEC_MOVE_COND]
                 |> Q.GEN `ret` |> Q.GEN `vals` |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val th2 = th |> Q.GEN `ret` |> Q.GEN `vals` |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val lemma = SPEC_MERGE |> SPEC_ALL
    |> Q.INST [`m`|->`SEP_F`,`c1`|->`c2`,`q1`|->`q2`]
    |> RW [SEP_CLAUSES,UNION_IDEMPOT]
  val th = MATCH_MP lemma (CONJ th1 th2)
  val inv = ``\(sp:num,vals). (vals.reg14 = n2w (8 * needed))``
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,SOME ^inv) * ~zS * zPC p *
      cond (needed < 2**34)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,heap_inv_def,SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`vals`,`vals.reg13`,`vals`,`vals.reg13`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Cases_on `needed <= sp` \\ METIS_TAC [])
  val th = MP th lemma
  in th end;

val zHEAP_ALLOC_CONS_SPACE = let
  val ((set_r14,_,_),_) = prog_x64Lib.x64_spec_memory64 "41BE"
  val lemma = prove(
    ``8 * needed < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (8 * needed)):word32)) MOD 4294967296)) =
       n2w (8 * needed):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(8 * needed) < 4294967296 /\ ~(2147483648 <= 8 * needed)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = set_r14 |> Q.INST [`rip`|->`p`,`imm32`|->`n2w (8 * needed)`] |> RW [lemma]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH T
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals). vals.reg14 = n2w (8 * needed))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg14 := n2w (8 * needed)`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ ASM_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR])
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [th,zHEAP_ALLOC]
  val th = th |> DISCH_ALL |> SIMP_RULE std_ss [SPEC_MOVE_COND,AND_IMP_INTRO]
  val lemma =
    DECIDE ``8 * needed < 2147483648 /\
             needed < 17179869184 <=> needed < 268435456:num``
  val th = RW [lemma,GSYM SPEC_MOVE_COND] th
  in th end;

(* cons *)

val (x64_cons_loop_res, x64_cons_loop_def, x64_cons_loop_pre_def) = x64_compile `
  x64_cons_loop (r7,r14:word64,r15:word64,dm:word64 set,m:word64->word64,ss) =
    let (r0,ss) = (HD ss, TL ss) in
    let r7 = r7 - 8w in
    let m = (r7 + 1w =+ r0) m in
    let r15 = r15 - 1w in
      if r15 <> 0w then
          x64_cons_loop (r7,r14,r15,dm,m,ss)
      else
        let r7 = r7 - 8w in
        let m = (r7 + 1w =+ r14) m in
        let r0 = r7 in
          (r0,r7,r14,r15,dm,m,ss)`

val (x64_cons_res, x64_cons_def, x64_cons_pre_def) = x64_compile `
  x64_cons (r0,r7,r14,dm,m,ss) =
    let r15 = r14 >>> 16 in
    let (r0,r7,r14,r15,dm,m,ss) = x64_cons_loop (r7,r14,r15,dm,m,ss) in
      (r0,r7,r14,r15,dm,m,ss)`

val blast_lemma = blast_align_lemma;

val LENGTH_APPEND_11 = prove(
  ``!xs xs1 ys ys1.
     (LENGTH xs = LENGTH xs1) ==>
     ((xs ++ ys = xs1 ++ ys1) <=> (xs = xs1) /\ (ys = ys1))``,
  Induct \\ Cases_on `xs1`  \\ SRW_TAC [] [] \\ METIS_TAC []);

val one_list_exists_1 = prove(
  ``one_list_exists a 1 = SEP_EXISTS x. one (a,x)``,
  ONCE_REWRITE_TAC [GSYM (EVAL ``SUC 0``)]
  \\ REWRITE_TAC [one_list_exists_SUC,one_list_exists_ZERO,SEP_CLAUSES]);

val one_list_exists_2 = prove(
  ``one_list_exists a 2 = SEP_EXISTS x1 x2. one (a,x1:word64) * one (a+8w,x2)``,
  SIMP_TAC std_ss [FUN_EQ_THM,one_list_exists_def,SEP_EXISTS_THM,cond_STAR]
  \\ `!xs. (LENGTH xs = 2) <=> ?x1 x2. xs = [x1;x2:word64]` by ALL_TAC THEN1
   (Cases \\ FULL_SIMP_TAC std_ss [LENGTH,NOT_CONS_NIL] \\ Cases_on `t`
    \\ FULL_SIMP_TAC std_ss [LENGTH,NOT_CONS_NIL,CONS_11,LENGTH_NIL])
  \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,one_list_def,SEP_CLAUSES]);

val one_list_exists_ADD = prove(
  ``!m a n. one_list_exists a (m + n) =
            one_list_exists a m * one_list_exists (a + n2w (8 * m)) n``,
  Induct \\ ASM_SIMP_TAC std_ss [one_list_exists_ZERO,SEP_CLAUSES,STAR_ASSOC,
      WORD_ADD_0,ADD_CLAUSES,one_list_exists_SUC,word_arith_lemma1,MULT_CLAUSES]);

val x64_cons_loop_thm = prove(
  ``!xs m r.
      (one_list_exists r7 (SUC (LENGTH xs)) * r) (fun2set (m,dm)) /\ xs <> [] /\
      LENGTH xs < dimword (:64) /\ (r7 && 7w = 0w) ==>
      ?m1. (x64_cons_loop_pre (r7 + n2w (LENGTH xs * 8 + 8) - 1w,r14,
                               n2w (LENGTH xs),dm,m,xs++ss)) /\
           (x64_cons_loop (r7 + n2w (LENGTH xs * 8 + 8) - 1w,r14,
                           n2w (LENGTH xs),dm,m,xs++ss) =
             (r7 - 1w,r7 - 1w,r14,0w,dm,m1,ss)) /\
           (one_list r7 (r14::REVERSE xs) * r) (fun2set (m1,dm))``,
  Induct \\ STRIP_TAC
  \\ SIMP_TAC std_ss [NOT_CONS_NIL]
  \\ SIMP_TAC std_ss [LENGTH,MULT_CLAUSES,LENGTH_SNOC]
  \\ NTAC 2 STRIP_TAC
  \\ ONCE_REWRITE_TAC [x64_cons_loop_def, x64_cons_loop_pre_def]
  \\ SIMP_TAC std_ss [LET_DEF,ADD1,GSYM word_add_n2w,WORD_ADD_SUB]
  \\ REPEAT STRIP_TAC
  \\ `LENGTH xs < dimword (:64)` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [n2w_11,ZERO_LT_dimword,LENGTH_NIL,HD,TL,
       APPEND,NOT_CONS_NIL]
  \\ Cases_on `xs = []` \\ FULL_SIMP_TAC std_ss [one_list_exists_2,LENGTH] THEN1
   (FULL_SIMP_TAC std_ss [SEP_EXISTS_THM,SEP_CLAUSES,one_list_def,SNOC_APPEND,
      APPEND,REVERSE_DEF,TL]
    \\ SIMP_TAC std_ss [GSYM WORD_SUB_PLUS,word_add_n2w]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SEP_R_TAC \\ SEP_W_TAC \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `0x7w && r7 = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  \\ FULL_SIMP_TAC std_ss [word_arith_lemma1]
  \\ SIMP_TAC std_ss [GSYM word_add_n2w,GSYM word_mul_n2w,WORD_ADD_ASSOC]
  \\ ONCE_REWRITE_TAC [word_arith_lemma3]
  \\ SIMP_TAC std_ss []
  \\ ONCE_REWRITE_TAC [word_arith_lemma4]
  \\ ASM_SIMP_TAC std_ss [blast_lemma]
  \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,WORD_ADD_ASSOC]
  \\ FULL_SIMP_TAC std_ss [word_arith_lemma4,GSYM word_mul_n2w]
  \\ SEP_I_TAC "x64_cons_loop"
  \\ FULL_SIMP_TAC std_ss [one_list_exists_ADD,one_list_exists_1,ADD1]
  \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES,LEFT_ADD_DISTRIB,word_add_n2w,
       word_mul_n2w,SEP_EXISTS_THM,word_arith_lemma1]
  \\ FULL_SIMP_TAC std_ss [AC MULT_ASSOC MULT_COMM,AC ADD_ASSOC ADD_COMM]
  \\ FULL_SIMP_TAC std_ss [PULL_EXISTS]
  \\ SEP_W_TAC \\ POP_ASSUM MP_TAC
  \\ POP_ASSUM (MP_TAC o Q.SPECL [`one (r7 + n2w (8 + LENGTH (xs:word64 list) * 8),h) * r`,`x'`])
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ FULL_SIMP_TAC std_ss [REVERSE_DEF,one_list_def,one_list_APPEND,SEP_CLAUSES]
  \\ FULL_SIMP_TAC std_ss [LENGTH_REVERSE,GSYM word_mul_n2w,GSYM word_add_n2w,
       AC WORD_ADD_COMM WORD_ADD_ASSOC, AC WORD_MULT_COMM WORD_MULT_ASSOC]
  \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ SEP_R_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ Q.PAT_ASSUM `r7 && 0x7w = 0x0w` MP_TAC
  \\ blastLib.BBLAST_TAC);

val heap_lookup_SPLIT = prove(
  ``!heap a x. (heap_lookup a heap = SOME x) ==>
               ?ys1 ys2. (heap = ys1 ++ [x] ++ ys2) /\ (a = heap_length ys1)``,
  Induct \\ SIMP_TAC std_ss [heap_lookup_def] \\ REPEAT STRIP_TAC
  \\ Cases_on `a = 0` \\ FULL_SIMP_TAC std_ss [] THEN1
   (Q.EXISTS_TAC `[]` \\ FULL_SIMP_TAC std_ss [APPEND,CONS_11] \\ EVAL_TAC
    \\ SIMP_TAC std_ss [SUM])
  \\ Cases_on `a < el_length h` \\ FULL_SIMP_TAC std_ss []
  \\ RES_TAC \\ Q.EXISTS_TAC `h::ys1` \\ FULL_SIMP_TAC (srw_ss()) [APPEND]
  \\ FULL_SIMP_TAC std_ss [heap_length_def,MAP,SUM] \\ DECIDE_TAC);

val x64_heap_heap_expand = prove(
  ``x64_heap a (heap_expand n) b b = one_list_exists a n``,
  Cases_on `n` \\ SIMP_TAC std_ss [x64_heap_def,heap_expand_def,SEP_CLAUSES,
     one_list_exists_def,LENGTH_NIL,one_list_def,ADD1,x64_el_def]);

val heap_length_heap_expand = prove(
  ``heap_length (heap_expand n) = n``,
  Cases_on `n` \\ SIMP_TAC std_ss [heap_length_def,ADD1,MAP] \\ EVAL_TAC
  \\ SIMP_TAC std_ss [SUM,MAP,el_length_def,SUM_ACC_DEF]);

val heap_store_unused_STAR = prove(
  ``(heap_store_unused a sp x heap1 = (heap2,T)) ==>
    ?frame.
      let addr = (b + n2w (8 * (a + sp)) - n2w (8 * el_length x)) in
        (x64_heap b heap1 b b = frame * one_list_exists addr (el_length x)) /\
        (x64_heap b heap2 b b = frame * x64_el addr x b b)``,
  SIMP_TAC std_ss [heap_store_unused_def]
  \\ Cases_on `(heap_lookup a heap1 = SOME (Unused (sp - 1)))`
  \\ Cases_on `el_length x <= sp` \\ FULL_SIMP_TAC std_ss [LET_DEF]
  \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
  \\ FULL_SIMP_TAC std_ss [heap_store_lemma]
  \\ Q.PAT_ASSUM `xxx = heap2` (ASSUME_TAC o GSYM)
  \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,SEP_CLAUSES]
  \\ FULL_SIMP_TAC std_ss [heap_length_APPEND,el_length_def,x64_el_def]
  \\ FULL_SIMP_TAC std_ss [x64_heap_heap_expand]
  \\ `sp - 1 + 1 = sp` by ALL_TAC THEN1
   (Cases_on `x` \\ FULL_SIMP_TAC std_ss [el_length_def] \\ DECIDE_TAC)
  \\ FULL_SIMP_TAC std_ss [heap_length_heap_expand]
  \\ `sp = ((sp - el_length x) + el_length x)` by DECIDE_TAC
  \\ POP_ASSUM (fn th => SIMP_TAC std_ss [Once th])
  \\ FULL_SIMP_TAC std_ss [one_list_exists_ADD]
  \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
  \\ `n2w (sp - el_length x) = n2w sp - n2w (el_length x):word64` by ALL_TAC THEN1
   (`~(sp < el_length x)` by DECIDE_TAC \\ ASM_SIMP_TAC std_ss [word_arith_lemma2])
  \\ FULL_SIMP_TAC std_ss [WORD_LEFT_SUB_DISTRIB,WORD_LEFT_ADD_DISTRIB]
  \\ Q.EXISTS_TAC `x64_heap b ys1 b b *
       one_list_exists (b + 0x8w * n2w (heap_length ys1)) (sp - el_length x) *
       x64_heap (b + (0x8w * n2w (heap_length ys1) + 0x8w * n2w sp)) ys2 b b`
  \\ FULL_SIMP_TAC (std_ss++star_ss) []
  \\ FULL_SIMP_TAC (srw_ss()) [STAR_ASSOC])
  |> SIMP_RULE std_ss [LET_DEF] |> GEN_ALL;

val cons_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x5,r5);(x2,r2);(x3,r3);(x4,r4)]`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM]

val cons_rev_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`(ZIP(xs,ys))`,`REVERSE (ZIP(xs,ys))`]
  |> DISCH ``LENGTH (xs:bc_value list) = LENGTH (ys:'a word heap_address list)``
  |> SIMP_RULE std_ss [rich_listTheory.MAP_REVERSE,MAP_FST_ZIP]
  |> SIMP_RULE std_ss [SUBSET_DEF,MEM_REVERSE]

val zHEAP_BIG_CONS = let
  val ((set_r14,_,_),_) = prog_x64Lib.x64_spec_memory64 "41BE"
  val lemma = prove(
    ``imm < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (imm)):word32)) MOD 4294967296)) =
       n2w (imm):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(imm) < 4294967296 /\ ~(2147483648 <= imm)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = set_r14 |> Q.INST [`rip`|->`p`,`imm32`|->`n2w (imm)`] |> RW [lemma]
  val th = th |> Q.INST [`imm`|->`w2n (imm64:word64)`] |> RW [n2w_w2n]
  val th = SPEC_COMPOSE_RULE [th,x64_cons_res]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
              |> UNDISCH
  val pc = get_pc th
  val inv = ``SOME (\(sp,vals:x64_vals). l+1 <= sp:num)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
            (imm64:word64 = n2w l << 16 + n2w (n MOD 2 ** 12) << 4) /\
            l <= LENGTH stack /\ l < 2 ** 15 /\ l <> 0 /\ n < 4096)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Block n (REVERSE (TAKE l stack)),x2,x3,x4,refs,
                                DROP l stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND])
    \\ `l <= LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_EQ_LENGTH
    \\ Q.MATCH_ASSUM_RENAME_TAC `stack = zs1 ++ zs2`
    \\ FULL_SIMP_TAC std_ss []
    \\ `abs_ml_inv (zs1 ++ ([x1; x2; x3; x4] ++ zs2)) refs
         (ys1 ++ ([r1; r2; r3; r4] ++ ys2),heap,a,sp) cs.heap_limit` by
     (FULL_SIMP_TAC std_ss [APPEND_ASSOC]
      \\ MATCH_MP_TAC (move_thm |> Q.SPECL [`[]`,`[]`] |> RW [APPEND,LENGTH])
      \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ `abs_ml_inv (REVERSE zs1 ++ ([x1; x2; x3; x4] ++ zs2)) refs
        (REVERSE ys1 ++ ([r1; r2; r3; r4] ++ ys2),heap,a,sp) cs.heap_limit` by
      (POP_ASSUM MP_TAC \\ MATCH_MP_TAC cons_rev_lemma \\ FULL_SIMP_TAC std_ss [])
    \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC) \\ STRIP_TAC
    \\ `l < sp` by DECIDE_TAC
    \\ MP_TAC (cons_thm |> Q.INST [`stack`|->`([x1; x2; x3; x4] ++ zs2)`,
         `roots`|->`REVERSE ys1 ++ ([r1; r2; r3; r4] ++ ys2)`,
         `l`|->`LENGTH (REVERSE (zs1:bc_value list))`,
         `xs`|->`(REVERSE zs1)`,`limit`|->`cs.heap_limit`,`tag`|->`n`]
             |> INST_TYPE [``:'a``|->``:63``,``:'b``|->``:64``])
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (ASM_SIMP_TAC std_ss [GSYM LENGTH_NIL,LENGTH_REVERSE] \\ DECIDE_TAC)
    \\ STRIP_TAC
    \\ `LENGTH (REVERSE zs1) = l` by FULL_SIMP_TAC std_ss [LENGTH_REVERSE]
    \\ FULL_SIMP_TAC std_ss [EVAL ``el_length (BlockRep n rs)``]
    \\ Q.ABBREV_TAC `header = n2w l << 16 + (n2w n << 4) : word64`
    \\ `(TAKE l (zs1 ++ zs2) = zs1) /\ (DROP l (zs1 ++ zs2) = zs2)` by ALL_TAC
    THEN1 METIS_TAC [rich_listTheory.TAKE_LENGTH_APPEND,
                     rich_listTheory.DROP_LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss []
    \\ `(rs = REVERSE ys1) /\ (roots2 = [r1; r2; r3; r4] ++ ys2)` by
          METIS_TAC [LENGTH_APPEND_11,LENGTH_REVERSE]
    \\ FULL_SIMP_TAC std_ss [LENGTH_REVERSE] \\ NTAC 4 (POP_ASSUM (K ALL_TAC))
    \\ `w2n header < 2147483648 /\ (header >>> 16 = n2w l)` by ALL_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_MUL_LSL,word_mul_n2w,word_add_n2w,w2n_n2w]
      \\ `(65536 * l + 16 * n) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ SIMP_TAC std_ss [GSYM w2n_11,w2n_lsr,w2n_n2w,EVAL ``dimword(:64)``]
      \\ `(65536 * l + 16 * n) < 18446744073709551616 /\
          l < 18446744073709551616` by DECIDE_TAC
      \\ ASM_SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [MULT_COMM]
      \\ MATCH_MP_TAC (DIV_MULT |> SIMP_RULE std_ss [PULL_FORALL])
      \\ DECIDE_TAC)
    \\ ONCE_REWRITE_TAC [x64_cons_def,x64_cons_pre_def]
    \\ FULL_SIMP_TAC std_ss [LET_DEF] \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ FULL_SIMP_TAC std_ss [LET_DEF]
    \\ IMP_RES_TAC heap_store_unused_STAR
    \\ POP_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `vs.current_heap`)
    \\ FULL_SIMP_TAC std_ss [EVAL ``el_length (BlockRep n ys1)``]
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND,GSYM APPEND_ASSOC,APPEND]
    \\ Q.ABBREV_TAC `ts1 = MAP (x64_addr vs.current_heap) ys1`
    \\ Q.ABBREV_TAC `ts2 = MAP (x64_addr vs.current_heap) ys2 ++
                           0x1w::cs.ret_address::cs.rest_of_stack`
    \\ Q.ABBREV_TAC `r7 = vs.current_heap + n2w (8 * (a + sp)) -
                          n2w (LENGTH ts1 * 8 + 8)`
    \\ `vs.current_heap + n2w (8 * (a + sp)) - 0x1w =
        r7 + n2w (LENGTH ts1 * 8 + 8) - 0x1w` by ALL_TAC
    THEN1 (UNABBREV_ALL_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD])
    \\ `l = LENGTH ts1` by METIS_TAC [LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss []
    \\ `(vs.current_heap + n2w (8 * (a + sp)) -
          n2w (8 * (LENGTH ts1 + 1))) = r7` by ALL_TAC
    THEN1 (UNABBREV_ALL_TAC \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB]
           \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC])
    \\ FULL_SIMP_TAC std_ss []
    \\ ASSUME_TAC (x64_cons_loop_thm |> GEN_ALL)
    \\ SEP_I_TAC "x64_cons_loop"
    \\ FULL_SIMP_TAC std_ss [ADD1,LENGTH_REVERSE] \\ SEP_F_TAC
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC std_ss [EVAL ``dimword (:64)``,GSYM LENGTH_NIL,LENGTH_MAP]
      \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ Q.PAT_ASSUM `heap_vars_ok vs`  MP_TAC
      \\ SIMP_TAC std_ss [GSYM MULT_CLAUSES]
      \\ SIMP_TAC std_ss [heap_vars_ok_def,GSYM word_mul_n2w,GSYM word_add_n2w]
      \\ FULL_SIMP_TAC std_ss [blast_lemma])
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := r7 - 1w ;
                                  reg7 := r7 - 1w ;
                                  reg14 := header ;
                                  reg15 := 0w ;
                                  memory := m1 ;
                                  stack := ts2 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [STAR_ASSOC]
    \\ SIMP_TAC (srw_ss()++star_ss) [] \\ STRIP_TAC \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`Pointer (a + sp - (LENGTH ys1 + 1))`,`r2`,`r3`,
        `r4`,`ys2`,`heap2`,`a`,`sp - (LENGTH ys1 + 1)`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def] \\ Q.UNABBREV_TAC `ts2`
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ STRIP_TAC THEN1
     (MATCH_MP_TAC (GEN_ALL cons_lemma)
      \\ Q.LIST_EXISTS_TAC [`x1`,`r1`]
      \\ Q.PAT_ASSUM `abs_ml_inv (Block n (REVERSE zs1)::x1::x2::x3::x4::zs2) refs
           (Pointer (a + sp - (LENGTH ys1 + 1))::r1::r2::r3::r4::ys2,
            heap2,a,sp - (LENGTH ys1 + 1)) cs.heap_limit` MP_TAC
      \\ FULL_SIMP_TAC std_ss [] \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [])
    \\ SIMP_TAC std_ss [CONJ_ASSOC] \\ STRIP_TAC THEN1
     (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [LENGTH_MAP,WORD_MUL_LSL]
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
      \\ `(n2w (sp - (LENGTH ys1 + 1)) = n2w sp - n2w (LENGTH ys1 + 1):word64) /\
          (n2w (a + sp - (LENGTH ys1 + 1)) =
           n2w (a + sp) - n2w (LENGTH ys1 + 1):word64)` by ALL_TAC THEN1
       (SIMP_TAC std_ss [word_arith_lemma2]
        \\ SRW_TAC [] [] \\ `F` by DECIDE_TAC)
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w]
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC,
                               AC WORD_MULT_COMM WORD_MULT_ASSOC])
    \\ `LENGTH ts1 < 281474976710656` by ALL_TAC THEN1
      (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [LENGTH_MAP] \\ DECIDE_TAC)
    \\ Q.UNABBREV_TAC `ts1`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_el_def,BlockRep_def,x64_payload_def,
         LET_DEF,one_list_def,cond_STAR,LENGTH_REVERSE]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [rich_listTheory.MAP_REVERSE])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [Once cond_CONJ,STAR_ASSOC] th
           |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th1 = zHEAP_ALLOC_CONS_SPACE |> Q.INST [`needed`|->`l+1`]
    |> CONV_RULE ((RATOR_CONV o RAND_CONV o RATOR_CONV) EVAL)
    |> SIMP_RULE std_ss [SEP_CLAUSES]
    |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th = SPEC_COMPOSE_RULE [th1,th]
  in th end;

(* cons instruction *)

val zHEAP_set_r14_before_alloc = let
  val th = compose_specs ["mov r14,r0","shl r14,1","add r14,8"]
  val pc = get_pc th
  val side = ``(x1 = Number (&l)) /\ l < 32768``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ^side)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val res_side = ``SOME (\(sp:num,vals). vals.reg14 = n2w (8 * (l + 1)))``
  val th = th |> Q.SPEC
    `zHEAP (cs,Number (&l),x2,x3,x4,refs,stack,s,^res_side) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    Q.SPEC_TAC (`x1`,`x1`) \\ fs []
    \\ FULL_SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals with reg14 := n2w (8 * (l + 1))`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ SIMP_TAC (srw_ss()++star_ss) [zVALS_def]
    \\ `small_int (&l)` by (EVAL_TAC \\ intLib.COOPER_TAC)
    \\ `vals.reg0 << 1 + 0x8w = n2w (8 * (l + 1))` by ALL_TAC THEN1
     (fs [heap_inv_def,x64_addr_def,abs_ml_inv_def,bc_stack_ref_inv_def,
          bc_value_inv_def]
      \\ simp[w2w_def,word_mul_n2w,WORD_MUL_LSL,word_add_n2w])
    \\ fs [] \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ fs [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (^side)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  in th end;

val set_r14_imm = let
  val ((set_r14,_,_),_) = prog_x64Lib.x64_spec_memory64 "41BE"
  val lemma = prove(
    ``imm < 2 ** 31 ==>
      ((n2w (SIGN_EXTEND 32 64 (w2n ((n2w (imm)):word32)) MOD 4294967296)) =
       n2w (imm):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(imm) < 4294967296 /\ ~(2147483648 <= imm)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = set_r14 |> Q.INST [`rip`|->`p`,`imm32`|->`n2w (imm)`] |> RW [lemma]
  (* val th = th |> Q.INST [`imm`|->`w2n (imm64:word64)`] |> RW [n2w_w2n] *)
  in th end;

val zHEAP_set_r14_after_alloc = let
  val th = compose_specs ["shl r14,4","mov r15,r0","shl r15,14","add r14,r15"]
  val th = SPEC_COMPOSE_RULE [set_r14_imm,th]
  val th = th |> Q.INST [`imm`|->`n`]
  val pc = get_pc th
  val side = ``(x1 = Number (&l)) /\ l < 32768 /\ (n:num) < 4096``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,
                      SOME (\(sp,vals). l + 1 <= sp)) vals /\
            ^side)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val res_side = ``SOME
           (\(sp,vals).
              l + 1 <= sp /\
              (vals.reg14 = n2w l << 16 + n2w (n MOD 2 ** 12) << 4))``
  val th = th |> Q.SPEC
    `zHEAP (cs,Number (&l),x2,x3,x4,refs,stack,s,^res_side) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    Q.SPEC_TAC (`x1`,`x1`) \\ fs []
    \\ FULL_SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| reg14 := n2w n << 4 + vals.reg0 << 14 ;
                                  reg15 := vals.reg0 << 14 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ SIMP_TAC (srw_ss()++star_ss) [zVALS_def]
    \\ `small_int (&l)` by (EVAL_TAC \\ intLib.COOPER_TAC)
    \\ `n2w n << 4 + vals.reg0 << 14 = n2w l << 16 + n2w n << 4` by ALL_TAC THEN1
     (fs [heap_inv_def,x64_addr_def,abs_ml_inv_def,bc_stack_ref_inv_def,
          bc_value_inv_def]
      \\ simp[w2w_def,word_mul_n2w,WORD_MUL_LSL,word_add_n2w])
    \\ fs [] \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ fs [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s,
             SOME (\(sp,vals). l + 1 <= sp)) * ~zS * zPC p *
      cond (^side)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  in th end;

val zHEAP_set_r14_after_ref_alloc = let
  val th = compose_specs ["mov r14,r0","shl r14,14","add r14,1"]
  val pc = get_pc th
  val side = ``(x1 = Number (&l)) /\ l < 32768``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,
                      SOME (\(sp,vals). l + 1 <= sp)) vals /\
            ^side)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA (DISCH T th)
  val res_side = ``SOME
           (\(sp,vals).
              l + 1 <= sp /\
              (vals.reg14 = n2w l << 16 + 1w))``
  val th = th |> Q.SPEC
    `zHEAP (cs,Number (&l),x2,x3,x4,refs,stack,s,^res_side) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    Q.SPEC_TAC (`x1`,`x1`) \\ fs []
    \\ FULL_SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [PULL_IMP_EXISTS,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| reg14 := vals.reg0 << 14 + 1w |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def]
    \\ POP_ASSUM (K ALL_TAC)
    \\ `small_int (&l)` by (EVAL_TAC \\ intLib.COOPER_TAC)
    \\ `vals.reg0 << 14 + 1w = n2w l << 16 + 1w` by ALL_TAC THEN1
     (fs [heap_inv_def,x64_addr_def,abs_ml_inv_def,bc_stack_ref_inv_def,
          bc_value_inv_def]
      \\ simp[w2w_def,word_mul_n2w,WORD_MUL_LSL,word_add_n2w])
    \\ fs [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s,
             SOME (\(sp,vals). l + 1 <= sp)) * ~zS * zPC p *
      cond (^side)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  in th end;

val zHEAP_LIMIT_X1_32768 = let
  val th0 = spec "cmp r0,131072"
  val ((th1,_,_),th2a) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jb 4")
  fun the (SOME x) = x | the _ = fail()
  val th2 = th2a |> the |> #1
  val thA = SPEC_COMPOSE_RULE [th0,th1]
  val thB = SPEC_COMPOSE_RULE [th0,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val thA = HIDE_STATUS_RULE true sts thA
  val thB = HIDE_STATUS_RULE true sts thB
  val thA = thA |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thB = thB |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val IF_COMPOSE_LEMMA = prove(
    ``SPEC m (p * cond b) c q1 /\ SPEC m (p * cond ~b) c q2 ==>
      SPEC m (p) c (if b then q1 else q2)``,
    Cases_on `b` \\ fs [SEP_CLAUSES]);
  val th = MATCH_MP IF_COMPOSE_LEMMA (CONJ thA thB)
  val th0 = spec "test r0,3"
  val ((th1,_,_),th2a) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jne 9")
  val th2 = th2a |> the |> #1
  val thA = SPEC_COMPOSE_RULE [th0,th1]
  val thB = SPEC_COMPOSE_RULE [th0,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val thA = HIDE_STATUS_RULE true sts thA
  val thB = HIDE_STATUS_RULE true sts thB
  val thA = thA |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thB = thB |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thB = SPEC_COMPOSE_RULE [thB,th]
  val IF_COMPOSE_SUBSET_LEMMA = prove(
    ``SPEC m (p * cond b) c q1 /\ SPEC m (p * cond ~b) c2 q2 ==>
      c2 SUBSET c ==>
      SPEC m (p) c (if b then q1 else q2)``,
    Cases_on `b` \\ fs [SEP_CLAUSES] \\ METIS_TAC [SPEC_SUBSET_CODE]);
  val if_if = METIS_PROVE [] ``(if b1 then (if b2 then x else y) else y) =
                               if b1 /\ b2 then x else y``
  val th = MATCH_MP IF_COMPOSE_SUBSET_LEMMA (CONJ thB thA)
             |> SIMP_RULE (std_ss++star_ss) [INSERT_SUBSET,
                 EMPTY_SUBSET,IN_INSERT,if_if] |> RW [STAR_ASSOC]
             |> Q.INST [`rip`|->`p`]
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            (x1 = Number (&l)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Number (&l),x2,x3,x4,refs,
                                stack,s,NONE) * ~zS * zPC (p + 0x12w)
                         \/
                         zHEAP (cs,Number (&l),x2,x3,x4,refs,
                                stack,s,NONE) * ~zS * zPC (p + 0x16w) *
                           precond (l < 32768)`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ Q.SPEC_TAC (`x1`,`x1`) \\ fs []
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals` \\ Q.EXISTS_TAC `vals`
    \\ fs [SEP_CLAUSES,precond_def,cond_STAR,SEP_DISJ_def]
    \\ REVERSE (Cases_on `(0x3w && vals.reg0 = 0x0w) /\
         vals.reg0 <+ 0x20000w` \\ fs [])
    \\ fs [zVALS_def] \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ DISJ2_TAC \\ Q.PAT_ASSUM `bbb s'` (K ALL_TAC)
    \\ fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def]
    \\ Cases_on `small_int (&l)` \\ fs [] THEN1
     (`(2 * l) < 9223372036854775808 /\
       (2 * (2 * l)) < 18446744073709551616` by
        (fs [small_int_def] \\ DECIDE_TAC)
      \\ rfs [x64_addr_def,word_mul_n2w,w2w_def,WORD_MUL_LSL]
      \\ fs [x64_addr_def,word_mul_n2w,w2w_def,WORD_MUL_LSL,WORD_LO]
      \\ DECIDE_TAC)
    \\ rfs [x64_addr_def,word_mul_n2w,w2w_def,WORD_MUL_LSL,heap_vars_ok_def]
    \\ fs [GSYM word_mul_n2w]
    \\ `F` by ALL_TAC \\ fs []
    \\ Q.PAT_ASSUM `xxx = 0x0w` MP_TAC
    \\ Q.PAT_ASSUM `0x7w && vs.current_heap = 0x0w` MP_TAC
    \\ fs [] \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond ((x1 = Number (&l)))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  val th = SPEC_COMPOSE_RULE [th,zHEAP_TERMINATE_WITH_ERROR]
           |> RW1 [SEP_DISJ_COMM]
  in th end;

val zHEAP_BIG_CONS_VAR_NONZERO_CASE = let
  val th = x64_cons_res
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH
  val pc = get_pc th
  val inv = ``SOME (\(sp,vals:x64_vals). (l+1 <= sp:num))``
  val inv2 = ``SOME (\(sp,vals:x64_vals). (l+1 <= sp:num) /\
                 (vals.reg14 = n2w l << 16 + n2w (n MOD 2 ** 12) << 4))``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
            (vals.reg14 = n2w l << 16 + n2w (n MOD 2 ** 12) << 4) /\
            l <= LENGTH stack /\ l < 2 ** 15 /\ l <> 0 /\ n < 4096)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,Block n (REVERSE (TAKE l stack)),x2,x3,x4,refs,
                                DROP l stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ `LENGTH roots = LENGTH stack` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def]
      \\ IMP_RES_TAC EVERY2_IMP_LENGTH \\ FULL_SIMP_TAC std_ss [LENGTH,APPEND])
    \\ `l <= LENGTH roots` by DECIDE_TAC
    \\ IMP_RES_TAC LESS_EQ_LENGTH
    \\ Q.MATCH_ASSUM_RENAME_TAC `stack = zs1 ++ zs2`
    \\ FULL_SIMP_TAC std_ss []
    \\ `abs_ml_inv (zs1 ++ ([x1; x2; x3; x4] ++ zs2)) refs
         (ys1 ++ ([r1; r2; r3; r4] ++ ys2),heap,a,sp) cs.heap_limit` by
     (FULL_SIMP_TAC std_ss [APPEND_ASSOC]
      \\ MATCH_MP_TAC (move_thm |> Q.SPECL [`[]`,`[]`] |> RW [APPEND,LENGTH])
      \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ `abs_ml_inv (REVERSE zs1 ++ ([x1; x2; x3; x4] ++ zs2)) refs
        (REVERSE ys1 ++ ([r1; r2; r3; r4] ++ ys2),heap,a,sp) cs.heap_limit` by
      (POP_ASSUM MP_TAC \\ MATCH_MP_TAC cons_rev_lemma \\ FULL_SIMP_TAC std_ss [])
    \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC) \\ STRIP_TAC
    \\ `l < sp` by DECIDE_TAC
    \\ MP_TAC (cons_thm |> Q.INST [`stack`|->`([x1; x2; x3; x4] ++ zs2)`,
         `roots`|->`REVERSE ys1 ++ ([r1; r2; r3; r4] ++ ys2)`,
         `l`|->`LENGTH (REVERSE (zs1:bc_value list))`,
         `xs`|->`(REVERSE zs1)`,`limit`|->`cs.heap_limit`,`tag`|->`n`]
             |> INST_TYPE [``:'a``|->``:63``,``:'b``|->``:64``])
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (ASM_SIMP_TAC std_ss [GSYM LENGTH_NIL,LENGTH_REVERSE] \\ DECIDE_TAC)
    \\ STRIP_TAC
    \\ `LENGTH (REVERSE zs1) = l` by FULL_SIMP_TAC std_ss [LENGTH_REVERSE]
    \\ FULL_SIMP_TAC std_ss [EVAL ``el_length (BlockRep n rs)``]
    \\ Q.ABBREV_TAC `header = n2w l << 16 + (n2w n << 4) : word64`
    \\ `(TAKE l (zs1 ++ zs2) = zs1) /\ (DROP l (zs1 ++ zs2) = zs2)` by ALL_TAC
    THEN1 METIS_TAC [rich_listTheory.TAKE_LENGTH_APPEND,
                     rich_listTheory.DROP_LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss []
    \\ `(rs = REVERSE ys1) /\ (roots2 = [r1; r2; r3; r4] ++ ys2)` by
          METIS_TAC [LENGTH_APPEND_11,LENGTH_REVERSE]
    \\ FULL_SIMP_TAC std_ss [LENGTH_REVERSE] \\ NTAC 4 (POP_ASSUM (K ALL_TAC))
    \\ `w2n header < 2147483648 /\ (header >>> 16 = n2w l)` by ALL_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_MUL_LSL,word_mul_n2w,word_add_n2w,w2n_n2w]
      \\ `(65536 * l + 16 * n) < 18446744073709551616` by DECIDE_TAC
      \\ FULL_SIMP_TAC std_ss []
      \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ SIMP_TAC std_ss [GSYM w2n_11,w2n_lsr,w2n_n2w,EVAL ``dimword(:64)``]
      \\ `(65536 * l + 16 * n) < 18446744073709551616 /\
          l < 18446744073709551616` by DECIDE_TAC
      \\ ASM_SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [MULT_COMM]
      \\ MATCH_MP_TAC (DIV_MULT |> SIMP_RULE std_ss [PULL_FORALL])
      \\ DECIDE_TAC)
    \\ ONCE_REWRITE_TAC [x64_cons_def,x64_cons_pre_def]
    \\ FULL_SIMP_TAC std_ss [LET_DEF] \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ FULL_SIMP_TAC std_ss [LET_DEF]
    \\ IMP_RES_TAC heap_store_unused_STAR
    \\ POP_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `vs.current_heap`)
    \\ FULL_SIMP_TAC std_ss [EVAL ``el_length (BlockRep n ys1)``]
    \\ FULL_SIMP_TAC std_ss [MAP_APPEND,GSYM APPEND_ASSOC,APPEND]
    \\ Q.ABBREV_TAC `ts1 = MAP (x64_addr vs.current_heap) ys1`
    \\ Q.ABBREV_TAC `ts2 = MAP (x64_addr vs.current_heap) ys2 ++
                           0x1w::cs.ret_address::cs.rest_of_stack`
    \\ Q.ABBREV_TAC `r7 = vs.current_heap + n2w (8 * (a + sp)) -
                          n2w (LENGTH ts1 * 8 + 8)`
    \\ `vs.current_heap + n2w (8 * (a + sp)) - 0x1w =
        r7 + n2w (LENGTH ts1 * 8 + 8) - 0x1w` by ALL_TAC
    THEN1 (UNABBREV_ALL_TAC \\ SIMP_TAC std_ss [WORD_SUB_ADD])
    \\ `l = LENGTH ts1` by METIS_TAC [LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss []
    \\ `(vs.current_heap + n2w (8 * (a + sp)) -
          n2w (8 * (LENGTH ts1 + 1))) = r7` by ALL_TAC
    THEN1 (UNABBREV_ALL_TAC \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB]
           \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC])
    \\ FULL_SIMP_TAC std_ss []
    \\ ASSUME_TAC (x64_cons_loop_thm |> GEN_ALL)
    \\ SEP_I_TAC "x64_cons_loop"
    \\ FULL_SIMP_TAC std_ss [ADD1,LENGTH_REVERSE] \\ SEP_F_TAC
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (UNABBREV_ALL_TAC
      \\ FULL_SIMP_TAC std_ss [EVAL ``dimword (:64)``,GSYM LENGTH_NIL,LENGTH_MAP]
      \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ Q.PAT_ASSUM `heap_vars_ok vs`  MP_TAC
      \\ SIMP_TAC std_ss [GSYM MULT_CLAUSES]
      \\ SIMP_TAC std_ss [heap_vars_ok_def,GSYM word_mul_n2w,GSYM word_add_n2w]
      \\ FULL_SIMP_TAC std_ss [blast_lemma])
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := r7 - 1w ;
                                  reg7 := r7 - 1w ;
                                  reg14 := header ;
                                  reg15 := 0w ;
                                  memory := m1 ;
                                  stack := ts2 |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [STAR_ASSOC]
    \\ SIMP_TAC (srw_ss()++star_ss) [] \\ STRIP_TAC \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`Pointer (a + sp - (LENGTH ys1 + 1))`,`r2`,`r3`,
        `r4`,`ys2`,`heap2`,`a`,`sp - (LENGTH ys1 + 1)`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def] \\ Q.UNABBREV_TAC `ts2`
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ STRIP_TAC THEN1
     (MATCH_MP_TAC (GEN_ALL cons_lemma)
      \\ Q.LIST_EXISTS_TAC [`x1`,`r1`]
      \\ Q.PAT_ASSUM `abs_ml_inv (Block n (REVERSE zs1)::x1::x2::x3::x4::zs2) refs
           (Pointer (a + sp - (LENGTH ys1 + 1))::r1::r2::r3::r4::ys2,
            heap2,a,sp - (LENGTH ys1 + 1)) cs.heap_limit` MP_TAC
      \\ FULL_SIMP_TAC std_ss [] \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [])
    \\ SIMP_TAC std_ss [CONJ_ASSOC] \\ STRIP_TAC THEN1
     (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [LENGTH_MAP,WORD_MUL_LSL]
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
      \\ `(n2w (sp - (LENGTH ys1 + 1)) = n2w sp - n2w (LENGTH ys1 + 1):word64) /\
          (n2w (a + sp - (LENGTH ys1 + 1)) =
           n2w (a + sp) - n2w (LENGTH ys1 + 1):word64)` by ALL_TAC THEN1
       (SIMP_TAC std_ss [word_arith_lemma2]
        \\ SRW_TAC [] [] \\ `F` by DECIDE_TAC)
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w]
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC,
                               AC WORD_MULT_COMM WORD_MULT_ASSOC])
    \\ `LENGTH ts1 < 281474976710656` by ALL_TAC THEN1
      (UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss [LENGTH_MAP] \\ DECIDE_TAC)
    \\ Q.UNABBREV_TAC `ts1`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_el_def,BlockRep_def,x64_payload_def,
         LET_DEF,one_list_def,cond_STAR,LENGTH_REVERSE]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [rich_listTheory.MAP_REVERSE])
  val th = MP th lemma
  val lemma = prove(
    ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
       (vals.reg14 = n2w l << 16 + n2w (n MOD 2 ** 12) << 4) /\
      l <= LENGTH stack /\ l < 2 ** 15 /\ l <> 0 /\ n < 4096 <=>
      heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv2) vals /\
      l <= LENGTH stack /\ l < 2 ** 15 /\ l <> 0 /\ n < 4096``,
    fs [heap_inv_def] \\ REPEAT STRIP_TAC \\ fs [] \\ METIS_TAC []);
  val th = RW [lemma] th
  val th = SIMP_RULE std_ss [Once cond_CONJ,STAR_ASSOC] th
           |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv2) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th1 = zHEAP_ALLOC |> Q.INST [`needed`|->`l+1`]
    |> CONV_RULE ((RATOR_CONV o RAND_CONV o RATOR_CONV) EVAL)
    |> SIMP_RULE std_ss [SEP_CLAUSES]
    |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th1 = SPEC_COMPOSE_RULE [zHEAP_set_r14_before_alloc,th1]
  val th1 = SPEC_COMPOSE_RULE [th1,zHEAP_set_r14_after_alloc]
  val th = SPEC_COMPOSE_RULE [th1,th |> Q.INST [`x1`|->`Number (&l)`]
                                     |> SIMP_RULE (srw_ss()) []]
  val lemma = prove(``(l < 32768 ==> (l:num) + 1 < 17179869184 ==> b) ==>
                      (l < 32768 ==> b)``,
                    Cases_on `b` \\ fs [] \\ DECIDE_TAC);
  val th = th |> RW [SPEC_MOVE_COND,GSYM AND_IMP_INTRO]
              |> Q.GEN `x1` |> SIMP_RULE std_ss [] |> UNDISCH_ALL
              |> DISCH ``l + (1:num) < 17179869184``
              |> DISCH ``l < 32768:num``
              |> MATCH_MP lemma |> RW [GSYM SPEC_MOVE_COND]
  val th = th |> RW [GSYM precond_def]
  val th1 = zHEAP_LIMIT_X1_32768
  val th = SPEC_COMPOSE_RULE [th1,th]
  val th = th |> RW [SPEC_MOVE_COND] |> Q.GEN `x1` |> SIMP_RULE std_ss []
  val th = SPEC_COMPOSE_RULE [th,compose_specs ["jmp 5"]]
  in th end;

val zHEAP_BIG_CONS_VAR = let
  val th = zHEAP_BIG_CONS_VAR_NONZERO_CASE
  val str = get_pc th |> rand |> rand |> rand
              |> numSyntax.int_of_term |> (fn i => i-5) |> int_to_string
  val th0 = zHEAP_1EQ0
  val ((th1,_,_),th2a) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode ("je " ^ str))
  fun the (SOME x) = x | the _ = fail()
  val th2 = th2a |> the |> #1
  val thA = SPEC_COMPOSE_RULE [th0,th1]
  val thB = SPEC_COMPOSE_RULE [th0,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val thA = HIDE_STATUS_RULE true sts thA
  val thB = HIDE_STATUS_RULE true sts thB
  val thA = thA |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thB = thB |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thA = thA |> Q.INST [`x1`|->`Number (&l)`] |> RW [getNumber_def,isNumber_def]
  val thB = thB |> Q.INST [`x1`|->`Number (&l)`] |> RW [getNumber_def,isNumber_def]
  val thB = SPEC_COMPOSE_RULE [thB,zHEAP_BIG_CONS_VAR_NONZERO_CASE]
  val lemma = prove(``((&l = 0) <=> (l = 0)) /\ ~(&l < 0)``,intLib.COOPER_TAC)
  val thA = thA |> RW [lemma]
  val thB = thB |> RW [lemma]
  val thA = SPEC_COMPOSE_RULE [thA,zHEAP_Nil |> Q.INST [`k`|->`n`]]
  val thA = thA |> RW1 [SPEC_MOVE_COND] |> UNDISCH_ALL
  val thB = thB |> DISCH ``l <> 0:num`` |> SIMP_RULE std_ss [SEP_CLAUSES]
                |> RW1 [GSYM SPEC_MOVE_COND]
  val IF_COMPOSE_UNION_LEMMA = prove(
    ``SPEC m (p * cond b) c q1 /\ SPEC m (p * cond ~b) c2 q2 ==>
      SPEC m (p) (c UNION c2) (if b then q1 else q2)``,
    Cases_on `b` \\ fs [SEP_CLAUSES] \\ METIS_TAC [SPEC_ADD_CODE,UNION_COMM]);
  val th = MATCH_MP IF_COMPOSE_UNION_LEMMA (CONJ thA thB)
  val q = thB |> concl |> rand
  val (th,goal) = SPEC_WEAKEN_RULE th q
  val lemma = prove(goal,
    SRW_TAC [] []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [SEP_IMP_def,SEP_DISJ_def])
  val th = MP th lemma
  val lemma = prove(``(n < 4096:num ==> 4 * n + 2 < 2147483648 ==> b) ==>
                      (n < 4096:num ==> b)``,
                    Cases_on `b` \\ fs [] \\ DECIDE_TAC);
  val th = th |> DISCH ``4 * n + 2 < 2147483648:num``
              |> DISCH ``n < 4096:num`` |> MATCH_MP lemma
  val th = th |> UNDISCH_ALL
  in th end;

(* new ref *)

val (x64_ref_loop_res, x64_ref_loop_def, x64_ref_loop_pre_def) = x64_compile `
  x64_ref_loop (r1,r7,r14:word64,r15:word64,dm:word64 set,m:word64->word64) =
      if r15 <> 0w then
        let r15 = r15 - 1w in
        let r7 = r7 - 8w in
        let m = (r7 + 1w =+ r1) m in
          x64_ref_loop (r1,r7,r14,r15,dm,m)
      else
        let r7 = r7 - 8w in
        let m = (r7 + 1w =+ r14) m in
          (r1,r7,r14,r15,dm,m)`

val (x64_ref_fun_res, x64_ref_fun_def, x64_ref_fun_pre_def) = x64_compile `
  x64_ref_fun (r0,r1,r7,r14,dm,m) =
    let r15 = r14 >>> 16 in
    let (r1,r7,r14,r15,dm,m) = x64_ref_loop (r1,r7,r14,r15,dm,m) in
    let r0 = r7 in
      (r0,r1,r7,r14,r15,dm,m)`

val MAP_REPLICATE = prove(
  ``!n x f. MAP f (REPLICATE n x) = REPLICATE n (f x)``,
  Induct \\ fs [rich_listTheory.REPLICATE]);

val REPLICATE_ADD = prove(
  ``!m n x. REPLICATE (m+n) x = REPLICATE m x ++ REPLICATE n x``,
  Induct \\ fs [rich_listTheory.REPLICATE,ADD]);

val x64_ref_loop_thm = prove(
  ``!l m r.
      (one_list_exists r7 (SUC l) * r) (fun2set (m,dm)) /\
      l < dimword (:64) /\ (r7 && 7w = 0w) ==>
      ?m1. (x64_ref_loop_pre (r1,r7 + n2w (l * 8 + 8) - 1w,r14,n2w l,dm,m)) /\
           (x64_ref_loop (r1,r7 + n2w (l * 8 + 8) - 1w,r14,n2w l,dm,m) =
             (r1,r7 - 1w,r14,0w,dm,m1)) /\
           (one_list r7 (r14::REPLICATE l r1) * r) (fun2set (m1,dm))``,
  Induct \\ STRIP_TAC
  \\ SIMP_TAC std_ss [Once x64_ref_loop_def, Once x64_ref_loop_pre_def]
  THEN1
   (FULL_SIMP_TAC std_ss [LET_DEF] \\ fs []
    \\ fs [rich_listTheory.REPLICATE,one_list_def,SEP_CLAUSES,one_list_exists_1]
    \\ fs [SEP_EXISTS_THM] \\ REPEAT STRIP_TAC \\ SEP_R_TAC \\ SEP_W_TAC)
  \\ FULL_SIMP_TAC std_ss [n2w_11,ZERO_LT_dimword]
  \\ ASM_SIMP_TAC std_ss [ADD1,GSYM word_add_n2w,WORD_ADD_SUB]
  \\ `r7 + (n2w ((l + 1) * 8) + 0x8w) - 0x1w - 0x8w =
      r7 + (n2w (l * 8) + 0x8w) - 0x1w` by ALL_TAC THEN1
    (FULL_SIMP_TAC std_ss [RIGHT_ADD_DISTRIB,GSYM word_add_n2w] \\ fs [])
  \\ FULL_SIMP_TAC std_ss [LET_DEF,WORD_SUB_ADD]
  \\ ONCE_REWRITE_TAC [one_list_exists_ADD]
  \\ ASM_SIMP_TAC std_ss [one_list_exists_1,GSYM ADD1]
  \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES,SEP_EXISTS_THM]
  \\ REPEAT STRIP_TAC
  \\ `(one_list_exists r7 (SUC l) * one (r7 + n2w (8 * SUC l),r1) * r)
        (fun2set ((r7 + n2w (8 * SUC l) =+ r1) m,dm))` by SEP_WRITE_TAC
  \\ SEP_F_TAC
  \\ `l < dimword (:64)` by DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss []
  \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [word_add_n2w,MULT_CLAUSES,AC ADD_COMM ADD_ASSOC,
       AC MULT_COMM MULT_ASSOC] \\ SEP_R_TAC
  \\ FULL_SIMP_TAC std_ss [REPLICATE_ADD,ADD1]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND,EVAL ``REPLICATE 1 r1``,one_list_APPEND]
  \\ FULL_SIMP_TAC std_ss [LENGTH,rich_listTheory.LENGTH_REPLICATE,MULT_CLAUSES]
  \\ FULL_SIMP_TAC (std_ss++star_ss) [word_add_n2w,MULT_CLAUSES,AC ADD_COMM ADD_ASSOC,
       AC MULT_COMM MULT_ASSOC,one_list_def,SEP_CLAUSES]
  \\ Q.PAT_ASSUM `r7 && 0x7w = 0x0w` MP_TAC
  \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w, GSYM word_mul_n2w]
  \\ blastLib.BBLAST_TAC);

val PULL_EXISTS_IMP = METIS_PROVE [] ``(p ==> ?x. Q x) <=> (?x. p ==> Q x)``;

val new_ref_blast = blastLib.BBLAST_PROVE
  ``((w + 8w * v) && 7w = w && 7w) /\
    ((w - 8w * v) && 7w = w && 7w:word64)``

val zHEAP_NEW_REF = let
  val th = x64_ref_fun_res
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH
  val pc = get_pc th
  val inv = ``SOME (\(sp,vals:x64_vals). (l+1 <= sp:num))``
  val inv2 = ``SOME (\(sp,vals:x64_vals). (l+1 <= sp:num) /\
                 (vals.reg14 = n2w l << 16 + 1w))``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
            (vals.reg14 = n2w l << 16 + 1w) /\ l < 2 ** 15 /\
            ~(ptr IN FDOM refs))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,RefPtr ptr,x2,x3,x4,
                                refs |+ (ptr,ValueArray (REPLICATE l x2)),
                                stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [CONJ_ASSOC] \\ STRIP_TAC
    \\ fs [x64_ref_fun_def,x64_ref_fun_pre_def,LET_DEF]
    \\ `(n2w l << 16 + 0x1w) >>> 16 = (n2w l):word64` by ALL_TAC THEN1
     (`l < 18446744073709551616` by DECIDE_TAC
      \\ `n2w l <+ 32768w:word64` by fs [WORD_LO]
      \\ POP_ASSUM MP_TAC \\ fs [] \\ blastLib.BBLAST_TAC) \\ fs []
    \\ `?r1' r7' r14' r15' dm' m'.
          x64_ref_loop
               (vals.reg1,vals.reg7,n2w l << 16 + 0x1w,
                n2w l,vals.memory_domain,
                vals.memory) = (r1',r7',r14',r15',dm',m')` by METIS_TAC [PAIR]
    \\ fs [PULL_FORALL] \\ STRIP_TAC
    \\ fs [PULL_EXISTS_IMP,PULL_EXISTS]
    \\ Q.EXISTS_TAC `vals with <| reg0  := r7';
                                  reg1  := r1';
                                  reg7  := r7';
                                  reg14  := r14';
                                  reg15  := r15';
                                  memory := m' ;
                                  memory_domain := dm' |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC (METIS_PROVE [] ``b1 /\ b3 ==> (b1 /\ (b2 ==> b3))``)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def,PULL_EXISTS]
    \\ IMP_RES_TAC new_ref_replicate_thm
    \\ fs [] \\ SRW_TAC [] []
    \\ NTAC 6 (POP_ASSUM (K ALL_TAC))
    \\ Q.LIST_EXISTS_TAC [`vs`,`Pointer (a + sp - (l+1))`,`r2`,`r3`,`r4`,
         `roots`,`heap2`,`a`,`sp-(l+1)`] \\ FULL_SIMP_TAC std_ss []
    \\ fs [x64_addr_def]
    \\ IMP_RES_TAC heap_store_unused_STAR
    \\ POP_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `vs.current_heap`)
    \\ FULL_SIMP_TAC std_ss [EVAL ``el_length (RefBlock r1)``]
    \\ FULL_SIMP_TAC std_ss
         [x64_addr_def,WORD_MUL_LSL,GSYM word_add_n2w,word_arith_lemma2]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [x64_el_def,RefBlock_def,x64_payload_def,
          rich_listTheory.LENGTH_REPLICATE,LET_DEF]
    \\ `l < 281474976710656` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ Q.ABBREV_TAC `tw = vs.current_heap + 0x8w * (n2w a + n2w sp) -
                            0x8w * (n2w l + 0x1w)`
    \\ Q.PAT_ASSUM `vals.reg1 = x64_addr vs.current_heap r2` (ASSUME_TAC o GSYM)
    \\ `vals.reg7 = tw + n2w (l * 8 + 8) - 0x1w` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [Abbr`tw`,WORD_LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,GSYM word_mul_n2w]
      \\ fs [] \\ blastLib.BBLAST_TAC)
    \\ `tw && 0x7w = 0x0w` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [Abbr`tw`,WORD_LEFT_ADD_DISTRIB]
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def,new_ref_blast,
           WORD_SUB_PLUS,WORD_ADD_ASSOC])
    \\ `l < dimword (:64)` by (EVAL_TAC \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [MAP_REPLICATE]
    \\ ASSUME_TAC (RW [ADD1] (GEN_ALL x64_ref_loop_thm))
    \\ Q.PAT_ASSUM `x64_ref_loop xx = yy` MP_TAC
    \\ SEP_I_TAC "x64_ref_loop"
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ SEP_F_TAC \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE (REPEAT STRIP_TAC)
    \\ FULL_SIMP_TAC (std_ss++star_ss) [one_list_def,WORD_MUL_LSL]
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w,LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
    \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w]
    \\ Q.UNABBREV_TAC `tw`
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w,word_add_n2w,LEFT_ADD_DISTRIB]
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w,LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
    \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w]
    \\ `n2w (8 * sp - (8 * l + 8)) = n2w (8 * sp) - n2w (8 * l + 8):word64` by
     (fs [word_arith_lemma2] \\ SRW_TAC [] [] \\ `F` by DECIDE_TAC)
    \\ `n2w (8 * a + 8 * sp - (8 * l + 8)) =
        n2w (8 * a + 8 * sp) - n2w (8 * l + 8):word64` by
     (fs [word_arith_lemma2] \\ SRW_TAC [] [] \\ `F` by DECIDE_TAC)
    \\ ASM_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w] \\ fs [])
  val th = MP th lemma
  val lemma = prove(
    ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
       (vals.reg14 = n2w l << 16 + 1w) /\ l < 2 ** 15 /\
           ptr NOTIN FDOM refs <=>
      heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv2) vals /\
      l < 32768 /\ ptr NOTIN FDOM refs``,
    fs [heap_inv_def] \\ REPEAT STRIP_TAC \\ fs [] \\ METIS_TAC []);
  val th = RW [lemma] th
  val th = SIMP_RULE std_ss [Once cond_CONJ,STAR_ASSOC] th
           |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv2) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th1 = zHEAP_ALLOC |> Q.INST [`needed`|->`l+1`]
    |> CONV_RULE ((RATOR_CONV o RAND_CONV o RATOR_CONV) EVAL)
    |> SIMP_RULE std_ss [SEP_CLAUSES]
    |> RW1 [SPEC_MOVE_COND] |> UNDISCH
  val th1 = SPEC_COMPOSE_RULE [zHEAP_set_r14_before_alloc,th1]
  val th1 = SPEC_COMPOSE_RULE [th1,zHEAP_set_r14_after_ref_alloc]
  val th = SPEC_COMPOSE_RULE [th1,th |> Q.INST [`x1`|->`Number (&l)`]
                                     |> SIMP_RULE (srw_ss()) []]
  val lemma = prove(``(l < 32768 ==> (l:num) + 1 < 17179869184 ==> b) ==>
                      (l < 32768 ==> b)``,
                    Cases_on `b` \\ fs [] \\ DECIDE_TAC);
  val th = th |> RW [SPEC_MOVE_COND,GSYM AND_IMP_INTRO]
              |> Q.GEN `x1` |> SIMP_RULE std_ss [] |> UNDISCH_ALL
              |> DISCH ``l + (1:num) < 17179869184``
              |> DISCH ``l < 32768:num``
              |> MATCH_MP lemma |> RW [GSYM SPEC_MOVE_COND]
  val th = th |> RW [GSYM precond_def]
  val th1 = zHEAP_LIMIT_X1_32768
  val th = SPEC_COMPOSE_RULE [th1,th]
  val th = th |> DISCH_ALL |> DISCH ``Number (&l) = x1``
              |> SIMP_RULE std_ss [SEP_CLAUSES]
              |> RW [GSYM SPEC_MOVE_COND]
  in th end;

(* deref *)

val zHEAP_DEREF = let
  val th = compose_specs ["mov r0,[r1+2*r0+9]"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isRefPtr x2 /\ isNumber x1 /\ 0 <= getNumber x1 /\
            isValueArray (refs ' (getRefPtr x2)) /\
            getNumber x1 < & LENGTH (getValueArray (refs ' (getRefPtr x2))))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,EL (Num (getNumber x1)) (getValueArray (refs ' (getRefPtr x2))),x2,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  (* gg goal *)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isRefPtr_def,APPEND,getRefPtr_def]
    \\ Cases_on `x1` \\ FULL_SIMP_TAC std_ss [isNumber_def,APPEND,getNumber_def]
    \\ Cases_on `refs ' n` \\ FULL_SIMP_TAC std_ss [isValueArray_def,getValueArray_def]
    \\ Cases_on `l = []` \\ FULL_SIMP_TAC std_ss []
    THEN1 (FULL_SIMP_TAC std_ss [LENGTH] \\ `F` by intLib.COOPER_TAC)
    \\ `Num i < LENGTH l` by intLib.COOPER_TAC
    \\ `abs_ml_inv (RefPtr n::Number i::x3::x4::stack) refs
         (r2::r1::r3::r4::roots,heap,a,sp) cs.heap_limit` by
       (MATCH_MP_TAC el_lemma2 \\ fs [] \\ REPEAT STRIP_TAC \\ fs [])
    \\ IMP_RES_TAC deref_thm
    \\ pop_assum mp_tac >> simp[]
    \\ disch_then (Q.SPEC_THEN`Num i`STRIP_ASSUME_TAC)
    \\ REV_FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `heap_el r (Num i) heap = (y,T)` (ASSUME_TAC o GSYM)
    \\ Q.PAT_ASSUM `r1::r2::r3::r4::roots = r::roots2` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [CONS_11]
    \\ `?f. (r2 = Pointer (f ' n)) /\ bc_ref_inv n refs (f,heap)` by ALL_TAC THEN1
      (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
        bc_value_inv_def] \\ Q.LIST_EXISTS_TAC [`f`]
      \\ ASM_SIMP_TAC std_ss []
      \\ `reachable_refs (Number i::RefPtr n::x3::x4::stack) refs n` by ALL_TAC THEN1
       (FULL_SIMP_TAC std_ss [reachable_refs_def,MEM]
        \\ Q.LIST_EXISTS_TAC [`RefPtr n`,`n`]
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ RES_TAC \\ fs[])
    \\ fs[bc_ref_inv_def,heap_el_def,FLOOKUP_DEF]
    \\ Cases_on`n IN FDOM f` \\ fs[]
    \\ Cases_on`n IN FDOM refs` \\ fs[]
    \\ Cases_on`refs ' n` \\ fs[RefBlock_def] \\ fs[]
    \\ Cases_on`Num i < LENGTH zs` \\ fs[]
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL]
    \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,WORD_SUB_ADD]
    \\ `r1 = Data (2w * n2w (Num i))` by ALL_TAC THEN1
     (`small_int i /\ ~(i < 0)` by ALL_TAC THEN1
        (rw[] >> FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
            bc_value_inv_def])
    \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ `(2 * Num i) < 9223372036854775808` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ IMP_RES_TAC LESS_LENGTH \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ Q.MATCH_ASSUM_RENAME_TAC `xs = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,one_list_APPEND,one_list_def,
         LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,AC WORD_ADD_COMM WORD_ADD_ASSOC,
         AC WORD_MULT_ASSOC WORD_MULT_COMM]
    \\ SEP_R_TAC \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [WORD_AND_COMM]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def])
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg0 := x64_addr vs.current_heap z |>`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`z`,`r2`,`r3`,`r4`,`roots`,
                          `heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ STRIP_TAC THEN1
     (Q.PAT_ASSUM `abs_ml_inv xx yy zz tt` MP_TAC
      \\ `EL (Num i) (zs1 ++ z::zs2) = z` by METIS_TAC [EL_LENGTH]
      \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ REPEAT STRIP_TAC
      \\ MATCH_MP_TAC el_lemma1
      \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_APPEND]
    \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC]
    \\ STRIP_TAC THEN1
      (FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w,word_mul_n2w,MULT_ASSOC])
    \\ Q.PAT_ASSUM `xxx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
    \\ NTAC 2 (FULL_SIMP_TAC (srw_ss()++star_ss) [one_list_APPEND,one_list_def]
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC,SEP_CLAUSES,APPEND,GSYM APPEND_ASSOC]
      \\ FULL_SIMP_TAC std_ss [word_add_n2w,word_mul_n2w,LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,LEFT_ADD_DISTRIB,heap_length_APPEND,
           AC WORD_ADD_ASSOC WORD_ADD_COMM,word_mul_n2w,AC MULT_COMM MULT_ASSOC,
           heap_length_def]))
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (isRefPtr x2 /\ isNumber x1 /\ 0 <= getNumber x1 /\
            isValueArray (refs ' (getRefPtr x2)) /\
            getNumber x1 < & LENGTH (getValueArray (refs ' (getRefPtr x2))))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  in th end;

(* update ref *)

val zHEAP_UPDATE_REF = let
  val th = compose_specs ["mov [r2+2*r1+9],r0"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isRefPtr x3 /\ isNumber x2 /\ 0 <= getNumber x2 /\
            isValueArray (refs ' (getRefPtr x3)) /\
            getNumber x2 < & LENGTH (getValueArray (refs ' (getRefPtr x3))))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,x1,x2,x3,x4,
            refs |+ (getRefPtr x3,
                     ValueArray (LUPDATE x1 (Num (getNumber x2))
                                         (getValueArray (refs ' (getRefPtr x3))))),
            stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  (*
    gg goal
  *)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ Cases_on `x3` \\ FULL_SIMP_TAC std_ss [isRefPtr_def,getRefPtr_def,APPEND]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isNumber_def,getNumber_def]
    \\ Cases_on `refs ' n` \\ FULL_SIMP_TAC std_ss [getValueArray_def,isValueArray_def]
    \\ `x1::Number i::RefPtr n::x4::stack = [x1;Number i] ++ RefPtr n::(x4::stack)` by simp[]
    \\ FULL_SIMP_TAC std_ss [] \\ pop_assum kall_tac
    \\ first_assum(assume_tac o MATCH_MP (GEN_ALL(REWRITE_RULE[GSYM AND_IMP_INTRO] update_ref_thm1)))
    \\ `?f. (r3 = Pointer (f ' n)) /\ bc_ref_inv n refs (f,heap)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
           bc_value_inv_def] \\ Q.LIST_EXISTS_TAC [`f`]
      \\ `reachable_refs ([x1;Number i]++RefPtr n::x4::stack) refs n` by ALL_TAC THEN1
       (FULL_SIMP_TAC std_ss [reachable_refs_def,MEM,MEM_APPEND]
        \\ Q.LIST_EXISTS_TAC [`RefPtr n`,`n`]
        \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM,RTC_REFL])
      \\ RES_TAC
      \\ fs[LIST_REL_EL_EQN,bc_value_inv_def])
    \\ `FLOOKUP refs n = SOME (ValueArray l)` by (
          fs[bc_ref_inv_def,FLOOKUP_DEF] >>
          BasicProvers.EVERY_CASE_TAC >> fs[] )
    \\ first_x_assum(qspecl_then[`l`,`Num i`]mp_tac)
    \\ `Num i < LENGTH l` by intLib.COOPER_TAC
    \\ ASM_SIMP_TAC std_ss [LENGTH] \\ strip_tac
    \\ Q.PAT_ASSUM `rrroots = rs ++ Pointer p'::roots2` (ASSUME_TAC o GSYM)
    \\ Cases_on`rs` \\ FULL_SIMP_TAC std_ss [LENGTH]
    \\ Cases_on`t` \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_NIL]
    \\ REV_FULL_SIMP_TAC std_ss [heap_deref_def,CONS_11,APPEND]
    \\ FULL_SIMP_TAC std_ss [bc_ref_inv_def]
    \\ Cases_on`FLOOKUP f n` >> fs[]
    \\ `FLOOKUP f n = SOME (f ' n)` by fs[FLOOKUP_DEF]
    \\ fs[] >> rfs[]
    \\ fs[RefBlock_def]
    \\ `LENGTH l = LENGTH vs1` by (IMP_RES_TAC LIST_REL_LENGTH >> rw[])
    \\ `Num i < LENGTH zs` by fs[]
    \\ IMP_RES_TAC heap_lookup_SPLIT
    \\ qmatch_assum_abbrev_tac`heap = ys1 ++ [z] ++ ys2`
    \\ `heap = ys1 ++ z::ys2` by simp[]
    \\ qpat_assum`heap = ys1 ++ [z] ++ ys2`kall_tac
    \\ FULL_SIMP_TAC std_ss [Abbr`z`,heap_store_lemma]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL]
    \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,WORD_SUB_ADD]
    \\ `r2 = Data (2w * n2w (Num i))` by ALL_TAC THEN1
     (`small_int i /\ ~(i < 0)` by ALL_TAC THEN1
        (rw[] >> FULL_SIMP_TAC std_ss [small_int_def] \\ intLib.COOPER_TAC)
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def,
            bc_value_inv_def])
    \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w]
    \\ `(2 * Num i) < 9223372036854775808` by DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ IMP_RES_TAC LESS_LENGTH \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ Q.MATCH_ASSUM_RENAME_TAC `xs = zs1 ++ z::zs2`
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,one_list_APPEND,one_list_def,
         LENGTH_MAP]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,AC WORD_ADD_COMM WORD_ADD_ASSOC,
         AC WORD_MULT_ASSOC WORD_MULT_COMM]
    \\ STRIP_TAC THEN1
     (SIMP_TAC std_ss [] \\ ONCE_REWRITE_TAC [WORD_AND_COMM]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,blast_align_lemma]
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def]
      \\ qpat_assum`(xx * yy) ss`mp_tac
      \\ rpt BasicProvers.VAR_EQ_TAC
      \\ simp[one_list_APPEND,one_list_def]
      \\ SIMP_TAC std_ss [AC WORD_ADD_ASSOC WORD_ADD_COMM,word_add_n2w,word_mul_n2w]
      \\ STRIP_TAC \\ SEP_R_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.ABBREV_TAC `addr = (vs.current_heap + (0x8w + (n2w (Num i) * 0x8w
                             + n2w (heap_length ys1) * 0x8w)))`
    \\ Q.EXISTS_TAC `vals with <| memory :=
         (addr =+ x64_addr vs.current_heap r1) vals.memory |>`
    \\ Q.UNABBREV_TAC `addr`
    \\ Tactical.REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
      \\ FULL_SIMP_TAC (srw_ss()++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,
                          `heap2`,`a`,`sp`]
    \\ conj_tac >- rw[]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [word_mul_n2w] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def]
    \\ Q.PAT_ASSUM `xxx = heap2` (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC,x64_addr_def,
         WORD_MUL_LSL,word_mul_n2w] \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [heap_store_lemma]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,word_mul_n2w,word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [ADD1,AC ADD_COMM ADD_ASSOC,CONJ_ASSOC]
    \\ STRIP_TAC THEN1
      (FULL_SIMP_TAC (srw_ss()++ARITH_ss) [w2w_def,w2n_n2w,word_mul_n2w,MULT_ASSOC])
    \\ Q.PAT_ASSUM `xxx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
    \\ NTAC 2 (FULL_SIMP_TAC (srw_ss()++star_ss) [one_list_APPEND,one_list_def]
      \\ FULL_SIMP_TAC std_ss [STAR_ASSOC,SEP_CLAUSES,APPEND,GSYM APPEND_ASSOC]
      \\ FULL_SIMP_TAC std_ss [word_add_n2w,word_mul_n2w,LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,LEFT_ADD_DISTRIB,heap_length_APPEND,
           AC WORD_ADD_ASSOC WORD_ADD_COMM,word_mul_n2w,AC MULT_COMM MULT_ASSOC,
           heap_length_def])
    \\ rpt BasicProvers.VAR_EQ_TAC
    \\ simp[one_list_APPEND,one_list_def,rich_listTheory.LUPDATE_APPEND2,LUPDATE_def]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Q.ABBREV_TAC `m = vals.memory`
    \\ Q.ABBREV_TAC `dm = vals.memory_domain`
    \\ STRIP_TAC \\ CHANGED_TAC SEP_W_TAC
    \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC std_ss [heap_length_APPEND,heap_length_def,el_length_def
         ,MAP,SUM] \\ FULL_SIMP_TAC (srw_ss()++star_ss) [AC MULT_COMM MULT_ASSOC])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (
        isRefPtr x3 /\ isNumber x2 /\ 0 <= getNumber x2 /\
        isValueArray (refs ' (getRefPtr x3)) /\
        getNumber x2 < & LENGTH (getValueArray (refs ' (getRefPtr x3))))``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  in th end;

(* swap *)

val swap_lemma =
  abs_ml_inv_stack_permute |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> Q.SPECL [`[(x1i,r1i);(x2i,r2i);(x3i,r3i);(x4i,r4i)]`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM]

val zHEAP_SWAP = let
  val th = compose_specs ["mov r15,r0","mov r0,r1","mov r1,r15"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x2,x1,x3,x4,
                                refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with <| reg0 := vals.reg1 ; reg1 := vals.reg0;
                                  reg15 := vals.reg0 |>`
    \\ REVERSE STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def])
    \\ POP_ASSUM (K ALL_TAC) \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r2`,`r1`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt rr` MP_TAC
    \\ MATCH_MP_TAC swap_lemma \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]);
  val th = MP th lemma
  in th end;


(* specific instances of CONS *)

val tags_eq =
  ``(inr_tag,
     inl_tag,
     errors_tag,
     longs_tag,
     numbers_tag,
     others_tag,
     chars_tag,
     strings_tag)`` |>
  (EVAL THENC REWRITE_CONV [bootstrapProofTheory.repl_contags_env_def] THENC
   EVAL THENC REWRITE_CONV [compileReplTheory.compile_repl_module_eq] THENC
   EVAL) |> RW [PAIR_EQ]
  |> CONJ conLangTheory.cons_tag_def
  |> CONJ conLangTheory.nil_tag_def
  |> CONJ conLangTheory.some_tag_def
  |> CONJ conLangTheory.none_tag_def
  |> CONJ block_tag_def

val BlockNil_def = CONV_RULE(RAND_CONV EVAL)bootstrapProofTheory.BlockNil_def
val BlockCons_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV EVAL))bootstrapProofTheory.BlockCons_def
val BlockPair_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV EVAL))bootstrapProofTheory.BlockPair_def
val BlockSome_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV EVAL))bootstrapProofTheory.BlockSome_def
val BlockInl_def =
  CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL))) bootstrapProofTheory.BlockInl_def
val BlockInr_def =
  CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL))) bootstrapProofTheory.BlockInr_def

val nil_tag_def  = Define `nil_tag = ^(BlockNil_def |> concl |> rand |> rator |> rand)`
val cons_tag_def = Define `cons_tag = ^(BlockCons_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val pair_tag_def = Define `pair_tag = ^(BlockPair_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`

val BlockNil_def = ONCE_REWRITE_RULE[GSYM nil_tag_def] BlockNil_def
val BlockCons_def = ONCE_REWRITE_RULE[GSYM cons_tag_def] BlockCons_def
val BlockPair_def = ONCE_REWRITE_RULE[GSYM pair_tag_def] BlockPair_def

val BlockOtherS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockOtherS_def
val BlockLongS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockLongS_def
val BlockNumberS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockNumberS_def
val BlockCharS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockCharS_def
val BlockStringS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockStringS_def
val BlockErrorS_def = CONV_RULE(STRIP_QUANT_CONV(RAND_CONV (ONCE_REWRITE_CONV[tags_eq] THENC EVAL)))BlockErrorS_def

val others_tag_def = Define`others_tag = ^(BlockOtherS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val longs_tag_def = Define`longs_tag = ^(BlockLongS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val numbers_tag_def = Define`numbers_tag = ^(BlockNumberS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val chars_tag_def = Define`chars_tag = ^(BlockCharS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val strings_tag_def = Define`strings_tag = ^(BlockStringS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`
val errors_tag_def = Define`errors_tag = ^(BlockErrorS_def |> SPEC_ALL |> concl |> rand |> rator |> rand)`

val BlockOtherS_def = ONCE_REWRITE_RULE[GSYM others_tag_def]BlockOtherS_def
val BlockLongS_def = ONCE_REWRITE_RULE[GSYM longs_tag_def]BlockLongS_def
val BlockNumberS_def = ONCE_REWRITE_RULE[GSYM numbers_tag_def]BlockNumberS_def
val BlockCharS_def = ONCE_REWRITE_RULE[GSYM chars_tag_def]BlockCharS_def
val BlockStringS_def = ONCE_REWRITE_RULE[GSYM strings_tag_def]BlockStringS_def
val BlockErrorS_def = ONCE_REWRITE_RULE[GSYM errors_tag_def]BlockErrorS_def

fun BlockConsPair tag (n,m) = let
  fun index_to_push 1 = zHEAP_PUSH1
    | index_to_push 2 = zHEAP_PUSH2
    | index_to_push 3 = zHEAP_PUSH3
    | index_to_push 4 = zHEAP_PUSH4
    | index_to_push _ = fail()
  val th1 =
    zHEAP_BIG_CONS |> Q.INST [`n`|->tag,`l`|->`2`]
     |> DISCH_ALL |> RW [AND_IMP_INTRO] |> CONV_RULE (RATOR_CONV EVAL)
     |> Q.GEN `imm64` |> SIMP_RULE (srw_ss()) [w2w_n2w]
     |> ONCE_REWRITE_RULE [GSYM n2w_mod]
     |> SIMP_RULE (srw_ss()) [GSYM SPEC_MOVE_COND]
  val th2 = index_to_push m
  val th3 = index_to_push n
  val th = SPEC_COMPOSE_RULE [th2,th3,th1]
           |> SIMP_RULE (srw_ss()) [DECIDE ``2 <= SUC (SUC n:num)``,
                SEP_CLAUSES,GSYM BlockCons_def,GSYM BlockPair_def]
  val _ = add_compiled [th]
  in th end

val BlockConsPair12 = BlockConsPair `0` (2,1)

val _ = map (fn (n,m) =>
    (BlockConsPair `pair_tag` (n,m), BlockConsPair `cons_tag` (n,m)))
  (cross_prod [1,2,3,4] [1,2,3,4] |> Lib.flatten
      |> filter (fn (m,n) => m <> n))

fun Block1 tag = let
  val th1 =
    zHEAP_BIG_CONS |> Q.INST [`n`|->tag,`l`|->`1`]
     |> DISCH_ALL |> RW [AND_IMP_INTRO] |> CONV_RULE (RATOR_CONV EVAL)
     |> Q.GEN `imm64` |> SIMP_RULE (srw_ss()) [w2w_n2w]
     |> ONCE_REWRITE_RULE [GSYM n2w_mod]
     |> SIMP_RULE (srw_ss()) [GSYM SPEC_MOVE_COND]
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,th1]
           |> SIMP_RULE (srw_ss()) [DECIDE ``1 <= SUC (n:num)``,
                SEP_CLAUSES,GSYM BlockErrorS_def,
                            GSYM BlockLongS_def,
                            GSYM BlockOtherS_def,
                            GSYM BlockNumberS_def,
                            GSYM BlockStringS_def,
                            GSYM BlockCharS_def]
  val _ = add_compiled [th]
  in th end

val thms = map Block1
  [`others_tag`, `longs_tag`, `numbers_tag`, `strings_tag`,`chars_tag`]

fun GenBlockNil tag th = let
  val th = th |> Q.INST [`k`|->tag]
    |> SIMP_RULE (srw_ss()) [GSYM BlockNil_def,GSYM BlockErrorS_def]
    |> SIMP_RULE (srw_ss()) [w2w_n2w,nil_tag_def,SEP_CLAUSES,errors_tag_def]
  val _ = add_compiled [th]
  in th end;

val BlockNil1 = GenBlockNil `nil_tag` zHEAP_Nil1
val BlockNil2 = GenBlockNil `nil_tag` zHEAP_Nil2
val BlockNil3 = GenBlockNil `nil_tag` zHEAP_Nil3
val BlockNil4 = GenBlockNil `nil_tag` zHEAP_Nil4

val _ = map (GenBlockNil `errors_tag`) [zHEAP_Nil1,zHEAP_Nil2,zHEAP_Nil3,zHEAP_Nil4]


(* turn if b then 1 else 0 to bool_to_val *)

val zHEAP_BOOL_INTRO = let
  val th = compose_specs ["neg r0","add r0,42"]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            ((x1 = Number 0) \/ (x1 = Number 1)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       bool_to_val (x1 = Number 1),x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val l0 = abs_ml_inv_Block_NIL |> SPEC_ALL |> Q.INST [`n`|->`10`]
             |> SIMP_RULE std_ss []
  val l1 = abs_ml_inv_Block_NIL |> SPEC_ALL |> Q.INST [`n`|->`9`]
             |> SIMP_RULE std_ss []
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ fs [cond_STAR] \\ STRIP_TAC \\ STRIP_TAC
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with reg0 := 0x0w - x64_addr vs.current_heap r1 + 0x2Aw`
    \\ REVERSE STRIP_TAC
    \\ TRY (fs [zVALS_def,AC STAR_COMM STAR_ASSOC] \\ NO_TAC)
    \\ fs [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`if x1 = Number 0 then Data 0x15w else Data 0x13w`,
          `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ fs [] \\ REPEAT STRIP_TAC
    \\ TRY (MATCH_MP_TAC (GEN_ALL l0) \\ METIS_TAC [])
    \\ TRY (MATCH_MP_TAC (GEN_ALL l1) \\ METIS_TAC [])
    \\ fs [abs_ml_inv_def,APPEND,bc_stack_ref_inv_def,bc_value_inv_def,
           small_int_def] \\ EVAL_TAC);
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond ((x1 = Number 0) \/ (x1 = Number 1))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  val th = SIMP_RULE std_ss [] th
  in th end;


(* Number size *)

val (x64_num_size1_res, x64_num_size1_def, x64_num_size1_pre_def) = x64_compile `
  x64_num_size1 (r0:word64,dm:word64 set,m:word64->word64) =
    if r0 && 1w = 0w then
      if r0 = 0w then let r14 = r0 in (r0,r14,dm,m)
                 else let r14 = 1w in (r0,r14,dm,m)
    else
      let r15 = m (r0 + 1w) in
      let r14 = r15 >>> 16 in
        (r0,r14:word64,dm,m)`

val (x64_num_size2_res, x64_num_size2_def, x64_num_size2_pre_def) = x64_compile `
  x64_num_size2 (r1:word64,r14,dm:word64 set,m:word64->word64) =
    if r1 && 1w = 0w then
      if r1 = 0w then (r1,r14,dm,m)
                 else let r14 = r14 + 1w in (r1,r14,dm,m)
    else
      let r15 = m (r1 + 1w) in
      let r15 = r15 >>> 16 in
      let r14 = r14 + r15 in
        (r1,r14:word64,dm,m)`

val (x64_num_size_res, x64_num_size_def, x64_num_size_pre_def) = x64_compile `
  x64_num_size (r0,r1,dm,m) =
    let (r0,r14,dm,m) = x64_num_size1 (r0,dm,m) in
    let (r1,r14,dm,m) = x64_num_size2 (r1,r14,dm,m) in
    let r14 = r14 + 5w in
    let r14 = r14 << 3 in
      (r0,r1,r14,dm,m)`

val num_size_def = Define `
  (num_size (Number i) = LENGTH ((mw (Num (ABS i))):word64 list)) /\
  (num_size _ = 0)`;

val x64_num_size1_EXPAND = prove(
  ``(x64_num_size1 (r0,dm,m) = (r0,FST (SND (x64_num_size1 (r0,dm,m))),dm,m))``,
  SIMP_TAC std_ss [x64_num_size1_def] \\ SRW_TAC [] []
  \\ UNABBREV_ALL_TAC \\ FULL_SIMP_TAC std_ss []);

val x64_num_size2_EXPAND = prove(
  ``(x64_num_size2 (r0,r14,dm,m) =
      (r0,r14 + FST (SND (x64_num_size1 (r0,dm,m))),dm,m))``,
  SIMP_TAC std_ss [x64_num_size1_def,x64_num_size2_def]
  \\ SRW_TAC [] [] \\ UNABBREV_ALL_TAC
  \\ FULL_SIMP_TAC std_ss [WORD_ADD_0,WORD_ADD_ASSOC]);

val x64_num_size2_pre_EXPAND = prove(
  ``x64_num_size2_pre (r0,r14,dm,m) = x64_num_size1_pre (r0,dm,m)``,
  fs [x64_num_size2_pre_def,x64_num_size1_pre_def]
  \\ SRW_TAC [] [] \\ fs []);

val size_lemma = blastLib.BBLAST_PROVE
  ``1w && (w << 1) = 0w:word64``

val lem = blastLib.BBLAST_PROVE
  ``(((w2w:63 word->word64) (2w * w) << 1 = 0w) <=> (w * 2w = 0w))``

val small_int_LENGTH = prove(
  ``small_int i ==>
    (LENGTH ((mw (Num (ABS i))) : word64 list) = if i = 0 then 0 else 1)``,
  Cases_on `i = 0` \\ fs [] THEN1 EVAL_TAC
  \\ fs [small_int_def] \\ Cases_on `i` \\ fs[]
  \\ `Num (ABS (& n)) = n` by intLib.COOPER_TAC \\ fs []
  \\ `Num (ABS (-& n)) = n` by intLib.COOPER_TAC \\ fs []
  \\ ONCE_REWRITE_TAC [mw_def]
  \\ fs [] \\ REPEAT STRIP_TAC
  \\ `n DIV 18446744073709551616 = 0` by (fs [DIV_EQ_X] \\ DECIDE_TAC)
  \\ fs [] \\ EVAL_TAC);

val bc_value_inv_Num_IMP_x64_num_size1_pre = prove(
  ``bc_value_inv (Number i) (r1,f,heap) /\ heap_vars_ok vs /\
    (x64_heap vs.current_heap heap vs.current_heap vs.current_heap *
        one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs)
         (fun2set (vals.memory,vals.memory_domain)) ==>
    x64_num_size1_pre
     (x64_addr vs.current_heap r1,vals.memory_domain,vals.memory) /\
    (FST (SND (x64_num_size1 (x64_addr vs.current_heap r1,
                vals.memory_domain,vals.memory))) = n2w (num_size (Number i)))``,
  fs [x64_num_size1_pre_def,x64_num_size1_def,LET_DEF,bc_value_inv_def]
  \\ Cases_on `small_int i` \\ fs [] THEN1
    (fs [x64_addr_def,size_lemma,num_size_def,small_int_LENGTH]
     \\ Cases_on `i = 0` \\ fs []
     \\ SRW_TAC [] [] \\ fs [small_int_def]
     \\ `F` by ALL_TAC \\ fs [lem]
     \\ fs [word_mul_n2w]
     \\ IMP_RES_TAC (intLib.COOPER_PROVE
          ``0 <= i /\ i < 4611686018427387904 ==>
           (2 * Num i) < 9223372036854775808``) \\ fs []
     \\ intLib.COOPER_TAC)
  \\ fs [x64_addr_def,size_lemma]
  \\ REPEAT STRIP_TAC \\ fs []
  \\ `(0x1w && x64_addr vs.current_heap (Pointer ptr)) <> 0x0w` by
   (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC \\ fs [heap_vars_ok_def]
    \\ fs [x64_addr_def] \\ blastLib.BBLAST_TAC)
  \\ fs [] \\ SRW_TAC [] [] \\ fs [x64_addr_def]
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def,DataOnly_def]
  \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
  \\ SEP_R_TAC \\ fs [] \\ REPEAT STRIP_TAC
  THEN1
   (fs [heap_vars_ok_def]
    \\ Q.PAT_ASSUM `0x7w && vs.current_heap = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  \\ fs [num_size_def]
  \\ `n2w (LENGTH ((mw (Num (ABS i))) : word64 list)) <+
        281474976710656w : word64` by
   (IMP_RES_TAC (DECIDE ``n < 281474976710656 ==> n < 18446744073709551616:num``)
    \\ fs [WORD_LO])
  \\ `b2w (i < 0) <+ 2w:word64` by ALL_TAC
  THEN1 (Cases_on `i < 0` \\ fs [] \\ EVAL_TAC)
  \\ NTAC 2 (POP_ASSUM MP_TAC)
  \\ Q.SPEC_TAC (`n2w (LENGTH ((mw (Num (ABS i))) : word64 list)):word64`,`w`)
  \\ Q.SPEC_TAC (`b2w (i < 0:int):word64`,`bb`)
  \\ blastLib.BBLAST_TAC);

val zHEAP_NUM_SIZE = let
  val th = x64_num_size_res
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            isNumber x1 /\ isNumber x2)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals).
                vals.reg14 = n2w (8 * (num_size x1 + num_size x2 + 5)))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [x64_num_size_def]
    \\ ONCE_REWRITE_TAC [x64_num_size1_EXPAND]
    \\ ONCE_REWRITE_TAC [x64_num_size2_EXPAND]
    \\ SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM,zHEAP_def]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    THEN1
     (fs [abs_ml_inv_def]
      \\ Cases_on `x1` \\ fs [isNumber_def]
      \\ Cases_on `x2` \\ fs [isNumber_def]
      \\ fs [bc_stack_ref_inv_def]
      \\ fs [x64_num_size_pre_def]
      \\ ONCE_REWRITE_TAC [x64_num_size1_EXPAND]
      \\ ONCE_REWRITE_TAC [x64_num_size2_EXPAND]
      \\ fs [LET_DEF,x64_num_size2_pre_EXPAND]
      \\ IMP_RES_TAC bc_value_inv_Num_IMP_x64_num_size1_pre \\ fs [])
    \\ Q.EXISTS_TAC
         `vals with <| reg14 := n2w (8 * (num_size x1 + num_size x2 + 5));
                       reg15 := x |>`
    \\ `(FST (SND (x64_num_size1 (x64_addr vs.current_heap r1,
                                 vals.memory_domain,vals.memory))) +
         FST (SND (x64_num_size1 (x64_addr vs.current_heap r2,
                                 vals.memory_domain,vals.memory))) +
         5w) << 3 = n2w (8 * (num_size x1 + num_size x2 + 5))` by
     (fs [abs_ml_inv_def]
      \\ Cases_on `x1` \\ fs [isNumber_def]
      \\ Cases_on `x2` \\ fs [isNumber_def]
      \\ fs [bc_stack_ref_inv_def]
      \\ IMP_RES_TAC bc_value_inv_Num_IMP_x64_num_size1_pre
      \\ fs [WORD_MUL_LSL,word_add_n2w,word_mul_n2w,LEFT_ADD_DISTRIB]
      \\ fs [AC ADD_COMM ADD_ASSOC, AC MULT_COMM MULT_ASSOC])
    \\ fs [] \\ REVERSE (REPEAT STRIP_TAC) THEN1
     (fs [zVALS_def,AC STAR_ASSOC STAR_COMM]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND])
    \\ fs [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p *
      cond (isNumber x1 /\ isNumber x2)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;


(* Use of multiword library *)

val (bignum_th,code_abbrev_def) = let
  val (_,_,code,_) = x64_multiwordTheory.x64_iop_res |> concl |> dest_spec
  val temp_code_def = Define `temp_code (p:word64) = ^code`;
  val th = x64_multiwordTheory.x64_iop_res |> Q.GEN `p` |> Q.SPEC `frame`
             |> RW [GSYM temp_code_def]
  in (th,temp_code_def) end

val thA = let
  val tm = ``x64_iop (r0,r1,r3,xs,ys,zs,xa,ya,ss) = (r10i,xsi,ysi,zsi,xai,yai,ssi)``
  val th = DISCH tm bignum_th |> SIMP_RULE std_ss [LET_DEF] |> UNDISCH
  in th end


(* bignum header writer *)

val num_eq_def = Define `
  num_bool x y = Number (if x = y then 1 else 0)`;

val zBIGNUMS_HEADER_def = Define `
  zBIGNUMS_HEADER (xai,xsi,yai,ysi,z,za,zsi,frame) =
    zBIGNUMS (xai,xsi,yai,ysi,za,zsi,frame * one (za - 8w, z))`;

val thB = thA |> Q.INST [`frame`|->`frame * one (za - 8w, z)`]
              |> RW [GSYM zBIGNUMS_HEADER_def]

val (x64_big_header_res, x64_big_header_def, x64_big_header_pre_def) = x64_compile `
  x64_big_header (r10:word64,r15:word64,dm:word64 set,m:word64->word64) =
    let r0 = r15 - 9w in
    let r2 = r10 >>> 1 in
    let r2 = r2 << 16 in
    let r3 = m (r0 + 1w) in
    let r2 = r2 + 2w in
    let r1 = r10 && 1w in
    let r2 = r2 + r1 in
    let m = (r0 + 1w =+ r2) m in
      (r0,r3,r10,r15,dm,m)`

val zBIGNUM_HEADER_WRITE = let
  val th = x64_big_header_res |> Q.INST [`r15`|->`za`]
           |> RW [x64_big_header_def,x64_big_header_pre_def]
  val th = MATCH_MP SPEC_FRAME th |> Q.SPEC `zR 0xDw xa * zR 0xEw ya * cond
             (bignum_mem (frame * one (za - 8w, z)) dm m xa xs ya ys za zs /\
              (r10 = x64_header (q,qs)))`
  val pc = get_pc th
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``(~zS * ^pc * zR 0x0w (za - 9w) * zR 0x3w z * ~zR 0x2w * ~zR 0x1w *
       zR 0xAw (x64_header (q,qs)) *
       zBIGNUMS_HEADER (xa,xs,ya,ys,n2w (LENGTH qs) << 16 + 2w+b2w q,za,zs,frame))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [x64_multiwordTheory.zBIGNUMS_def,
        LET_DEF,SEP_IMP_def,cond_STAR,zBIGNUMS_HEADER_def]
    \\ SIMP_TAC std_ss [word_arith_lemma3,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`dm`,`((za - 0x8w =+ (r10 >>> 1) << 16 + 0x2w + (r10 && 0x1w)) m)`]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ `m (za  0x8w) = z` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `xa = ya` \\ FULL_SIMP_TAC std_ss [] \\ SEP_R_TAC)
    \\ Q.PAT_ASSUM `r10 = xxx` ASSUME_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ `((x64_header (q,qs) >>> 1) << 16 = n2w (LENGTH qs) << 16) /\
        (x64_header (q,qs) && 0x1w = b2w q)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [x64_multiwordTheory.x64_header_def]
      \\ Cases_on `q` \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,b2w_def]
      \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss [x64_multiwordTheory.bignum_mem_def]
    \\ Cases_on `xa = ya` \\ FULL_SIMP_TAC std_ss [] \\ SEP_R_TAC
    \\ SEP_W_TAC \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = th |> Q.GENL [`dm`,`m`] |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * ~zR 0x0w * ~zR 0x1w * ~zR 0x2w * ~zR 0x3w * zR 0xAw r10 *
       zBIGNUMS_HEADER (xa,xs,ya,ys,z,za,zs,frame) *
       cond (r10 = x64_header (q,qs)))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [x64_multiwordTheory.zBIGNUMS_def,
        LET_DEF,SEP_IMP_def,cond_STAR,zBIGNUMS_HEADER_def]
    \\ SIMP_TAC std_ss [word_arith_lemma3,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ NTAC 2 STRIP_TAC
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_multiwordTheory.zBIGNUMS_def,
        LET_DEF,SEP_IMP_def,cond_STAR,zBIGNUMS_HEADER_def]
    \\ Q.LIST_EXISTS_TAC [`m`,`dm`]
    \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REPEAT STRIP_TAC
    \\ Cases_on `xa = ya`
    \\ FULL_SIMP_TAC std_ss [x64_multiwordTheory.bignum_mem_def]
    \\ SEP_R_TAC
    \\ Q.PAT_ASSUM `za && 0x7w = 0x0w` MP_TAC
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  in th end

val thC = SPEC_COMPOSE_RULE [thB,zBIGNUM_HEADER_WRITE]

(* bignum collapse small int *)

val (x64_big_small_res, x64_big_small_def, x64_big_small_pre_def) = x64_compile `
  x64_big_small (r0,r10:word64,r15,dm:word64 set,m:word64->word64) =
    if r10 = 0w then (* zero *)
      let r0 = 0w in
      let r1 = 0w in
        (r0,r1,r15,dm,m)
    else if r10 = 1w then (* zero *)
      let r0 = 0w in
      let r1 = 0w in
        (r0,r1,r15,dm,m)
    else if r10 = 2w then
      let r1 = m r15 in
      let r2 = 1w in
      let r2 = r2 << 62 in
        if r1 <+ r2 then (* can be repr as small_int *)
          let r0 = r1 << 2 in
          let r1 = 0w in
            (r0,r1,r15,dm,m)
        else
          let r1 = r10 >>> 1 in
          let r1 = r1 << 3 in
          let r1 = r1 + 8w in
            (r0,r1,r15,dm,m)
    else
      let r1 = r10 >>> 1 in
      let r1 = r1 << 3 in
      let r1 = r1 + 8w in
        (r0,r1,r15,dm,m)`

val small_int_to_word_def = Define `
  small_int_to_word i =
    x64_addr ARB (Data (0x2w * n2w (Num i) : 63 word))`;

val mw_ok_mw2n_eq_0 = prove(
  ``mw_ok qs ==> ((mw2n qs = 0) <=> (qs = []))``,
  STRIP_ASSUME_TAC (ISPEC ``qs:'a word list`` SNOC_CASES)
  \\ SRW_TAC [] [] THEN1 EVAL_TAC
  \\ fs [SNOC_APPEND,multiwordTheory.mw2n_msf,multiwordTheory.mw_ok_def]
  \\ DISJ2_TAC \\ fs [multiwordTheory.dimwords_def]);

val mw_ok_mw2i_eq_0 = prove(
  ``mw_ok qs ==> ((mw2i (q,qs) = 0) <=> (qs = []))``,
  Cases_on `q` \\ fs [multiwordTheory.mw2i_def,mw_ok_mw2n_eq_0]);

val not_zero_IMP_x64_header_NOT_0_1 = prove(
  ``mw_ok qs /\ mw2i (q,qs) <> 0 /\ LENGTH qs < 4294967296 ==>
    (x64_header (q,qs) <> 0x0w) /\
    (x64_header (q,qs) <> 0x1w)``,
  REPEAT STRIP_TAC
  \\ `qs <> []` by METIS_TAC [mw_ok_mw2i_eq_0]
  \\ Cases_on `q` \\ fs [x64_multiwordTheory.x64_header_def]
  \\ fs [word_add_n2w]
  \\ `(LENGTH qs * 2 + 1) < 18446744073709551616 /\
      (LENGTH qs * 2) < 18446744073709551616` by DECIDE_TAC
  \\ fs [LENGTH_NIL]);

val x64_header_IMP_NOT_small_int = prove(
  ``LENGTH qs < 4294967296 /\ mw_ok qs /\
    (x64_header (q,qs) <> 0x0w) /\
    (x64_header (q,qs) <> 0x1w) /\
    (x64_header (q,qs) <> 0x2w) ==>
    ~small_int (mw2i (q,qs))``,
  REPEAT STRIP_TAC
  \\ `LENGTH qs < 2` by ALL_TAC
  THEN1
   (STRIP_ASSUME_TAC (ISPEC ``qs:word64 list`` SNOC_CASES)
    \\ fs [] \\ SRW_TAC [] []
    \\ fs [multiwordTheory.mw_ok_def]
    \\ Cases_on `q` THEN1
     (fs [small_int_def,multiwordTheory.mw2i_def,
          multiwordTheory.mw2n_msf,multiwordTheory.dimwords_def])
    \\ fs [multiwordTheory.mw2i_def,multiwordTheory.mw2n_msf,
         small_int_def]
    \\ Cases_on `l` \\ fs [SNOC_APPEND]
    \\ Cases_on `x` \\ fs [multiwordTheory.dimwords_def]
    \\ fs [MULT_CLAUSES,EXP_ADD]
    \\ `2 ** (LENGTH t * 64) <> 0` by fs []
    \\ Cases_on `2 ** (LENGTH t * 64)` \\ fs []
    \\ Cases_on `n'` \\ fs [MULT_CLAUSES]
    \\ `F` by DECIDE_TAC)
  \\ Cases_on `qs` \\ TRY (Cases_on `t`)
  \\ Cases_on `q` \\ fs []
  \\ REPEAT (POP_ASSUM MP_TAC)
  \\ EVAL_TAC
  \\ REPEAT STRIP_TAC
  \\ Cases_on `h` \\ fs []
  \\ DECIDE_TAC);

val x64_header_shifts = prove(
  ``x64_header (q,qs) >>> 1 << 3 + 8w = n2w (8 * LENGTH qs + 8)``,
  fs [x64_multiwordTheory.x64_header_def,GSYM word_mul_n2w,GSYM word_add_n2w]
  \\ Q.ABBREV_TAC `qq = n2w (LENGTH (qs:word64 list)):word64`
  \\ Cases_on `q` \\ fs [] \\ blastLib.BBLAST_TAC);

val zBIGNUM_BIG_SMALL = let
  val th = x64_big_small_res |> Q.INST [`r15`|->`za`,
              `r10`|->`x64_header (q,qs)`,`r0`|->`za - 9w`]
  val th = MATCH_MP SPEC_FRAME th |> Q.SPEC `zR 0xDw xa * zR 0xEw ya * cond
             (bignum_mem (frame * one (za - 8w, z)) dm m xa xs ya ys za zs /\
              (isPREFIX qs zs) /\ LENGTH qs < 2**32 /\ mw_ok qs)`
  val pc = get_pc th
  val th = th |> DISCH ``x64_big_small_pre (za - 9w,x64_header (q,qs),za,dm,m)``
              |> SIMP_RULE (std_ss++sep_cond_ss) []
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th |> Q.SPEC
     `(~zS * ^pc * zR 0x0w (if small_int (mw2i (q,qs:word64 list))
                            then small_int_to_word (mw2i (q,qs:word64 list))
                            else za - 9w) *
       zR 0x1w (if small_int (mw2i (q,qs:word64 list)) then 0w else
                  n2w (8 * LENGTH qs + 8)) * ~zR 0x2w * ~zR 0xAw *
       zBIGNUMS_HEADER (xa,xs,ya,ys,z,za,zs,frame))`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    Cases_on `mw2i (q,qs) = 0` \\ fs []
    THEN1
     (REPEAT STRIP_TAC
      \\ `qs = []` by fs [mw_ok_mw2i_eq_0] \\ fs []
      \\ Cases_on `q`
      \\ fs [EVAL ``x64_header (F,[])``,EVAL ``x64_header (T,[])``,
             x64_big_small_def,x64_big_small_pre_def,
             LET_DEF,SEP_CLAUSES,EVAL ``small_int 0``,
             EVAL ``small_int_to_word 0``,zBIGNUMS_HEADER_def,
             x64_multiwordTheory.zBIGNUMS_def]
      \\ fs [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ Q.LIST_EXISTS_TAC [`dm`,`m`]
      \\ fs [AC STAR_COMM STAR_ASSOC,SEP_CLAUSES])
    \\ REVERSE (Cases_on `x64_header (q,qs) = 2w`) \\ fs []
    THEN1
     (REPEAT STRIP_TAC
      \\ `(x64_header (q,qs) <> 0x0w) /\
          (x64_header (q,qs) <> 0x1w)` by
       (MATCH_MP_TAC not_zero_IMP_x64_header_NOT_0_1 \\ fs [])
      \\ IMP_RES_TAC x64_header_IMP_NOT_small_int
      \\ fs [x64_big_small_pre_def,x64_big_small_def,LET_DEF]
      \\ IMP_RES_TAC not_zero_IMP_x64_header_NOT_0_1 \\ fs []
      \\ fs [x64_header_shifts]
      \\ fs [SEP_CLAUSES,zBIGNUMS_HEADER_def,
             x64_multiwordTheory.zBIGNUMS_def,SEP_IMP_def,
             SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ Q.LIST_EXISTS_TAC [`dm`,`m`]
      \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
    \\ STRIP_TAC
    \\ `~q /\ (LENGTH qs = 1)` by
     (fs [x64_multiwordTheory.x64_header_def]
      \\ Cases_on `q` \\ fs [word_add_n2w]
      \\ fs [multiwordTheory.mw2i_def,multiwordTheory.mw2n_msf,
             small_int_def]
      \\ `(LENGTH qs * 2 + 1) < 18446744073709551616` by DECIDE_TAC \\ fs []
      \\ `(LENGTH qs * 2) < 18446744073709551616` by DECIDE_TAC \\ fs []
      \\ Cases_on `qs` \\ fs []
      \\ Cases_on `t` \\ fs [] \\ DECIDE_TAC)
    \\ fs [x64_big_small_pre_def,x64_big_small_def,LET_DEF,
           zBIGNUMS_HEADER_def,x64_multiwordTheory.zBIGNUMS_def,SEP_IMP_def,
           SEP_EXISTS_THM,SEP_CLAUSES]
    \\ fs [PULL_FORALL,PULL_EXISTS]
    \\ `?qq. qs = [qq]` by (Cases_on `qs` \\ fs [LENGTH_NIL])
    \\ fs [] \\ Cases_on `zs` \\ fs []
    \\ rpt BasicProvers.VAR_EQ_TAC
    \\ fs [x64_multiwordTheory.bignum_mem_def]
    \\ `za IN dm /\ (m za = h)` by
            (Cases_on `xa = ya`
             \\ fs [x64_multiwordTheory.array64_def]
             \\ SEP_R_TAC) \\ fs []
    \\ `small_int (mw2i (F,[h])) <=> h <+ 0x4000000000000000w` by
     (fs [multiwordTheory.mw2i_def,multiwordTheory.mw2n_def,small_int_def]
      \\ Cases_on `h` \\ fs [WORD_LO])
    \\ `h <+ 0x4000000000000000w ==>
        (small_int_to_word (mw2i (F,[h])) = h << 2)` by
     (fs [multiwordTheory.mw2i_def,multiwordTheory.mw2n_def,small_int_def]
      \\ fs [small_int_to_word_def,x64_addr_def]
      \\ fs [GSYM w2w_def] \\ blastLib.BBLAST_TAC)
    \\ fs [] \\ SRW_TAC [] [] \\ rfs []
    \\ Cases_on `xa = ya` \\ fs []
    \\ Q.LIST_EXISTS_TAC [`dm`,`m`] \\ fs [] \\ rfs[]
    \\ fs [AC STAR_COMM STAR_ASSOC,SEP_CLAUSES])
  val th = MP th lemma
  val th = Q.GENL [`m`,`dm`] th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``(~zS * zPC p * zR 0x0w (za - 9w) * ~zR 0x1w * ~zR 0x2w *
       zR 0xAw (x64_header (q,qs)) *
       zBIGNUMS_HEADER (xa,xs,ya,ys,z,za,zs,frame) * cond
         ((isPREFIX qs zs) /\ LENGTH qs < 4294967296 /\ mw_ok qs))``
  val lemma = prove(goal,
    fs [AC STAR_COMM STAR_ASSOC,zBIGNUMS_HEADER_def,
        x64_multiwordTheory.zBIGNUMS_def,SEP_CLAUSES,
        AC CONJ_COMM CONJ_ASSOC,SEP_IMP_REFL])
  val th = MP th lemma
  in th end;

val thD = SPEC_COMPOSE_RULE [thC,zBIGNUM_BIG_SMALL] |> RW [STAR_ASSOC];

(* set up code *)

val (x64_move_ptr_res, x64_move_ptr_def, x64_move_ptr_pre_def) = x64_compile `
  x64_move_ptr (r0,r15,dm:word64 set,m:word64->word64) =
    if r0 = 0w then
      let r13 = r15 in
        (r0,r13,dm,m)
    else if r0 && 1w = 0w then
      let r0 = r0 >>> 2 in
      let m = (r15 =+ r0) m in
      let r0 = 2w in
      let r13 = r15 in
        (r0,r13,dm,m)
    else
      let r13 = r0 + 9w in
      let r0 = m (r0 + 1w) in
      let r15 = r0 && 1w in
      let r0 = r0 >>> 15 in
      let r0 = r0 + r15 in
        (r0,r13,dm,m)`

val (x64_move_ptr2_res, x64_move_ptr2_def, x64_move_ptr2_pre_def) = x64_compile `
  x64_move_ptr2 (r1,r15,dm:word64 set,m:word64->word64) =
    if r1 = 0w then
      let r14 = r15 in
        (r1,r14,dm,m)
    else if r1 && 1w = 0w then
      let r1 = r1 >>> 2 in
      let m = (r15 =+ r1) m in
      let r1 = 2w in
      let r14 = r15 in
        (r1,r14,dm,m)
    else
      let r14 = r1 + 9w in
      let r1 = m (r1 + 1w) in
      let r15 = r1 && 1w in
      let r1 = r1 >>> 15 in
      let r1 = r1 + r15 in
        (r1,r14,dm,m)`

val x64_move_ptr2_thm = prove(
  ``(x64_move_ptr2 = x64_move_ptr) /\
    (x64_move_ptr2_pre = x64_move_ptr_pre)``,
  fs [FUN_EQ_THM,FORALL_PROD]
  \\ fs [x64_move_ptr2_def, x64_move_ptr2_pre_def,
         x64_move_ptr_def, x64_move_ptr_pre_def,LET_DEF]);

val (x64_big_setup_res, x64_big_setup_def, x64_big_setup_pre_def) = x64_compile `
  x64_big_setup (r0,r1,r6:word64,r7,r9,dm:word64 set,m:word64->word64) =
    let r15 = r7 - 7w in
    let (r0,r13,dm,m) = x64_move_ptr (r0,r15,dm,m) in
    let r15 = r7 - 15w in
    let (r1,r14,dm,m) = x64_move_ptr2 (r1,r15,dm,m) in
    let r15 = m (r9 + 24w) in
    let m = (r6 + 1w =+ r15) m in
    let r15 = r6 + 9w in
      (r0,r1,r6,r7,r9,r13,r14,r15,m,dm)`

(* print string from stack *)

val blast_lemma = prove(
  ``r7 <+ 256w ==> (w2w ((w2w r7):word8) = r7:word64)``,
  blastLib.BBLAST_TAC) |> UNDISCH;

val lemma = prove(
  ``(r15 = po) ==>
    (zIO (pi,input,r15,output) = zIO (pi,input,po,output))``,
  SIMP_TAC std_ss []) |> UNDISCH;

val put_char_thm =
  SPEC_COMPOSE_RULE [x64_call_r15, x64_putchar_thm]
  |> Q.INST [`c`|->`w2w (r7:word64)`,`rip`|->`p`] |> RW [blast_lemma]
  |> RW1 [lemma] |> DISCH_ALL |> RW [AND_IMP_INTRO]
  |> RW [GSYM SPEC_MOVE_COND]

val th = let
  val q = put_char_thm |> concl |> rand
  val tm = ``output ++ [(w2w:word64->word8) r7]``
  val new_q = subst [tm|->``output:word8 list``] q
  val (th,goal) = SPEC_WEAKEN_RULE put_char_thm ``let output = ^tm in ^new_q``
  val lemma = prove(goal,SIMP_TAC std_ss [LET_DEF,SEP_IMP_REFL])
  val th = MP th lemma
  val _ = add_compiled [th];
  val _ = add_decompiled("print_r7",th,3,SOME 3);
  in th end

val th = let
  val th = x64_pop_r7
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``let (r7,ss) = (HD ss,TL ss) in
        (zPC (p + 0x2w) * zR 0x7w r7 * zSTACK (base,ss))``
  val lemma = prove(goal,SIMP_TAC std_ss [LET_DEF,SEP_IMP_REFL])
  val th = MP th lemma
  val _ = add_decompiled("pop_r7",th,2,SOME 2);
  in th end

val (res,x64_pop_def) = x64_decompile "x64_pop" `
  L1: insert pop_r7 `

val (res,x64_print_def) = x64_decompile "x64_print" `
  L1: insert print_r7 `

val (x64_print_stack_res,x64_print_stack_def) = x64_decompile "x64_print_stack" `
  L1: insert x64_pop
      test r7,r7
      je L2
      insert x64_print
      jmp L1
  L2: `

val _ = add_compiled [x64_print_stack_res]

val x64_print_stack_thm = prove(
  ``!xs output.
      EVERY (\x. ORD x <> 0) xs /\ (r15 = po) ==>
      x64_print_stack_pre (r15,output,po,MAP (n2w o ORD) xs ++ 0w::ss) /\
      (x64_print_stack (r15,output,po,MAP (n2w o ORD) xs ++ 0w::ss) =
         (r15,output ++ MAP (n2w o ORD) xs,po,ss))``,
  Induct \\ ONCE_REWRITE_TAC [x64_print_stack_def]
  \\ SIMP_TAC std_ss [LET_DEF,x64_pop_def,MAP,APPEND,HD,TL,APPEND_NIL]
  \\ SIMP_TAC std_ss [x64_print_def,LET_DEF,EVERY_DEF]
  \\ SIMP_TAC std_ss [n2w_11,ZERO_LT_dimword]
  \\ REPEAT STRIP_TAC
  \\ `ORD h < 256` by SIMP_TAC std_ss [ORD_BOUND]
  \\ `ORD h < 18446744073709551616` by DECIDE_TAC
  \\ FULL_SIMP_TAC (srw_ss()) [w2w_def,n2w_w2n,WORD_LO]);

val zBIGNUMS_ALT_def = Define `
  zBIGNUMS_ALT (xa,xs,ya,ys,za,zs,p) =
    SEP_EXISTS dm m.
       zMEMORY64 dm m * cond (bignum_mem p dm m xa xs ya ys za zs)`;

val zBIGNUMS_ALT_THM = prove(
  ``zBIGNUMS (xa,xs,ya,ys,za,zs,p) =
    zBIGNUMS_ALT (xa,xs,ya,ys,za,zs,p) * zR 0xDw xa * zR 0xEw ya * zR 0xFw za``,
  SIMP_TAC std_ss [zBIGNUMS_ALT_def,x64_multiwordTheory.zBIGNUMS_def,SEP_CLAUSES]
  \\ SIMP_TAC (std_ss++sep_cond_ss) []);

val res0 = SPEC_COMPOSE_RULE
             [compose_specs ["shr r3,2","mov r2,0"],
              x64_push_r2]

val res1 = thD |> CONV_RULE (RAND_CONV
  (REWRITE_CONV [zBIGNUMS_HEADER_def,zBIGNUMS_ALT_THM]))
  |> SIMP_RULE std_ss [SEP_CLAUSES,STAR_ASSOC]

val res2 = compose_specs ["mov r15,r3","mov r14,r0","mov r13,r1"]

val res3 = x64_print_stack_res |> SIMP_RULE std_ss [LET_DEF]
  |> DISCH ``x64_print_stack (r15,output,po,ss) =
               (r15_p,output_p,po_p,ss_p)``
  |> SIMP_RULE std_ss [] |> UNDISCH

val res4 = compose_specs ["mov r0,r14","mov r1,r13","mov r14,r15","mov r13,r15"]

val res5 = compose_specs ["add r6,r1"]

fun push_pop push_th pop_th th =
  SPEC_COMPOSE_RULE [push_th,th,pop_th] |> RW [HD,TL,NOT_CONS_NIL]

val thE = SPEC_COMPOSE_RULE [res0,res1,res2,res3,res4] |> RW [STAR_ASSOC]
          |> DISCH ``ss_p = ss:word64 list`` |> SIMP_RULE std_ss []
          |> UNDISCH
          |> push_pop x64_push_r6 x64_pop_r6
          |> (fn th => SPEC_COMPOSE_RULE [th,res5])

val thE1 = thE
    |> push_pop x64_push_r2 x64_pop_r2
    |> push_pop x64_push_r3 x64_pop_r3

val thE2 = thE1
    |> SIMP_RULE (std_ss++sep_cond_ss) [zBIGNUMS_HEADER_def,
         x64_multiwordTheory.zBIGNUMS_def,SEP_CLAUSES,
         GSYM SPEC_PRE_EXISTS,SPEC_MOVE_COND] |> SPEC_ALL |> UNDISCH_ALL
    |> RW [SEP_CLAUSES,STAR_ASSOC]

val th1 =
  x64_big_setup_res
  |> DISCH ``x64_big_setup (r0,r1,r6,r7,r9,dm,m) =
        (r0j,r1j,r6,r7j,r9j,r13j,r14j,r6 + 9w,mj,dmj)``
  |> SIMP_RULE std_ss [LET_DEF] |> UNDISCH_ALL

val thE3 =
  SPEC_COMPOSE_RULE [th1,thE2 |> Q.INST [`dm`|->`dmj`]]
  |> push_pop x64_push_r1 x64_pop_r1
  |> push_pop x64_push_r15 x64_pop_r15
  |> push_pop x64_push_r7 x64_pop_r7
  |> push_pop x64_push_r8 x64_pop_r8
  |> push_pop x64_push_r9 x64_pop_r9
  |> push_pop x64_push_r10 x64_pop_r10
  |> push_pop x64_push_r11 x64_pop_r11
  |> push_pop x64_push_r12 x64_pop_r12
  |> push_pop x64_push_r13 x64_pop_r13
  |> push_pop x64_push_r14 x64_pop_r14
  |> RW [WORD_ADD_0,SEP_CLAUSES]
  |> SIMP_RULE (std_ss++sep_cond_ss) [SEP_CLAUSES,
         GSYM SPEC_PRE_EXISTS,SPEC_MOVE_COND] |> SPEC_ALL |> UNDISCH_ALL

(* push r13 onto stack in two parts *)

val parts_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4);(x5,r5);(x6,r6)]`,
              `[(x5,r5);(x6,r6);(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val abs_ml_inv_pop =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x2,r2);(x1,r1)]`,
              `[(x1,r1);(x2,r2);(x1,r1)]`]
  |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val zHEAP_PUSH_R13_IN_PARTS = let
  val th0 = x64_push_r15
  val th1 = compose_specs ["mov r15,r13","shr r15,32","shl r15,2"]
  val th2 = compose_specs ["mov r15,r13","shl r15,32","shr r15,30"]
  val th = SPEC_COMPOSE_RULE [th1,th0,th2,th0]
  val pc = get_pc th
  val ss = ``SOME (\(sp:num,vals). vals.reg13 = r13:word64)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^ss) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,
                           Number (&(w2n (((r13:word64) << 32) >>> 32)))::
                           Number (&(w2n ((r13:word64) >>> 32)))::stack,s,NONE) *
                         ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with
          <| stack := ((r13 << 32 >>> 30)::(r13 >>> 32 << 2)::vals.stack) ;
             reg15 := (r13:word64 << 32 >>> 30):word64 |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
         `(Data (2w * n2w (w2n ((r13:word64) << 32 >>> 32))))::
          (Data (2w * n2w (w2n ((r13:word64) >>> 32))))::roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [CONS_11,MAP]
    \\ fs [x64_addr_def]
    \\ REVERSE STRIP_TAC THEN1 (fs [GSYM w2w_def] \\ blastLib.BBLAST_TAC)
    \\ NTAC 2 (MATCH_MP_TAC parts_lemma)
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ fs [w2n_lsr,DIV_LT_X]
    \\ Q.LIST_EXISTS_TAC [`x1`,`r1`]
    \\ REVERSE STRIP_TAC THEN1
     (ASSUME_TAC (ISPEC ``(r13 << 32):word64`` w2n_lt)
      \\ fs [] \\ DECIDE_TAC)
    \\ MATCH_MP_TAC abs_ml_inv_pop
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x2`,`r2`]
    \\ STRIP_TAC THEN1 (MATCH_MP_TAC abs_ml_inv_pop \\ fs [])
    \\ fs [DIV_LT_X]
    \\ ASSUME_TAC (ISPEC ``(r13):word64`` w2n_lt)
    \\ fs [] \\ DECIDE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^ss) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

(* pop r13 onto stack from two parts *)

val small_int_w2n_lemma = prove(
  ``small_int (&w2n ((r13:word64)  32))``,
  fs [small_int_def,w2n_lsr,DIV_LT_X]
  \\ ASSUME_TAC (ISPEC ``(r13):word64`` w2n_lt)
  \\ fs [] \\ DECIDE_TAC);

val pop_parts_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4);(x5,r5);(x6,r6)]`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val zHEAP_POP_R13_IN_PARTS = let
  val thA = x64_pop_r13
  val th0 = x64_pop_r15
  val th1 = compose_specs ["shr r13,2"]
  val th2 = compose_specs ["shl r15,30","or r13,r15"]
  val th = SPEC_COMPOSE_RULE [thA,th1,th0,th2]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) []
  val pc = get_pc th
  val ss = ``SOME (\(sp:num,vals). vals.reg13 = r13)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            (stack = Number (&w2n ((r13:word64) << 32 >>> 32))::
                     Number (&w2n ((r13:word64) >>> 32))::sss))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,sss,s,^ss) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ `?rr1 rr2 rrs. roots = rr1::rr2::rrs` by
          (fs [abs_ml_inv_def,bc_stack_ref_inv_def] \\ rfs[])
    \\ fs [APPEND] \\ IMP_RES_TAC pop_parts_lemma \\ fs []
    \\ Q.PAT_ASSUM `abs_ml_inv sssss refs
         (r1::r2::r3::r4::rr1::rr2::rrs,heap,a,sp) cs.heap_limit` MP_TAC
    \\ SIMP_TAC std_ss [abs_ml_inv_def] \\ REPEAT STRIP_TAC
    \\ fs [bc_stack_ref_inv_def] \\ rfs[]
    \\ Q.EXISTS_TAC `vals with
          <| stack := TL (TL (vals.stack)) ;
             reg15 := (x64_addr vs.current_heap rr2  30) ;
             reg13 := (x64_addr vs.current_heap rr2  30 
                      x64_addr vs.current_heap rr1  2) |>`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
         `TL (TL roots)`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [CONS_11,MAP,TL]
    \\ fs [bc_value_inv_def,small_int_w2n_lemma,x64_addr_def,GSYM w2w_def]
    \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p *
       cond (stack = Number (&w2n ((r13:word64) << 32 >>> 32))::
                     Number (&w2n ((r13:word64) >>> 32))::sss)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

(* top-level theorems about bignum operations *)

val n2iop_def = Define `
  n2iop (n:int) = if n = 0 then Add else
                  if n = 1 then Sub else
                  if n = 2 then Lt else
                  if n = 3 then Eq else
                  if n = 4 then Mul else
                  if n = 5 then Div else
                  if n = 6 then Mod else
                  if n = 7 then Dec else ARB`;

val perform_bignum_blast_lemma = blastLib.BBLAST_PROVE
  ``(w2w w << 1 = (w2w v << 1):word64) <=> (w = v:63 word)``

val heap_lookup_limit = prove(
  ``(heap_lookup ptr heap = SOME x) /\ heap_ok heap n ==> ptr < n``,
  REPEAT STRIP_TAC
  \\ IMP_RES_TAC ml_copying_gcTheory.heap_lookup_LESS
  \\ rfs [heap_ok_def]);

val mw_11 = prove(
  ``!n k. (mw n = mw k) <=> (n = k)``,
  HO_MATCH_MP_TAC mw_ind \\ REPEAT STRIP_TAC
  \\ ONCE_REWRITE_TAC [mw_def]
  \\ Cases_on `n = 0` \\ fs []
  \\ Cases_on `k = 0` \\ fs []
  \\ Cases_on `n = k` \\ fs []
  \\ METIS_TAC [DIVISION,ZERO_LT_dimword]);

val all_ops = prove(
  ``0 <= i /\ i <= 7:int ==>
    (i = 0) \/ (i = 1) \/ (i = 2) \/ (i = 3) \/
    (i = 4) \/ (i = 5) \/ (i = 6) \/ (i = 7)``,
  intLib.COOPER_TAC);

val MEM_n2l_LESS = prove(
  ``!k n. MEM x (n2l k n) /\ (k = 10) ==> x < k``,
  HO_MATCH_MP_TAC numposrepTheory.n2l_ind \\ REPEAT STRIP_TAC \\ fs []
  \\ NTAC 2 (POP_ASSUM MP_TAC)
  \\ ONCE_REWRITE_TAC [numposrepTheory.n2l_def]
  \\ fs [] \\ SRW_TAC [] [] \\ fs []) |> SIMP_RULE std_ss [];

val EVERY_ORD_int_to_str = prove(
  ``EVERY (\x. ORD x <> 0) (int_to_str i)``,
  fs [multiwordTheory.int_to_str_def] \\ SRW_TAC [] []
  \\ fs [integer_wordTheory.toString_def]
  \\ fs [ASCIInumbersTheory.num_to_dec_string_def,
         ASCIInumbersTheory.n2s_def,rich_listTheory.EVERY_REVERSE,EVERY_MAP]
  \\ fs [EVERY_MEM]
  \\ REPEAT STRIP_TAC \\ IMP_RES_TAC MEM_n2l_LESS
  \\ `(x = 0) \/ (x = 1) \/ (x = 2) \/ (x = 3) \/
      (x = 4) \/ (x = 5) \/ (x = 6) \/ (x = 7) \/
      (x = 8) \/ (x = 9)` by DECIDE_TAC \\ fs []);

val x64_print_stack_IF = prove(
  ``x64_print_stack_pre
      (po,output,po,
       if b then MAP (n2w o ORD) (int_to_str i) ++ 0x0w::stack else 0x0w::stack) /\
    (x64_print_stack
      (po,output,po,
       if b then MAP (n2w o ORD) (int_to_str i) ++ 0x0w::stack else 0x0w::stack) =
      (po,output ++ if b then MAP (n2w o ORD) (int_to_str i) else [],po,stack))``,
  REVERSE (Cases_on `b`) \\ fs []
  THEN1 (ONCE_REWRITE_TAC [x64_print_stack_def]
         \\ fs [LET_DEF,x64_pop_def])
  \\ MATCH_MP_TAC x64_print_stack_thm
  \\ fs [EVERY_ORD_int_to_str]);

val sort_vars = miscLib.sort_vars;

fun exists_inst var q =
  CONV_TAC(RESORT_EXISTS_CONV(sort_vars[var])) \\ Q.EXISTS_TAC q

val bignum_blast_lemma = blastLib.BBLAST_PROVE
  ``((7w && 8w * w + v = 0w) <=> (7w && v = 0w:word64)) /\
    ((7w && 8w * w + v2 + v = 0w) <=> (7w && v2 + v = 0w:word64)) /\
    ((7w && w = 0w) ==> ((7w && (w + v) = 0w) <=> (7w && v = 0w)))``

val array64_one_list = prove(
  ``array64 = one_list``,
  fs [FUN_EQ_THM] \\ ONCE_REWRITE_TAC [GSYM FUN_EQ_THM] \\ Induct_on `x'`
  \\ fs [x64_multiwordTheory.array64_def,one_list_def]);

val mwi_op_NIL_NIL_LENGTH = prove(
  ``(op <> Div) /\ (op <> Mod) ==>
    LENGTH (SND (mwi_op op (F,[]) (F,[]:word64 list))) < 4294967296``,
  Cases_on `op` \\ fs [] \\ EVAL_TAC);

val mwi_op_NIL_NIL_OK = prove(
  ``(op <> Div) /\ (op <> Mod) ==>
    mw_ok (SND (mwi_op op (F,[]) (F,[]:word64 list)))``,
  Cases_on `op` \\ fs [] \\ EVAL_TAC);

val small_int_mwi_op_NIL_NIL = prove(
  ``(op <> Div) /\ (op <> Mod) ==>
    small_int (mw2i (mwi_op op (F,[]) (F,[]:word64 list)))``,
  Cases_on `op` \\ fs [] \\ EVAL_TAC);

val mwi_op_value = prove(
  ``(op <> Div) /\ (op <> Mod) ==>
    (mwi_op op (F,[]) (F,[]:word64 list) = if op = Eq then i2mw 1 else i2mw 0) /\
    (int_op op 0 0 = if op = Eq then 1 else 0)``,
  Cases_on `op` \\ fs [] \\ EVAL_TAC);

val push_state_accesses = prove(
  ``((if b then x else y).local = if b then x.local else y.local) /\
    ((if b then x else y).code_mode = if b then x.code_mode else y.code_mode) /\
    ((if b then x else y).code_max_length = if b then x.code_max_length else y.code_max_length) /\
    ((if b then x else y).code_start = if b then x.code_start else y.code_start) /\
    ((if b then x else y).code = if b then x.code else y.code) /\
    ((if b then x else y).input = if b then x.input else y.input) /\
    ((if b then x else y).output = if b then x.output else y.output) /\
    ((if b then x else y).base_offset = if b then x.base_offset else y.base_offset) /\
    ((if b then x else y).handler = if b then x.handler else y.handler)``,
  Cases_on `b` \\ fs []);

val abs_ml_inv_Num_0 =
  abs_ml_inv_Num
  |> SPEC_ALL |> Q.INST [`n`|->`0`]
  |> SIMP_RULE std_ss [word_mul_n2w]

val abs_ml_inv_Num_1 =
  abs_ml_inv_Num
  |> SPEC_ALL |> Q.INST [`n`|->`1`]
  |> SIMP_RULE std_ss [word_mul_n2w]

val abs_ml_inv_1_0_swap_lemma =
  abs_ml_inv_stack_permute |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  |> Q.SPECL [`[(x2,r2);(x1,r1)]`,
              `[(x1,r1);(x2,r2)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM]

val abs_ml_inv_1_0_swap = prove(
  ``abs_ml_inv (x2::x1::stack) refs (r2::r1::roots,heap,a,sp) limit ==>
    abs_ml_inv (x1::x2::stack) refs (r1::r2::roots,heap,a,sp) limit``,
  MATCH_MP_TAC abs_ml_inv_1_0_swap_lemma
  \\ REPEAT STRIP_TAC \\ fs []);

val abs_ml_inv_1_0 = prove(
  ``abs_ml_inv (x1::x2::stack) refs (r1::r2::roots,heap,a,sp) limit ==>
    abs_ml_inv (Number 1::Number 0::stack) refs
      (Data 2w::Data 0w::roots,heap,a,sp) limit``,
  REPEAT STRIP_TAC
  \\ MATCH_MP_TAC (abs_ml_inv_Num_1 |> GEN_ALL)
  \\ Q.LIST_EXISTS_TAC [`x2`,`r2`]
  \\ MATCH_MP_TAC abs_ml_inv_1_0_swap \\ fs []
  \\ MATCH_MP_TAC (abs_ml_inv_Num_0 |> GEN_ALL)
  \\ Q.LIST_EXISTS_TAC [`x1`,`r1`] \\ fs []);

val abs_ml_inv_0_0 = prove(
  ``abs_ml_inv (x1::x2::stack) refs (r1::r2::roots,heap,a,sp) limit ==>
    abs_ml_inv (Number 0::Number 0::stack) refs
      (Data 0w::Data 0w::roots,heap,a,sp) limit``,
  REPEAT STRIP_TAC
  \\ MATCH_MP_TAC (abs_ml_inv_Num_0 |> GEN_ALL)
  \\ Q.LIST_EXISTS_TAC [`x2`,`r2`]
  \\ MATCH_MP_TAC abs_ml_inv_1_0_swap \\ fs []
  \\ MATCH_MP_TAC (abs_ml_inv_Num_0 |> GEN_ALL)
  \\ Q.LIST_EXISTS_TAC [`x1`,`r1`] \\ fs []);

val heap_inv_small_int_test = prove(
  ``(heap_inv (cs,Number i1,x2,x3,x4,refs,stack,s,i) vals ==>
     ((0x1w && vals.reg0 = 0x0w) <=> small_int i1)) /\
    (heap_inv (cs,x2,Number i1,x3,x4,refs,stack,s,i) vals ==>
     ((0x1w && vals.reg1 = 0x0w) <=> small_int i1))``,
  REPEAT STRIP_TAC \\ Cases_on `small_int i1` \\ fs []
  \\ fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,x64_addr_def]
  \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC \\ fs [heap_vars_ok_def]
  \\ blastLib.BBLAST_TAC);

val small_int_imp_lemma = prove(
  ``small_int i1 /\ (i1 <> 0) ==>
    (w2w:63 word->word64) (0x2w * n2w (Num i1))  1  0x0w``,
  fs [w2w_def,word_mul_n2w,WORD_MUL_LSL,small_int_def]
  \\ REPEAT STRIP_TAC
  \\ `(2 * Num i1) < 9223372036854775808 /\
      (2 * (2 * Num i1)) < 18446744073709551616` by intLib.COOPER_TAC \\ fs []
  \\ Cases_on `i1` \\ fs []);

val heap_inv_zero_test = prove(
  ``(heap_inv (cs,Number i1,x2,x3,x4,refs,stack,s,i) vals ==>
     ((vals.reg0 = 0x0w) <=> (i1 = 0))) /\
    (heap_inv (cs,x2,Number i1,x3,x4,refs,stack,s,i) vals ==>
     ((vals.reg1 = 0x0w) <=> (i1 = 0)))``,
  REPEAT STRIP_TAC \\ Cases_on `i1 = 0` \\ fs []
  \\ TRY (fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,x64_addr_def,small_int_def] \\ NO_TAC)
  \\ fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,x64_addr_def]
  \\ Cases_on `small_int i1` \\ fs []
  \\ fs [x64_addr_def,small_int_imp_lemma]
  \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC \\ fs [heap_vars_ok_def]
  \\ blastLib.BBLAST_TAC)

val small_int_imp_lemma2 = prove(
  ``small_int i1 /\ (i1 <> 0) ==>
    (w2w:63 word->word64) (0x2w * n2w (Num i1))  1 >>> 2  0x0w``,
  SIMP_TAC std_ss [GSYM w2n_11,w2n_lsr]
  \\ fs [w2w_def,word_mul_n2w,WORD_MUL_LSL,small_int_def]
  \\ REPEAT STRIP_TAC
  \\ `(2 * Num i1) < 9223372036854775808 /\
      (2 * (2 * Num i1)) < 18446744073709551616` by intLib.COOPER_TAC \\ fs []
  \\ Cases_on `i1` \\ fs []
  \\ fs [DIV_EQ_X] \\ DECIDE_TAC);

val heap_inv_zero_test_shift = prove(
  ``(heap_inv (cs,Number i1,x2,x3,x4,refs,stack,s,i) vals ==>
     ((vals.reg0 >>> 2 = 0x0w) <=> (i1 = 0))) /\
    (heap_inv (cs,x2,Number i1,x3,x4,refs,stack,s,i) vals ==>
     ((vals.reg1 >>> 2 = 0x0w) <=> (i1 = 0)))``,
  REPEAT STRIP_TAC \\ Cases_on `i1 = 0` \\ fs []
  \\ TRY (fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,x64_addr_def,small_int_def] \\ NO_TAC)
  \\ fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,x64_addr_def]
  \\ Cases_on `small_int i1` \\ fs []
  \\ fs [x64_addr_def,small_int_imp_lemma2]
  \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC \\ fs [heap_vars_ok_def]
  \\ blastLib.BBLAST_TAC)

val heap_inv_tests = LIST_CONJ
  [heap_inv_zero_test,heap_inv_small_int_test,heap_inv_zero_test_shift];

val num_size_1 = prove(
  ``small_int i1 /\ i1 <> 0 ==> (num_size (Number i1) = 1)``,
  SIMP_TAC std_ss [num_size_def,Once mw_def,small_int_def]
  \\ REPEAT STRIP_TAC
  \\ `Num (ABS i1) <> 0` by intLib.COOPER_TAC \\ fs []
  \\ `Num (ABS i1) < 18446744073709551616` by intLib.COOPER_TAC \\ fs []
  \\ IMP_RES_TAC arithmeticTheory.LESS_DIV_EQ_ZERO \\ fs []
  \\ EVAL_TAC);

val mw_ok_i2mw = prove(
  ``mw_ok (SND (i2mw i))``,
  fs [multiwordTheory.i2mw_def,multiwordTheory.mw_ok_n2mw]);

val mw_thm = prove(
  ``mw = n2mw``,
  fs [FUN_EQ_THM] \\ HO_MATCH_MP_TAC mw_ind
  \\ REPEAT STRIP_TAC
  \\ ONCE_REWRITE_TAC [mw_def,multiwordTheory.n2mw_def]
  \\ SRW_TAC [] []);

val mw2n_n2mw = multiwordTheory.mw2n_n2mw

val LESS_EQ_IMP_LENGTH_n2mw_LESS_EQ = prove(
  ``!m n. n <= m:num ==>
    (LENGTH ((n2mw n):word64 list) <= LENGTH ((n2mw m):word64 list))``,
  HO_MATCH_MP_TAC (mw_ind |> INST_TYPE [``:'a``|->``:64``])
  \\ REPEAT STRIP_TAC
  \\ ONCE_REWRITE_TAC [multiwordTheory.n2mw_def]
  \\ SRW_TAC [] [] THEN1 `F` by DECIDE_TAC
  \\ fs [] \\ FIRST_X_ASSUM MATCH_MP_TAC
  \\ fs [DIV_LE_X,RIGHT_ADD_DISTRIB]
  \\ STRIP_ASSUME_TAC (Q.SPEC `m` (MATCH_MP DIVISION
        (DECIDE ``0 < 18446744073709551616:num``)))
  \\ DECIDE_TAC) |> SPEC_ALL;

val abs_simp = prove(
  ``(ABS (&n) = &n) /\ (ABS (-&n) = &n)``,
  intLib.COOPER_TAC);

val IMP_LENGTH_FRONT = prove(
  ``(LENGTH xs = n + 1) ==>
    (LENGTH (FRONT xs) = n)``,
  `(xs = []) \/ ?y ys. xs = SNOC y ys` by METIS_TAC [SNOC_CASES]
  \\ FULL_SIMP_TAC std_ss [FRONT_SNOC] \\ fs [ADD1]);

val LENGTH_FRONT_mw_mul_by_single =
  MATCH_MP IMP_LENGTH_FRONT
  multiwordTheory.LENGTH_mw_mul_by_single

val LENGTH_mw_div = prove(
  ``LENGTH (mw_fix ys) <> 0 /\
    (mw_div xs ys = (xs1,ys1:'a word list,c)) ==>
    LENGTH xs1 <= LENGTH xs /\ LENGTH ys1 <= LENGTH ys``,
  fs [multiwordTheory.mw_div_def,LET_DEF]
  \\ SRW_TAC [] [LENGTH,rich_listTheory.LENGTH_REPLICATE]
  \\ SRW_TAC [] [LENGTH,rich_listTheory.LENGTH_REPLICATE]
  \\ `LENGTH (mw_fix xs) <= LENGTH xs` by fs [multiwordTheory.LENGTH_mw_fix]
  \\ `LENGTH (mw_fix ys) <= LENGTH ys` by fs [multiwordTheory.LENGTH_mw_fix]
  THEN1 DECIDE_TAC
  THEN1
   (Cases_on `mw_simple_div 0x0w (REVERSE (mw_fix xs)) (HD (mw_fix ys))`
    \\ Cases_on `r` \\ fs [] \\ SRW_TAC [] []
    \\ IMP_RES_TAC multiwordTheory.LENGTH_mw_simple_div \\ fs [] \\ DECIDE_TAC)
  THEN1
   (Cases_on `mw_simple_div 0x0w (REVERSE (mw_fix xs)) (HD (mw_fix ys))`
    \\ Cases_on `r` \\ fs [] \\ SRW_TAC [] []
    \\ IMP_RES_TAC multiwordTheory.LENGTH_mw_simple_div \\ fs [] \\ DECIDE_TAC)
  \\ Q.ABBREV_TAC `zs3 = (FRONT
              (mw_mul_by_single (calc_d (LAST (mw_fix ys),0x1w))
                 (mw_fix ys)))`
  \\ Q.ABBREV_TAC `zs2 = (LASTN (LENGTH (mw_fix ys))
              (mw_mul_by_single (calc_d (LAST (mw_fix ys),0x1w))
                 (mw_fix xs) ++ [0x0w]))`
  \\ Q.ABBREV_TAC `zs1 = (BUTLASTN (LENGTH (mw_fix ys))
              (mw_mul_by_single (calc_d (LAST (mw_fix ys),0x1w))
                 (mw_fix xs) ++ [0x0w]))`
  \\ Cases_on `mw_div_aux zs1 zs2 zs3`
  \\ `LENGTH zs3 = LENGTH (mw_fix ys)` by
   (UNABBREV_ALL_TAC \\ fs [LENGTH_FRONT_mw_mul_by_single])
  \\ `LENGTH zs2 = LENGTH (mw_fix ys)` by
   (UNABBREV_ALL_TAC \\ fs [LENGTH_FRONT_mw_mul_by_single]
    \\ MATCH_MP_TAC rich_listTheory.LENGTH_LASTN \\ fs []
    \\ fs [multiwordTheory.LENGTH_mw_mul_by_single]
    \\ DECIDE_TAC)
  \\ `LENGTH zs1 = (LENGTH (mw_fix xs) + 2) - LENGTH (mw_fix ys)` by
   (UNABBREV_ALL_TAC \\ fs [LENGTH_FRONT_mw_mul_by_single]
    \\ `LENGTH (mw_fix xs) + 2 =
        LENGTH (mw_mul_by_single (calc_d (LAST (mw_fix ys),0x1w))
                 (mw_fix xs) ++ [0x0w:'a word])` by
      (fs [multiwordTheory.LENGTH_mw_mul_by_single] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ MATCH_MP_TAC rich_listTheory.LENGTH_BUTLASTN \\ fs []
    \\ fs [multiwordTheory.LENGTH_mw_mul_by_single]
    \\ DECIDE_TAC)
  \\ `LENGTH zs2 = LENGTH zs3` by fs []
  \\ IMP_RES_TAC multiwordTheory.LENGTH_mw_div_aux
  \\ Cases_on `calc_d (LAST (mw_fix ys),0x1w)`
  \\ Cases_on `mw_simple_div 0x0w (REVERSE r) (n2w n)` \\ fs []
  \\ Cases_on `r'` \\ fs [] \\ SRW_TAC [] []
  \\ IMP_RES_TAC multiwordTheory.LENGTH_mw_simple_div \\ fs []
  \\ DECIDE_TAC);

val mw_addv_CONS_T = prove(
  ``mw_addv (x::xs) [] T = mw_addv (x::xs) [1w] F``,
  Cases_on `xs` \\ fs [multiwordTheory.mw_addv_def,LET_DEF]
  \\ AP_TERM_TAC
  \\ fs [multiwordTheory.single_add_def,multiwordTheory.b2w_def,
         multiwordTheory.b2n_def,word_arith_lemma1]);

val LENGTH_mw_addv_lemma =
  multiwordTheory.LENGTH_mw_addv |> GEN_ALL
  |> Q.SPECL [`[1w]`,`h::t'`] |> SIMP_RULE (srw_ss()) [ADD1];

val LENGTH_mw_subv_BETTER = prove(
  ``LENGTH (mw_subv xs ys) <= LENGTH xs``,
  fs [multiwordTheory.mw_subv_def]
  \\ MATCH_MP_TAC LESS_EQ_TRANS
  \\ Q.EXISTS_TAC `LENGTH (FST (mw_sub xs ys T))`
  \\ fs [multiwordTheory.LENGTH_mw_fix]
  \\ Cases_on `mw_sub xs ys T`
  \\ IMP_RES_TAC multiwordTheory.LENGTH_mw_sub
  \\ fs []);

val LENGTH_mwi_divmod = prove(
  ``LENGTH (mw_fix ys) <> 0 /\
    (mwi_divmod (s,xs) (t,ys) = (c,(x,xs1),(y,ys1:'a word list))) ==>
    LENGTH xs1 <= LENGTH xs + LENGTH ys /\
    LENGTH ys1 <= LENGTH xs + LENGTH ys``,
  fs [multiwordTheory.mwi_divmod_def]
  \\ Cases_on `mw_div xs ys` \\ Cases_on `r` \\ fs [LET_DEF]
  \\ Cases_on `s = t` \\ fs [] \\ SRW_TAC [] []
  \\ IMP_RES_TAC LENGTH_mw_div
  \\ `LENGTH (mw_fix ys) <= LENGTH ys` by fs [multiwordTheory.LENGTH_mw_fix]
  \\ `LENGTH (mw_fix q) <= LENGTH q` by fs [multiwordTheory.LENGTH_mw_fix]
  \\ `LENGTH (mw_fix q') <= LENGTH q'` by fs [multiwordTheory.LENGTH_mw_fix]
  \\ TRY DECIDE_TAC \\ fs []
  THEN1
   (Cases_on `mw_fix q` \\ fs [] THEN1 (EVAL_TAC \\ DECIDE_TAC)
    \\ fs [mw_addv_CONS_T] \\ ASSUME_TAC LENGTH_mw_addv_lemma
    \\ fs [] \\ DECIDE_TAC)
  \\ MATCH_MP_TAC LESS_EQ_TRANS
  \\ Q.EXISTS_TAC `LENGTH ys`
  \\ fs [LENGTH_mw_subv_BETTER]);

val LENGTH_int_op = prove(
  ``((op = Div) \/ (op = Mod) ==> j <> 0) ==>
    LENGTH (SND (i2mw (int_op op i j):(bool # word64 list))) <=
    num_size (Number i) + num_size (Number j) + 1``,
  REPEAT STRIP_TAC
  \\ `mwi_op op (i2mw i) (i2mw j) =
      i2mw (int_op op i j):(bool # word64 list)` by
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
  \\ POP_ASSUM (fn th => fs [GSYM th])
  \\ Cases_on `op` \\ fs [multiwordTheory.mwi_op_def] \\ SRW_TAC [] []
  \\ fs [multiwordTheory.mwi_add_def,
         multiwordTheory.mwi_sub_def,
         multiwordTheory.mwi_mul_def,
         multiwordTheory.mwi_div_def,
         multiwordTheory.mwi_mod_def,
         multiwordTheory.i2mw_def,LET_DEF]
  \\ SRW_TAC [] [num_size_def]
  \\ TRY (MATCH_MP_TAC (MATCH_MP (LESS_EQ_TRANS |> RW [GSYM AND_IMP_INTRO])
        (multiwordTheory.LENGTH_mw_addv |> UNDISCH)
          |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO]))
  \\ TRY (MATCH_MP_TAC (MATCH_MP (LESS_EQ_TRANS |> RW [GSYM AND_IMP_INTRO])
        (multiwordTheory.LENGTH_mw_subv |> SPEC_ALL |> UNDISCH)
          |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO]))
  \\ TRY (MATCH_MP_TAC (MATCH_MP (LESS_EQ_TRANS |> RW [GSYM AND_IMP_INTRO])
        (multiwordTheory.LENGTH_mw_fix |> SPEC_ALL)
          |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO]))
  \\ fs [multiwordTheory.LENGTH_mw_mul]
  \\ fs [mw_thm,mw2n_n2mw]
  \\ IMP_RES_TAC (DECIDE ``~(n <= m:num) ==> m <= n``)
  \\ IMP_RES_TAC LESS_EQ_IMP_LENGTH_n2mw_LESS_EQ
  \\ fs [] \\ REPEAT STRIP_TAC
  \\ fs [EVAL ``LENGTH (n2mw 1:word64 list)``]
  \\ fs [EVAL ``LENGTH (n2mw 0:word64 list)``]
  \\ TRY DECIDE_TAC
  \\ `?x1 x2 x3 x4 x5.
         (mwi_divmod
           (i < 0,n2mw (Num (ABS i)))
           (j < 0,n2mw (Num (ABS j)))) =
              (x1,(x2,x3),x4,x5:word64 list)` by METIS_TAC [PAIR]
  \\ `LENGTH (mw_fix (n2mw (Num (ABS j))):word64 list) <> 0` by
   (fs [LENGTH_NIL,multiwordTheory.mw_fix_NIL,multiwordTheory.mw2n_n2mw]
    \\ intLib.COOPER_TAC)
  \\ IMP_RES_TAC LENGTH_mwi_divmod \\ fs []
  \\ DECIDE_TAC);

val num_length_lemma =
  MATCH_MP (RW [GSYM AND_IMP_INTRO] LESS_EQ_LESS_TRANS)
    (LENGTH_int_op |> UNDISCH)
  |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO]

val small_int_num_exists = prove(
  ``small_int i ==> ?k. (i = & k) /\ k < 2**62``,
  Cases_on `i` \\ fs [small_int_def]);

val IntData_def = Define `
  IntData i = DataOnly (i < 0) (mw (Num (ABS i)):word64 list)`;

val isSomeUsed_def = Define `
  (isSomeUsed NONE = F) /\
  (isSomeUsed (SOME (Unused _)) = F) /\
  (isSomeUsed _ = T)`;

val isSomeUsed_heap_lookup_IntData = prove(
  ``!sp ys1 ptr.
      (sp = d + num_size (Number k) + 2) ==>
      (isSomeUsed (heap_lookup ptr (ys1 ++ Unused (sp-1)::ys2)) ==>
       (heap_lookup ptr (ys1 ++ IntData k::Unused d::ys2:(63,64) ml_heap) =
        heap_lookup ptr (ys1 ++ Unused (sp-1)::ys2)))``,
  fs [] \\ Induct THEN1
   (fs []
    \\ ONCE_REWRITE_TAC [heap_lookup_def] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [heap_lookup_def]
    \\ fs [el_length_def,IntData_def,DataOnly_def,GSYM num_size_def]
    \\ Cases_on `ptr = 0` THEN1 fs [isSomeUsed_def] \\ fs []
    \\ Cases_on `ptr < d + num_size (Number k) + 2  1 + 1`
    THEN1 fs [isSomeUsed_def] \\ fs []
    \\ `~(ptr <= num_size (Number k) + 1) /\ 0 < d + 1 /\
        ~(ptr < num_size (Number k) + 1 + (d + 1)) /\
        ~(ptr < num_size (Number k) + 1)` by DECIDE_TAC
    \\ FULL_SIMP_TAC bool_ss [GSYM SUB_PLUS]
    \\ `!l:num. d + l + 2  1 + 1 = l + 1 + (d + 1)` by DECIDE_TAC
    \\ fs [])
  \\ SIMP_TAC std_ss [APPEND]
  \\ ONCE_REWRITE_TAC [heap_lookup_def] \\ REPEAT STRIP_TAC
  \\ Cases_on `ptr = 0` THEN1 fs [isSomeUsed_def] \\ fs []
  \\ Cases_on `ptr < el_length h` THEN1 fs [isSomeUsed_def] \\ fs []);

val isSomeDataElement_heap_lookup_IntData = prove(
  ``!sp ys1 ptr.
      (sp = d + num_size (Number k) + 2) ==>
      (isSomeDataElement (heap_lookup ptr
           (ys1 ++ Unused (sp-1)::ys2:(63,64) ml_heap)) ==>
       isSomeDataElement (heap_lookup ptr
           (ys1 ++ IntData k::Unused d::ys2)))``,
  REPEAT STRIP_TAC
  \\ fs [isSomeDataElement_def]
  \\ MP_TAC (isSomeUsed_heap_lookup_IntData |> SPEC_ALL) \\ fs []
  \\ fs [isSomeUsed_def]);

val FILTER_APPEND_NIL = prove(
  ``!xs ys. (FILTER P (xs++ys) = []) <=> (FILTER P xs = []) /\ (FILTER P ys = [])``,
  Induct \\ fs [] \\ SRW_TAC [] []);

val isForwardPointer_IntData = prove(
  ``~isForwardPointer (IntData k)``,
  fs [IntData_def,DataOnly_def,isForwardPointer_def]);

val EVERY2_MONO = prove(
  ``!xs ys.
      (!x y. MEM x xs /\ MEM y ys /\ P x y ==> Q x y) ==>
      EVERY2 P xs ys ==> EVERY2 Q xs ys``,
  Induct \\ Cases_on `ys` \\ fs []);

val bc_value_inv_Unused = prove(
  ``!x y f h:(63,64) ml_heap.
      bc_value_inv x
        (y,f,ys1 ++ Unused (d + num_size (Number k) + 2 - 1)::ys2) 
      bc_value_inv x (y,f,ys1 ++ IntData k::Unused d::ys2:(63,64) ml_heap)``,
  recInduct bc_value_inv_ind \\ fs [] \\ REPEAT STRIP_TAC \\ fs [bc_value_inv_def]
  THEN1
   (Cases_on `small_int i` \\ fs [DataOnly_def]
    \\ REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC (isSomeUsed_heap_lookup_IntData
            |> SIMP_RULE std_ss [] |> SPEC_ALL) \\ fs [isSomeUsed_def])
  \\ Cases_on `vs = []` \\ fs []
  \\ Q.EXISTS_TAC `xs` \\ fs []
  \\ REPEAT STRIP_TAC
  THEN1
   (Q.PAT_ASSUM `LIST_REL xx tt yy` MP_TAC
    \\ MATCH_MP_TAC EVERY2_MONO \\ fs []
    \\ REPEAT STRIP_TAC
    \\ fs [AND_IMP_INTRO]
    \\ FIRST_X_ASSUM MATCH_MP_TAC \\ fs []
    \\ METIS_TAC [])
  \\ Q.PAT_ASSUM `xxx = SOME (BlockRep n xs)` (fn th => fs [GSYM th]
         THEN ASSUME_TAC th)
  \\ MATCH_MP_TAC (isSomeUsed_heap_lookup_IntData |> SIMP_RULE (std_ss++ARITH_ss) [])
  \\ fs [] \\ EVAL_TAC) |> SIMP_RULE std_ss [];

val abs_ml_inv_Num_BIG_lemma = prove(
  ``abs_ml_inv (stack) refs
      (roots,ys1 ++ Unused (sp - 1)::ys2,heap_length (ys1:(63,64) ml_heap),sp) l /\
    (sp = d + num_size (Number k) + 2) ==>
    abs_ml_inv (stack) refs
      (roots,
       ys1 ++ IntData k::Unused d::ys2,
       heap_length ys1 + num_size (Number k) + 1,
       sp - num_size (Number k) - 1) l``,
  fs [abs_ml_inv_def]
  \\ REPEAT STRIP_TAC \\ fs []
  THEN1
   (fs [roots_ok_def]
    \\ REPEAT STRIP_TAC \\ RES_TAC
    \\ MATCH_MP_TAC (MP_CANON isSomeDataElement_heap_lookup_IntData)
    \\ fs [])
  THEN1
   (fs [heap_ok_def,FILTER_APPEND_NIL,isForwardPointer_IntData]
    \\ FULL_SIMP_TAC std_ss [isForwardPointer_def]
    \\ REPEAT STRIP_TAC THEN1
     (fs [heap_length_def,heap_length_APPEND,el_length_def,
           IntData_def,DataOnly_def]
      \\ fs [GSYM heap_length_def,mw_thm,num_size_def]
      \\ REPEAT STRIP_TAC)
    \\ MATCH_MP_TAC (MP_CANON isSomeDataElement_heap_lookup_IntData |> SIMP_RULE(std_ss++ARITH_ss)[])
    \\ fs [] \\ FIRST_X_ASSUM MATCH_MP_TAC
    \\ fs [IntData_def,DataOnly_def] \\ SRW_TAC [] []
    \\ fs [] \\ METIS_TAC [])
  THEN1
   (fs [unused_space_inv_def] \\ REPEAT STRIP_TAC
    \\ fs [heap_lookup_APPEND,DECIDE ``~(n+m+1<n:num)``]
    \\ `heap_length ys1 + num_size (Number k) + 1 - heap_length ys1 =
        num_size (Number k) + 1` by DECIDE_TAC \\ fs []
    \\ ONCE_REWRITE_TAC [heap_lookup_def] \\ fs []
    \\ fs [el_length_def,IntData_def,DataOnly_def,num_size_def,mw_thm]
    \\ ONCE_REWRITE_TAC [heap_lookup_def] \\ fs []
    \\ DECIDE_TAC)
  \\ fs [bc_stack_ref_inv_def]
  \\ Q.EXISTS_TAC `f` \\ fs []
  \\ fs [INJ_DEF] \\ REPEAT STRIP_TAC
  THEN1 (MATCH_MP_TAC (MP_CANON isSomeDataElement_heap_lookup_IntData |> SIMP_RULE(std_ss++ARITH_ss)[]) \\ fs [])
  THEN1
   (Q.PAT_ASSUM `LIST_REL PP stack roots` MP_TAC
    \\ MATCH_MP_TAC EVERY2_MONO \\ fs []
    \\ METIS_TAC [bc_value_inv_Unused|>SIMP_RULE(std_ss++ARITH_ss)[]])
  \\ fs [bc_ref_inv_def] \\ RES_TAC
  \\ Cases_on `FLOOKUP f n` \\ fs []
  \\ Cases_on `FLOOKUP refs n` \\ fs []
  \\ REVERSE (Cases_on `x'`) \\ fs []
  THEN1
   (Q.PAT_ASSUM `xxx = SOME (Bytes l')` (fn th => fs [GSYM th]
           THEN ASSUME_TAC th)
    \\ MATCH_MP_TAC (isSomeUsed_heap_lookup_IntData |> SIMP_RULE (std_ss++ARITH_ss) [])
    \\ fs [] \\ EVAL_TAC)
  \\ Q.EXISTS_TAC `zs` \\ fs []
  \\ REPEAT STRIP_TAC
  THEN1
   (Q.PAT_ASSUM `xxx = SOME (RefBlock zs)` (fn th => fs [GSYM th]
           THEN ASSUME_TAC th)
    \\ MATCH_MP_TAC (isSomeUsed_heap_lookup_IntData |> SIMP_RULE (std_ss++ARITH_ss) [])
    \\ fs [] \\ EVAL_TAC)
  \\ Q.PAT_ASSUM `LIST_REL xx yy tt` MP_TAC
  \\ MATCH_MP_TAC EVERY2_MONO \\ fs []
  \\ METIS_TAC [bc_value_inv_Unused|>SIMP_RULE(std_ss++ARITH_ss)[]]);

val abs_ml_inv_Num_BIG = prove(
  ``abs_ml_inv (x1::stack) refs
      (r1::roots,ys1 ++ Unused (sp - 1)::(ys2:(63,64) ml_heap),heap_length ys1,sp) l /\
    (sp = d + num_size (Number k) + 2) /\ ~small_int k ==>
    abs_ml_inv (Number k::stack) refs
      (Pointer (heap_length ys1)::roots,
       ys1 ++ IntData k::Unused d::ys2,
       heap_length ys1 + num_size (Number k) + 1,
       sp - num_size (Number k) - 1) l``,
  REPEAT STRIP_TAC
  \\ IMP_RES_TAC abs_ml_inv_Num_BIG_lemma \\ POP_ASSUM MP_TAC
  \\ POP_ASSUM MP_TAC
  \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ REPEAT STRIP_TAC
  \\ fs [abs_ml_inv_def]
  \\ REPEAT STRIP_TAC THEN1
   (fs [roots_ok_def] \\ REPEAT STRIP_TAC \\ fs []
    \\ fs [heap_lookup_APPEND]
    \\ fs [heap_lookup_def,IntData_def,DataOnly_def,isSomeDataElement_def])
  \\ fs [bc_stack_ref_inv_def]
  \\ Q.EXISTS_TAC `f` \\ fs [reachable_refs_def]
  \\ REVERSE (REPEAT STRIP_TAC) \\ fs [] THEN1 (METIS_TAC [])
  \\ SRW_TAC [] [] \\ fs [get_refs_def]
  \\ fs [bc_value_inv_def]
  \\ fs [heap_lookup_APPEND]
  \\ fs [heap_lookup_def,IntData_def,DataOnly_def,isSomeDataElement_def])

val small_int_IMP_i2mw = prove(
  ``bc_value_inv (Number i1) (r1,f,heap) /\ small_int i1 /\ (i1 <> 0) ==>
    (i2mw i1 = (F,[x64_addr vs.current_heap r1 >>> 2]))``,
  fs [bc_value_inv_def] \\ REPEAT STRIP_TAC \\ fs [x64_addr_def]
  \\ fs [multiwordTheory.i2mw_def,small_int_def]
  \\ ONCE_REWRITE_TAC [multiwordTheory.n2mw_def]
  \\ SRW_TAC [] []
  THEN1 intLib.COOPER_TAC
  THEN1 intLib.COOPER_TAC
  \\ ONCE_REWRITE_TAC [GSYM w2n_11]
  \\ REWRITE_TAC [w2n_lsr]
  \\ fs [w2w_def,w2n_n2w,n2w_w2n,WORD_MUL_LSL,word_mul_n2w]
  \\ `(2 * Num i1) < 9223372036854775808` by intLib.COOPER_TAC \\ fs []
  \\ `Num (ABS i1) < 18446744073709551616 /\
      (ABS i1 = i1)` by intLib.COOPER_TAC \\ fs []
  \\ `(2 * (2 * Num i1)) < 18446744073709551616` by intLib.COOPER_TAC \\ fs []
  \\ fs [MULT_ASSOC]
  \\ fs [ONCE_REWRITE_RULE [MULT_COMM] MULT_DIV]
  \\ `Num i1 DIV 18446744073709551616 = 0` by fs [DIV_EQ_X]
  \\ fs [] \\ EVAL_TAC);

val heap_lookup_DataOnly_in_split = prove(
  ``(heap_lookup ptr (ys1 ++ [Unused (sp  1)] ++ ys2) =
      SOME (DataOnly (i1 < 0) (mw (Num (ABS i1))))) ==>
    ?other.
      (x64_heap vs.current_heap ys1 vs.current_heap vs.current_heap *
       x64_heap (n2w (8 * heap_length (ys1 ++ [Unused (sp  1)])) +
        vs.current_heap) ys2 vs.current_heap vs.current_heap =
       other * x64_el (x64_addr vs.current_heap (Pointer ptr) + 1w)
         (DataOnly (i1 < 0) (n2mw (Num (ABS i1))))
            vs.current_heap vs.current_heap)``,
  REPEAT STRIP_TAC \\ fs [heap_lookup_APPEND]
  \\ Cases_on `ptr < heap_length (ys1 ++ [Unused (sp - 1)])` \\ fs []
  THEN1
   (Cases_on `ptr < heap_length ys1` \\ fs []
    THEN1
     (IMP_RES_TAC heap_lookup_SPLIT
      \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,
           SEP_CLAUSES,x64_addr_def,WORD_MUL_LSL,word_mul_n2w,
           AC MULT_COMM MULT_ASSOC,AC WORD_ADD_COMM WORD_ADD_ASSOC,mw_thm]
      \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1' vs.current_heap
        vs.current_heap * x64_heap (vs.current_heap + n2w (8 *
        heap_length (ys1' ++ [DataOnly (i1 < 0) (mw (Num (ABS
        i1)))]))) ys2' vs.current_heap vs.current_heap * x64_heap
        (vs.current_heap + n2w (8 * heap_length ((ys1':(63,64) ml_heap) ++ [DataOnly
        (i1 < 0) (mw (Num (ABS i1)):word64 list)] ++ ys2' ++ [Unused (sp - 1)])))
        ys2 vs.current_heap vs.current_heap`
      \\ fs [AC STAR_ASSOC STAR_COMM,mw_thm])
    \\ fs [heap_lookup_def,DataOnly_def])
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,
           SEP_CLAUSES,x64_addr_def,WORD_MUL_LSL,word_mul_n2w,
           AC MULT_COMM MULT_ASSOC,AC WORD_ADD_COMM WORD_ADD_ASSOC]
  \\ IMP_RES_TAC (DECIDE ``~(n < m) /\ (n - m = k:num) ==> (n = k + m)``)
  \\ fs [heap_length_APPEND]
  \\ FULL_SIMP_TAC std_ss [x64_heap_APPEND,x64_heap_def,LEFT_ADD_DISTRIB,
           SEP_CLAUSES,x64_addr_def,WORD_MUL_LSL,word_mul_n2w, word_add_n2w,
           AC MULT_COMM MULT_ASSOC,AC WORD_ADD_COMM WORD_ADD_ASSOC,mw_thm]
  \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC]
  \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
       vs.current_heap * (x64_heap (vs.current_heap + n2w (heap_length
       ys1 * 8 + 8 * heap_length ([Unused (sp - 1)]:(63,64) ml_heap))) ys1'
       vs.current_heap vs.current_heap * x64_heap (vs.current_heap +
       n2w (heap_length ys1 * 8 +
       8 * heap_length ([Unused (sp - 1)]:(63,64) ml_heap) +
       (heap_length ys1' * 8 + 8 * heap_length ([DataOnly (i1 < 0) (mw
       (Num (ABS i1)))]:(63,64) ml_heap)))) ys2' vs.current_heap vs.current_heap)`
  \\ fs [AC STAR_ASSOC STAR_COMM,mw_thm]);

local fun fs x = full_simp_tac(srw_ss())x in
val heap_lookup_DataOnly_in_split_two_lemma = prove(
  ``(heap_lookup ptr1 (ys1 ++ [Unused (sp  1)] ++ ys2) =
      SOME (DataOnly (i1 < 0) (mw (Num (ABS i1))))) /\
    (heap_lookup ptr2 (ys1 ++ [Unused (sp  1)] ++ ys2) =
      SOME (DataOnly (i2 < 0) (mw (Num (ABS i2))))) /\
    ptr1 < ptr2 ==>
    ?other.
      (x64_heap vs.current_heap ys1 vs.current_heap vs.current_heap *
       x64_heap (n2w (8 * heap_length (ys1 ++ [Unused (sp  1)])) +
        vs.current_heap) ys2 vs.current_heap vs.current_heap =
       other *
       x64_el (x64_addr vs.current_heap (Pointer ptr1) + 1w)
         (DataOnly (i1 < 0) (n2mw (Num (ABS i1))))
            vs.current_heap vs.current_heap *
       x64_el (x64_addr vs.current_heap (Pointer ptr2) + 1w)
         (DataOnly (i2 < 0) (n2mw (Num (ABS i2))))
            vs.current_heap vs.current_heap)``,
  REPEAT STRIP_TAC \\ fs [heap_lookup_APPEND]
  \\ Cases_on `ptr1 < heap_length (ys1 ++ [Unused (sp - 1)])` \\ fs []
  THEN1
   (REVERSE (Cases_on `ptr1 < heap_length ys1`) \\ fs []
    THEN1 (fs [heap_lookup_def,DataOnly_def])
    \\ Cases_on `ptr2 < heap_length (ys1 ++ [Unused (sp  1)])` \\ fs []
    THEN1
     (REVERSE (Cases_on `ptr2 < heap_length ys1`) \\ fs []
      THEN1 (fs [heap_lookup_def,DataOnly_def])
      \\ Q.PAT_ASSUM `heap_lookup ptr2 ys1 = xxx` MP_TAC
      \\ IMP_RES_TAC heap_lookup_SPLIT \\ fs []
      \\ fs [heap_lookup_APPEND]
      \\ fs [heap_length_APPEND]
      \\ fs [heap_length_def,el_length_def,DataOnly_def]
      \\ fs [GSYM heap_length_def]
      \\ `~(ptr2 < heap_length ys1')` by DECIDE_TAC \\ fs []
      \\ Cases_on `ptr2 < heap_length ys1' +
           (LENGTH (mw (Num (ABS i1)):word64 list) + 1)` \\ fs []
      THEN1 (fs [heap_lookup_def] \\ REPEAT STRIP_TAC \\ `F` by DECIDE_TAC)
      \\ REPEAT STRIP_TAC
      \\ IMP_RES_TAC heap_lookup_SPLIT \\ fs []
      \\ fs [x64_heap_APPEND,x64_heap_def,SEP_CLAUSES,mw_thm]
      \\ Q.ABBREV_TAC `x1 = n2mw (Num (ABS i1)):word64 list`
      \\ Q.ABBREV_TAC `x2 = n2mw (Num (ABS i2)):word64 list`
      \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1' vs.current_heap
           vs.current_heap * x64_heap (n2w (8 * heap_length (ys1' ++
           [DataElement [] (LENGTH x1) (NumTag (i1 < 0),x1)])) +
           vs.current_heap) ys1'' vs.current_heap vs.current_heap *
           x64_heap (n2w (8 * heap_length (ys1' ++ [DataElement []
           (LENGTH x1) (NumTag (i1 < 0),x1)] ++ ys1'' ++ [DataElement
           [] (LENGTH x2) (NumTag (i2 < 0),x2)])) + vs.current_heap)
           ys2'' vs.current_heap vs.current_heap * x64_heap (n2w (8 *
           (heap_length ys1' + (LENGTH x1 + 1) + heap_length (ys1'' ++
           [DataElement [] (LENGTH x2) (NumTag (i2 < 0),x2)] ++ ys2'')
           + (sp  1 + 1))) + vs.current_heap) ys2 vs.current_heap
           vs.current_heap` \\ fs [AC STAR_ASSOC STAR_COMM]
      \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
      \\ fs [STAR_ASSOC]
      \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
      \\ `ptr2 = (heap_length ys1' + (LENGTH x1 + 1)) +
                 heap_length ys1''` by DECIDE_TAC \\ fs []
      \\ fs [WORD_MUL_LSL,word_mul_n2w,LEFT_ADD_DISTRIB,
             heap_length_APPEND,x64_addr_def]
      \\ fs [heap_length_def,el_length_def,AC ADD_COMM ADD_ASSOC,LEFT_ADD_DISTRIB]
      \\ fs [AC STAR_ASSOC STAR_COMM])
    \\ IMP_RES_TAC heap_lookup_SPLIT \\ fs []
    \\ fs [heap_lookup_APPEND]
    \\ fs [heap_length_APPEND]
    \\ fs [heap_length_def,el_length_def,DataOnly_def]
    \\ fs [GSYM heap_length_def]
    \\ REPEAT STRIP_TAC
    \\ fs [x64_heap_APPEND,x64_heap_def,SEP_CLAUSES,mw_thm]
    \\ Q.ABBREV_TAC `x1 = n2mw (Num (ABS i1)):word64 list`
    \\ Q.ABBREV_TAC `x2 = n2mw (Num (ABS i2)):word64 list`
    \\ fs [WORD_MUL_LSL,word_mul_n2w,LEFT_ADD_DISTRIB,
           heap_length_APPEND,x64_addr_def]
    \\ fs [heap_length_def,el_length_def,AC ADD_COMM ADD_ASSOC,LEFT_ADD_DISTRIB]
    \\ fs [GSYM heap_length_def]
    \\ IMP_RES_TAC (DECIDE ``~(p < n) /\ (p - n = m) ==> (p = n + m:num)``)
    \\ fs [WORD_MUL_LSL,word_mul_n2w,LEFT_ADD_DISTRIB,
           heap_length_APPEND,x64_addr_def]
    \\ fs [heap_length_def,el_length_def,AC ADD_COMM ADD_ASSOC,LEFT_ADD_DISTRIB]
    \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1'' vs.current_heap
         vs.current_heap * x64_heap (n2w (8 + (8 * LENGTH x1 + 8 * SUM
         (MAP el_length ys1''))) + vs.current_heap) ys2''
         vs.current_heap vs.current_heap * (x64_heap (n2w (8 + (8 + (8
         * LENGTH x1 + (8 * SUM (MAP el_length ys1'') + (8 * SUM (MAP
         el_length ys2'') + 8 * (sp  1)))))) + vs.current_heap) ys1'
         vs.current_heap vs.current_heap * x64_heap (n2w (8 + (8 + (8
         * LENGTH x1 + (8 * SUM (MAP el_length ys1'') + (8 * SUM (MAP
         el_length ys2'') + 8 * (sp  1)))))) + n2w (8 + (8 * LENGTH
         x2 + 8 * SUM (MAP el_length ys1'))) + vs.current_heap) ys2'
         vs.current_heap vs.current_heap)`
    \\ fs [AC STAR_COMM STAR_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC]
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
    \\ fs [STAR_ASSOC]
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
  \\ `~(ptr2 < heap_length (ys1 ++ [Unused (sp  1)]))` by DECIDE_TAC \\ fs []
  \\ Q.PAT_ASSUM `heap_lookup pp ys2 = xxx` MP_TAC
  \\ IMP_RES_TAC heap_lookup_SPLIT \\ fs []
  \\ fs [heap_lookup_APPEND]
  \\ fs [heap_length_APPEND]
  \\ fs [heap_length_def,el_length_def,DataOnly_def]
  \\ fs [GSYM heap_length_def]
  \\ IMP_RES_TAC (DECIDE ``~(p < n) /\ (p - n = m) ==> (p = n + m:num)``)
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC) \\ POP_ASSUM (K ALL_TAC)
  \\ POP_ASSUM (fn th => fs [th])
  \\ STRIP_TAC \\ fs [DECIDE ``0 < n + (m + 1:num)``]
  \\ POP_ASSUM (fn th => fs [th]) \\ fs [mw_thm]
  \\ Q.ABBREV_TAC `x1 = n2mw (Num (ABS i1)):word64 list`
  \\ Q.ABBREV_TAC `x2 = n2mw (Num (ABS i2)):word64 list`
  \\ `~(ptr2 < heap_length ys1 + (sp  1 + 1) + heap_length ys1')` by DECIDE_TAC
  \\ fs []
  \\ Cases_on `ptr2 < heap_length ys1 + (sp  1 + 1) + (heap_length ys1'
       + (LENGTH x1 + 1))` \\ fs [] THEN1
   (fs [heap_lookup_def] \\ REPEAT STRIP_TAC
    \\ IMP_RES_TAC (DECIDE ``~(p < m) /\ p <= m:num ==> (p = m)``) \\ fs [])
  \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC heap_lookup_SPLIT \\ fs []
  \\ fs [heap_lookup_APPEND]
  \\ fs [heap_length_APPEND]
  \\ fs [heap_length_def,el_length_def,DataOnly_def]
  \\ fs [GSYM heap_length_def]
  \\ REPEAT STRIP_TAC
  \\ fs [x64_heap_APPEND,x64_heap_def,SEP_CLAUSES,mw_thm]
  \\ Q.ABBREV_TAC `x1 = n2mw (Num (ABS i1)):word64 list`
  \\ Q.ABBREV_TAC `x2 = n2mw (Num (ABS i2)):word64 list`
  \\ fs [WORD_MUL_LSL,word_mul_n2w,LEFT_ADD_DISTRIB,
         heap_length_APPEND,x64_addr_def]
  \\ fs [heap_length_def,el_length_def,AC ADD_COMM ADD_ASSOC,LEFT_ADD_DISTRIB]
  \\ fs [GSYM heap_length_def]
  \\ fs [GSYM SUB_PLUS,ADD_ASSOC]
  \\ fs [AC ADD_COMM ADD_ASSOC]
  \\ IMP_RES_TAC (DECIDE ``~(p < n) /\ (p - n = m) ==> (p = n + m:num)``)
  \\ fs [WORD_MUL_LSL,word_mul_n2w,LEFT_ADD_DISTRIB,
         heap_length_APPEND,x64_addr_def]
  \\ fs [heap_length_def,el_length_def,AC ADD_COMM ADD_ASSOC,LEFT_ADD_DISTRIB]
  \\ fs [GSYM SUB_PLUS,ADD_ASSOC]
  \\ fs [AC ADD_COMM ADD_ASSOC]
  \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
        vs.current_heap * (x64_heap (n2w (8 + (8 * SUM (MAP el_length
        ys1) + 8 * (sp  1))) + vs.current_heap) ys1' vs.current_heap
        vs.current_heap * x64_heap (n2w (8 + (8 * LENGTH x1 + 8 * SUM
        (MAP el_length ys1'))) + n2w (8 + (8 * SUM (MAP el_length ys1)
        + 8 * (sp  1))) + vs.current_heap) ys1'' vs.current_heap
        vs.current_heap * x64_heap (n2w (8 + (8 * SUM (MAP el_length
        ys1) + 8 * (sp  1))) + n2w (16 + (8 * LENGTH x1 + (8 * LENGTH
        x2 + (8 * SUM (MAP el_length ys1') + 8 * SUM (MAP el_length
        ys1''))))) + vs.current_heap) ys2 vs.current_heap
        vs.current_heap)`
  \\ fs [AC STAR_COMM STAR_ASSOC]
  \\ fs [AC STAR_COMM STAR_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC]
  \\ fs [ADD_ASSOC]
  \\ fs [AC STAR_COMM STAR_ASSOC]);
end

val star_lemma = prove(
  ``a1 * a2 * a3 = STAR a1 (a3 * a2)``,
  fs [AC STAR_COMM STAR_ASSOC]);

val heap_lookup_DataOnly_in_split_two = prove(
  ``(heap_lookup ptr1 (ys1 ++ [Unused (sp  1)] ++ ys2) =
      SOME (DataOnly (i1 < 0) (mw (Num (ABS i1))))) /\
    (heap_lookup ptr2 (ys1 ++ [Unused (sp  1)] ++ ys2) =
      SOME (DataOnly (i2 < 0) (mw (Num (ABS i2))))) /\
    ptr1 <> ptr2 ==>
    ?other.
      (x64_heap vs.current_heap ys1 vs.current_heap vs.current_heap *
       x64_heap (n2w (8 * heap_length (ys1 ++ [Unused (sp  1)])) +
        vs.current_heap) ys2 vs.current_heap vs.current_heap =
       other *
       x64_el (x64_addr vs.current_heap (Pointer ptr1) + 1w)
         (DataOnly (i1 < 0) (n2mw (Num (ABS i1))))
            vs.current_heap vs.current_heap *
       x64_el (x64_addr vs.current_heap (Pointer ptr2) + 1w)
         (DataOnly (i2 < 0) (n2mw (Num (ABS i2))))
            vs.current_heap vs.current_heap)``,
  REPEAT STRIP_TAC
  \\ `ptr1 < ptr2 \/ ptr2 < ptr1` by DECIDE_TAC
  THEN1 (MATCH_MP_TAC heap_lookup_DataOnly_in_split_two_lemma \\ fs [])
  \\ ONCE_REWRITE_TAC [star_lemma]
  \\ fs [STAR_ASSOC]
  \\ MATCH_MP_TAC heap_lookup_DataOnly_in_split_two_lemma \\ fs []);

val star_reorder = prove(
  ``a1 * a2 * a3 * a4 * a5 * a6 * a7 * a8 =
    a2 * a3 * a4 * a5 * a7 * a8 * (STAR a1 a6)``,
  fs [AC STAR_ASSOC STAR_COMM]);

val MOD_LESS_LEMMA = prove(
  ``n < 281474976710656 ==>
    n MOD 18446744073709551616 < 281474976710656``,
  REPEAT STRIP_TAC
  \\ `n < 18446744073709551616` by DECIDE_TAC \\ fs []);

val LENGTH_n2mw_Num_ABS_EQ_0 = prove(
  ``(LENGTH (n2mw (Num (ABS i)):word64 list) = 0) <=> (i = 0)``,
  fs [LENGTH_NIL,multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC);

val x64_header_NOT_ZERO = prove(
  ``num_size (Number i1) < 4294967296 /\ i1 <> 0 ==>
    (x64_header (n,n2mw (Num (ABS i1)):word64 list) <> 0w)``,
  fs [x64_multiwordTheory.x64_header_def,GSYM word_mul_n2w,num_size_def,mw_thm]
  \\ fs [GSYM LENGTH_n2mw_Num_ABS_EQ_0]
  \\ Q.SPEC_TAC (`LENGTH (n2mw (Num (ABS i1)):word64 list)`,`l`)
  \\ NTAC 2 STRIP_TAC
  \\ `n2w l <+ 4294967296w:word64 /\ n2w l <> 0w:word64` by ALL_TAC THEN1
    (`l < 18446744073709551616` by DECIDE_TAC \\ fs [WORD_LO])
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
  \\ Cases_on `n` \\ FULL_SIMP_TAC std_ss [] \\ blastLib.BBLAST_TAC);

val mw2i_ID = prove(
  ``mw2i (i1 < 0,n2mw (Num (ABS i1))) = i1``,
  Cases_on `i1 < 0`
  \\ fs [multiwordTheory.mw2i_def,multiwordTheory.mw2n_n2mw]
  \\ intLib.COOPER_TAC);

val star_reorder_lemma5 = prove(
  ``a1 * a2 * a3 * a4 * a5 * a6 * a7 * a8 * a9 =
    a2 * a3 * a4 * a5 * a6 * a9 * a8 * (STAR a1 a7)``,
  SIMP_TAC std_ss [AC STAR_COMM STAR_ASSOC]);

val star_reorder_lemma6 = prove(
  ``a1 * a2 * a3 * a4 * a5 * a6 * a7 * a8 * a9 =
    a1 * a2 * a4 * a6 * a7 * a9 * a8 * (STAR a3 a5)``,
  SIMP_TAC std_ss [AC STAR_COMM STAR_ASSOC]);

val star_reorder_lemma7 = prove(
  ``a1 * a2 * a3 * a4 * a5 * a6 * a7 * a8 * a9 =
    a2 * a3 * a4 * a5 * a6 * a8 * a9 * (STAR a1 a7)``,
  SIMP_TAC std_ss [AC STAR_COMM STAR_ASSOC]);

val star_reorder_lemma8 = prove(
  ``a1 * a2 * a3 * a4 * a5 * a6 * a7 * a8 =
    a1 * a2 * a4 * a6 * a7 * a8 * (STAR a3 a5)``,
  SIMP_TAC std_ss [AC STAR_COMM STAR_ASSOC]);

val word_eq_add_vs_current_heap = prove(
  ``(w1 = w2) <=> (w1 + vs.current_heap = w2 + vs.current_heap)``,
  fs []);

val word_eq_add_8 = prove(
  ``(w1 = w2) <=> (w1 + 8w = w2 + 8w:word64)``,
  fs []);

val NOT_small_int_IMP_NOT_0 = prove(
  ``~(small_int i) ==> i <> 0``,
  fs [small_int_def] \\ intLib.COOPER_TAC);

val zHEAP_PERFORM_BIGNUM = let

  val th = thE3 |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
                |> UNDISCH_ALL |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val inv = ``SOME (\(sp,vals:x64_vals). num_size x1 + num_size x2 + 5 <= sp:num)``
  val side = ``heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals /\
               isNumber x1 /\ isNumber x2 /\ isNumber x4 /\
               (((n2iop (getNumber x4)) = Div) ==> x2 <> Number 0) /\
               (((n2iop (getNumber x4)) = Mod) ==> x2 <> Number 0) /\
               0 <= getNumber x4 /\ getNumber x4 <= 7 /\
               num_size x1 + num_size x2 + 5 < 2**32``
  val target = ``~zS * zPC p * zVALS cs vals``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = SMART_WEAKEN th |> SPEC side
  val th = th |> Q.SPEC `zHEAP (cs,
     Number (int_op (n2iop (getNumber x4)) (getNumber x1) (getNumber x2)),
     x2,x3,x4,refs,stack,if n2iop (getNumber x4) <> Dec then s else
       s with output := s.output ++ int_to_str (getNumber (x1)),NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
  fun fs x = full_simp_tac (srw_ss()) x
  fun rw x = srw_tac[]x
  fun rfs x = rev_full_simp_tac (srw_ss()) x
(*
  gg goal
*)
  val lemma = prove(goal,

    REPEAT STRIP_TAC
    \\ `vals.reg3 >>> 2 = int_op_rep (n2iop (getNumber x4))` by ALL_TAC THEN1
     (Cases_on `x4` \\ fs [isNumber_def,getNumber_def]
      \\ fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
             bc_value_inv_def]
      \\ MP_TAC all_ops \\ fs [] \\ REPEAT STRIP_TAC
      \\ fs [small_int_def] \\ EVAL_TAC)
    \\ Cases_on `vals.reg1 = vals.reg0` \\ fs []
    THEN1
     (`x2 = x1` by ALL_TAC THEN1
       (fs [heap_inv_def] \\ Cases_on `x1` \\ Cases_on `x2`
        \\ fs [isNumber_def,abs_ml_inv_def,bc_stack_ref_inv_def]
        \\ fs [bc_value_inv_def]
        \\ Cases_on `small_int i` \\ fs [] THEN1
         (`small_int i'` by ALL_TAC THEN1
           (CCONTR_TAC \\ fs [] \\ SRW_TAC [] [] \\ fs [x64_addr_def]
            \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
            \\ Q.PAT_ASSUM `w1 = w2 << 1` MP_TAC
            \\ fs [heap_vars_ok_def]
            \\ blastLib.BBLAST_TAC)
          \\ fs [] \\ SRW_TAC [] [] \\ fs [x64_addr_def]
          \\ fs [perform_bignum_blast_lemma,word_mul_n2w]
          \\ `2 * Num i < 9223372036854775808 /\
              2 * Num i' < 9223372036854775808` by ALL_TAC THEN1
               (NTAC 2 (POP_ASSUM MP_TAC)
                \\ REPEAT (POP_ASSUM (K ALL_TAC))
                \\ fs [small_int_def] \\ intLib.COOPER_TAC)
          \\ fs [] \\ Q.PAT_ASSUM `2 * Num i' = 2 * Num i` MP_TAC
          \\ NTAC 4 (POP_ASSUM MP_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC))
          \\ fs [small_int_def] \\ intLib.COOPER_TAC)
        \\ `~small_int i'` by ALL_TAC THEN1
         (CCONTR_TAC \\ fs [] \\ SRW_TAC [] [] \\ fs [x64_addr_def]
          \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
          \\ Q.PAT_ASSUM `w2 << 1 = w1` MP_TAC
          \\ fs [heap_vars_ok_def]
          \\ blastLib.BBLAST_TAC)
        \\ fs [] \\ SRW_TAC [] [] \\ fs [x64_addr_def]
        \\ IMP_RES_TAC heap_lookup_limit
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ `(8 * ptr) < 18446744073709551616` by DECIDE_TAC
        \\ `(8 * ptr') < 18446744073709551616` by DECIDE_TAC
        \\ fs [DECIDE ``(8*n=8*m:num) = (n=m)``] \\ SRW_TAC [] []
        \\ fs [DataOnly_def,mw_11]
        \\ Q.PAT_ASSUM `i' < 0 = i < 0` MP_TAC
        \\ Q.PAT_ASSUM `Num (ABS i') = Num (ABS i)` MP_TAC
        \\ REPEAT (POP_ASSUM (K ALL_TAC))
        \\ fs [small_int_def] \\ intLib.COOPER_TAC)
      \\ POP_ASSUM (fn th => fs [th])
      \\ Cases_on `x1 = Number 0` \\ fs []
      THEN1
       (`vals.reg0 = 0w` by ALL_TAC THEN1
          (fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,
               bc_value_inv_def,EVAL ``small_int 0``]
           \\ SRW_TAC [] [x64_addr_def])
        \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
               x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
               x64_move_ptr2_def,x64_move_ptr2_pre_def]
        \\ fs [heap_inv_def]
        \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
          (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
         (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
          \\ SEP_R_TAC \\ fs [])
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
        \\ Q.EXISTS_TAC `cs.putchar_ptr`
        \\ REPEAT (Q.PAT_ASSUM `0x0w = w` (MP_TAC o GSYM))
        \\ REPEAT STRIP_TAC \\ fs [x64_multiwordTheory.bignum_mem_def]
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
        \\ Q.EXISTS_TAC `[]`
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
        \\ Q.EXISTS_TAC `[]`
        \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
        \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
        \\ fs [unused_space_inv_def]
        \\ `sp <> 0` by DECIDE_TAC \\ fs []
        \\ IMP_RES_TAC heap_lookup_SPLIT
        \\ POP_ASSUM (fn th => fs [th])
        \\ POP_ASSUM (fn th => fs [th])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
        \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
        \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
        \\ SIMP_TAC std_ss [Once one_list_exists_def]
        \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
        \\ Q.EXISTS_TAC `TL xs`
        \\ fs [GSYM (EVAL ``x64_header (F,[])``)]
        \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
        \\ SEP_I_TAC "x64_iop"
        \\ POP_ASSUM MP_TAC
        \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
         (fs [x64_multiwordTheory.x64_header_def]
          \\ Cases_on `xs` \\ fs [] \\ EVAL_TAC
          \\ SRW_TAC [] [] \\ fs []
          \\ IMP_RES_TAC abs_ml_inv_SP_LESS_LIMIT
          \\ DECIDE_TAC)
        \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[])``]
        \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
        \\ exists_inst "q"
             `FST (mwi_op (n2iop (getNumber x4)) (F,[]) (F,[]:word64 list))`
        \\ exists_inst "qs" `SND (mwi_op (n2iop (getNumber x4)) (F,[]) (F,[]))`
        \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
        \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
              vs.current_heap *
          x64_heap
            (0x8w * n2w (heap_length (ys1 ++ [Unused (sp - 1)])) +
             vs.current_heap) ys2 vs.current_heap vs.current_heap *
          one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs`
        \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (REPEAT STRIP_TAC THEN1
           (Q.ABBREV_TAC `m = vals.memory`
            \\ Q.ABBREV_TAC `dm = vals.memory_domain`
            \\ Cases_on `xs` \\ fs []
            \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
            \\ fs [one_list_def] \\ SEP_W_TAC
            \\ fs [array64_one_list]
            \\ POP_ASSUM MP_TAC
            \\ fs [AC STAR_COMM STAR_ASSOC])
          \\ TRY (MATCH_MP_TAC mwi_op_NIL_NIL_LENGTH \\ fs [] \\ NO_TAC)
          THEN1 (Cases_on `xs` \\ fs []
            \\ fs [one_list_def] \\ SEP_R_TAC)
          \\ MATCH_MP_TAC mwi_op_NIL_NIL_OK \\ fs [])
        \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
        \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
        \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
        \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
        \\ ONCE_REWRITE_TAC [CONJ_COMM]
        \\ `small_int (mw2i (mwi_op (n2iop (getNumber x4)) (F,[])
             (F,[]:word64 list)))` by ALL_TAC THEN1
          (MATCH_MP_TAC small_int_mwi_op_NIL_NIL \\ fs []) \\ fs []
        \\ Q.EXISTS_TAC `vals with <|
              stack := MAP (x64_addr vs.current_heap) roots ++
                       0x1w::cs.ret_address::cs.rest_of_stack ;
              reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
              reg9 := vs.base_ptr ;
              reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                       -0x1w) ;
              reg1 := 0w ;
              reg2 := x64_addr vs.current_heap r3 ;
              reg3 := x64_addr vs.current_heap r4 ;
              reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w) ;
              reg0 := (small_int_to_word
                (mw2i (mwi_op (n2iop (getNumber x4)) (F,[]:word64 list) (F,[])))) ;
              memory := m ;
              memory_domain := dm ;
              input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
              output_stream := MAP (n2w o ORD) s.output ++
                if n2iop (getNumber x4) = Dec then
                  MAP (n2w o ORD) (int_to_str (mw2i (F,[]:word64 list)))
                else [] |>`
        \\ STRIP_TAC
        THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM])
        \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
        \\ Q.LIST_EXISTS_TAC [`vs`,
             `Data (if n2iop (getNumber x4) = Eq then 2w else 0w)`,
             `Data 0w`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
             `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,EVAL ``x64_addr vs.current_heap (Data 0x0w)``]
        \\ fs [x64_addr_def]
        \\ MP_TAC (Q.INST [`op`|->`n2iop (getNumber x4)`] mwi_op_value)
        \\ fs [] \\ STRIP_TAC \\ fs []
        \\ fs [] \\ SRW_TAC [] []
        \\ TRY (EVAL_TAC \\ NO_TAC)
        THEN1 (MATCH_MP_TAC (GEN_ALL abs_ml_inv_1_0) \\ fs [] \\ METIS_TAC [])
        THEN1 (MATCH_MP_TAC (GEN_ALL abs_ml_inv_0_0) \\ fs [] \\ METIS_TAC [])
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [array64_one_list,one_list_def,SEP_CLAUSES,x64_heap_APPEND,
               x64_heap_def,x64_el_def]
        \\ `LENGTH xs - 1 + 1 = LENGTH xs` by DECIDE_TAC
        \\ fs [el_length_def,heap_length_APPEND,heap_length_def]
        \\ fs [GSYM heap_length_def]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ REPEAT STRIP_TAC
        \\ Q.EXISTS_TAC `
             [b2w
              (FST
                 (if n2iop (getNumber x4) = Eq then i2mw 1
                  else ((i2mw 0):(bool # word64 list)))) +
            n2w
              (LENGTH
                 (SND
                    (if n2iop (getNumber x4) = Eq
                     then ((i2mw 1):(bool # word64 list))
                     else i2mw 0)))  16 + 0x2w] ++
             SND (if n2iop (getNumber x4) = Eq then i2mw 1 else i2mw 0) ++
             zs1` \\ fs [SEP_CLAUSES]
        \\ Q.EXISTS_TAC `xs''` \\ fs [SEP_CLAUSES,one_list_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [LEFT_ADD_DISTRIB,GSYM word_add_n2w]
        \\ REVERSE (REPEAT STRIP_TAC)
        THEN1 (fs [AC STAR_ASSOC STAR_COMM])
        \\ Cases_on `xs` \\ fs [LENGTH]
        \\ Q.PAT_ASSUM `xxx = LENGTH t` (fn th => fs [GSYM th])
        \\ fs [ADD1] \\ DECIDE_TAC)
      \\ `?i1. (x1 = Number i1) /\ (i1 <> 0)` by
        (Cases_on `x1` \\ fs [isNumber_def])
      \\ fs [getNumber_def,isNumber_def]
      \\ Cases_on `small_int i1` \\ fs []
      THEN1
       (`vals.reg0 <> 0w /\ (0x1w && vals.reg0 = 0x0w) /\
         vals.reg0 >>> 2 <> 0w` by ALL_TAC THEN1
          (IMP_RES_TAC heap_inv_tests \\ fs [])
        \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
               x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
               x64_move_ptr2_def,x64_move_ptr2_pre_def]
        \\ fs [heap_inv_def]
        \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
          (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
         (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
          \\ SEP_R_TAC \\ fs [])
        \\ `i2mw i1 = (F,[x64_addr vs.current_heap r1 >>> 2])` by
              (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
               \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
        \\ Q.EXISTS_TAC `cs.putchar_ptr`
        \\ REPEAT STRIP_TAC
        \\ fs [x64_multiwordTheory.bignum_mem_def]
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
        \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r1 >>> 2]`
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
        \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r1 >>> 2]`
        \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
        \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
        \\ fs [unused_space_inv_def]
        \\ `sp <> 0` by DECIDE_TAC \\ fs []
        \\ IMP_RES_TAC heap_lookup_SPLIT
        \\ POP_ASSUM (fn th => fs [th])
        \\ POP_ASSUM (fn th => fs [th])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
        \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
        \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
        \\ SIMP_TAC std_ss [Once one_list_exists_def]
        \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
        \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
         (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
          \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
          THEN1 (`F` by DECIDE_TAC)
          \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
          THEN1 (`F` by DECIDE_TAC))
        \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
        \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r1 >>> 2])` by EVAL_TAC
        \\ fs []
        \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
        \\ SEP_I_TAC "x64_iop"
        \\ POP_ASSUM MP_TAC
        \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
        THEN1
         (fs [x64_multiwordTheory.x64_header_def,multiwordTheory.mw_ok_def]
          \\ rfs [] \\ SRW_TAC [] []
          \\ IMP_RES_TAC num_size_1 \\ fs [] THEN1 DECIDE_TAC
          \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
                 el_length_def] \\ DECIDE_TAC)
        \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
        \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
        \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
        \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
               ((i2mw i1):(bool # word64 list)) =
            i2mw (int_op (n2iop (getNumber x4)) i1 i1)` by ALL_TAC THEN1
          (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
        \\ exists_inst "q"
             `FST (mwi_op (n2iop (getNumber x4))
                ((i2mw i1):(bool # word64 list))
                ((i2mw i1):(bool # word64 list)))`
        \\ exists_inst "qs"
             `SND (mwi_op (n2iop (getNumber x4))
                ((i2mw i1):(bool # word64 list))
                ((i2mw i1):(bool # word64 list)))`
        \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
        \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
              vs.current_heap *
          x64_heap
            (0x8w * n2w (heap_length (ys1 ++ [Unused (sp - 1)])) +
             vs.current_heap) ys2 vs.current_heap vs.current_heap *
          one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs`
        \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (Q.ABBREV_TAC `m = vals.memory`
          \\ Q.ABBREV_TAC `dm = vals.memory_domain`
          \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
          \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [heap_length_def,el_length_def]
          \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                   LEFT_ADD_DISTRIB,MULT_CLAUSES]
          \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                   AC WORD_MULT_COMM WORD_MULT_ASSOC,
                   AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [APPLY_UPDATE_THM]
          \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
              vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
              0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
              vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
           (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
            \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
            \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
          \\ fs [] \\ SEP_R_TAC \\ fs []
          \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
          THEN1
           (SEP_W_TAC \\ POP_ASSUM MP_TAC
            \\ fs [AC STAR_ASSOC STAR_COMM]
            \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
            \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
          \\ fs [mw_ok_i2mw]
          \\ MATCH_MP_TAC num_length_lemma \\ fs []
          \\ DECIDE_TAC)
        \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
        \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
        \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
        \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
        \\ ONCE_REWRITE_TAC [CONJ_COMM]
        \\ fs [multiwordTheory.mw2i_i2mw]
        \\ Q.EXISTS_TAC `vals with <|
              stack := MAP (x64_addr vs.current_heap) roots ++
                       0x1w::cs.ret_address::cs.rest_of_stack ;
              reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
              reg9 := vs.base_ptr ;
              reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                       -0x1w) ;
              reg1 := x64_addr vs.current_heap r1 ;
              reg2 := x64_addr vs.current_heap r3 ;
              reg3 := x64_addr vs.current_heap r4 ;
              reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                       (if small_int (int_op (n2iop (getNumber x4)) i1 i1) then 0x0w
                        else n2w (8 * LENGTH
                          ((SND (i2mw (int_op (n2iop (getNumber x4))
                              i1 i1))):word64 list) + 8)) + -0x1w) ;
              reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i1) then
                         small_int_to_word (int_op (n2iop (getNumber x4)) i1 i1)
                       else
                         (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
              memory := m ;
              memory_domain := dm ;
              input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
              output_stream := MAP (n2w o ORD) s.output ++
                if n2iop (getNumber x4) = Dec then
                  MAP (n2w o ORD) (int_to_str i1)
                else [] |>`
        \\ STRIP_TAC
        THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
               \\ POP_ASSUM MP_TAC
               \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
               \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
        \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i1)` \\ fs []
        THEN1
         (Q.LIST_EXISTS_TAC [`vs`,
             `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i1)))`,
             `r1`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
             `heap_length ys1`,`sp`]
          \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
          \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
          \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
          \\ STRIP_TAC THEN1
           (IMP_RES_TAC small_int_num_exists
            \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
            \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
            \\ Q.LIST_EXISTS_TAC [`Number (&k')`,`r1`]
            \\ `r2 = r1` by ALL_TAC \\ fs []
            \\ fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def])
          \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
          \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ Q.ABBREV_TAC `result = i2mw
               (int_op (n2iop (getNumber x4)) i1 i1):(bool # word64 list)`
          \\ Q.EXISTS_TAC
              `b2w (FST (result:(bool # word64 list))) +
               n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
               (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i1)) ++ zs1) ++
               [x64_addr vs.current_heap r1 >>> 2;
                x64_addr vs.current_heap r1 >>> 2]` \\ Q.EXISTS_TAC `xs'`
          \\ fs [ADD1,GSYM ADD_ASSOC]
          \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
          \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
          \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                   LEFT_ADD_DISTRIB,MULT_CLAUSES]
          \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                   AC WORD_MULT_COMM WORD_MULT_ASSOC,
                   AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ Q.LIST_EXISTS_TAC [`vs`,
             `Pointer (heap_length ys1)`,
             `r1`,`r3`,`r4`,`roots`,`ys1 ++
               IntData (int_op (n2iop (getNumber x4)) i1 i1) ::
               Unused (LENGTH zs1 + 1)::ys2`,
             `heap_length ys1 +
              num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) + 1`,
             `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) - 1`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ fs [x64_addr_def,WORD_MUL_LSL]
        \\ REVERSE (REPEAT STRIP_TAC)
        THEN1
         (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
          \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
                 IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
          \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
          \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
          \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                   LEFT_ADD_DISTRIB,MULT_CLAUSES]
          \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
                [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
          \\ STRIP_TAC THEN1
           (fs [mw_thm]
            \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
            \\ fs [] \\ DECIDE_TAC)
          \\ fs [multiwordTheory.i2mw_def,mw_thm]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ REPEAT STRIP_TAC
          \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
               [x64_addr vs.current_heap r1 >>> 2;
                x64_addr vs.current_heap r1 >>> 2]`]
          \\ Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM)
          \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
          \\ fs [word_mul_n2w,word_add_n2w]
          \\ `n2w (8 * LENGTH
               (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i1))):word64 list) +
              8 * heap_length ys1 + 8 * LENGTH zs1) =
              n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
           (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
            \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
            \\ fs [LEFT_ADD_DISTRIB]
            \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
            \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
          \\ FULL_SIMP_TAC std_ss [] \\ fs []
          \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ `!w v. n2w w + vs.current_heap + n2w v =
                    n2w (w + v) + vs.current_heap` by
           (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
            \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
          \\ FULL_SIMP_TAC std_ss []
          \\ `8 * LENGTH zs1 + 8 *
              LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
                i1 i1))):word64 list) +
              8 * heap_length ys1 + 24 =
              8 * heap_length ys1 + 8 * (sp  1) + 8` by
           (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
            \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
            \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
          \\ fs []
          \\ fs [WORD_MUL_LSL,word_mul_n2w]
          \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        THEN1
         (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
          \\ fs [GSYM ADD_ASSOC]
          \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) +
                2 <= sp` by
           (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
                `j`|->`i1`] LENGTH_int_op)
            \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
            \\ DECIDE_TAC)
          \\ DECIDE_TAC)
        THEN1
         (fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
              word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
        \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
        \\ `r2 = r1` by (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def])
        \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
        \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
        \\ DECIDE_TAC)
      \\ POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ ~(0x1w && vals.reg0 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ ~(0x1w && vals.reg1 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i1))`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr. (r1 = Pointer ptr) /\
                (heap_lookup ptr (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                 SOME (DataOnly (i1 < 0) (mw (Num (ABS i1)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC heap_lookup_DataOnly_in_split
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [])
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ STRIP_TAC \\ fs []
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w) >>> 15 =
           x64_header (i1 < 0,n2mw (Num (ABS i1)))) /\
          x64_addr vs.current_heap (Pointer ptr) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i1 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `(n2mw (Num (ABS i1))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i1 < 0,n2mw (Num (ABS i1))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i1):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i1)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i1):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i1):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr) + 0x1w,b2w (i1 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x8w,w6) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x10w,w7) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i1) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i1))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i1) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i1)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i1)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i1)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number i1`,`Pointer ptr`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 i1):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i1)) ++ zs1) ++
             [w6; w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma5]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i1) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++ [w6;w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i1))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 i1))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma6]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i1)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`i1`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)
    \\ `?i1 i2. (x1 = Number i1) /\ (x2 = Number i2)` by
      (Cases_on `x1` \\ Cases_on `x2` \\ fs [isNumber_def])
    \\ fs [getNumber_def,isNumber_def]
    \\ NTAC 2 (POP_ASSUM (K ALL_TAC))
    \\ Cases_on `ml_translator$CONTAINER
         (~small_int i1 /\ ~small_int i2 /\ (i1 <> 0) /\ (i2 <> 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ ~(0x1w && vals.reg0 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ ~(0x1w && vals.reg1 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i1))`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i2))` \\ rfs []
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr1. (r1 = Pointer ptr1) /\
                 (heap_lookup ptr1 (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                  SOME (DataOnly (i1 < 0) (mw (Num (ABS i1)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ `?ptr2. (r2 = Pointer ptr2) /\
                 (heap_lookup ptr2 (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                  SOME (DataOnly (i2 < 0) (mw (Num (ABS i2)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC heap_lookup_DataOnly_in_split_two
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
        (fs [] \\ REPEAT STRIP_TAC \\ SRW_TAC [] [])
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ STRIP_TAC \\ fs []
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr1) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr1) + 0x1w) >>> 15 =
           x64_header (i1 < 0,n2mw (Num (ABS i1)))) /\
          x64_addr vs.current_heap (Pointer ptr1) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr1) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr1) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i1 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr2) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr2) + 0x1w) >>> 15 =
           x64_header (i2 < 0,n2mw (Num (ABS i2)))) /\
          x64_addr vs.current_heap (Pointer ptr2) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr2) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr2) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i2 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `(n2mw (Num (ABS i1))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `(n2mw (Num (ABS i2))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i1 < 0,n2mw (Num (ABS i1))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ `x64_header (i2 < 0,n2mw (Num (ABS i2))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr1) + 0x1w,b2w (i1 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) << 16 + 0x2w) *
        one (x64_addr vs.current_heap (Pointer ptr2) + 0x1w,b2w (i2 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x8w,w6) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x10w,w7) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number i1`,`Pointer ptr1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ SIMP_TAC std_ss [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 i2):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i2)) ++ zs1) ++
             [w6; w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma5]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++ [w6;w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma6]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`i1`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (~small_int i1 /\ small_int i2 /\ (i1 <> 0) /\ (i2 <> 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ ~(0x1w && vals.reg0 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ (0x1w && vals.reg1 = 0x0w) /\
          vals.reg1 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i2 = (F,[x64_addr vs.current_heap r2 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i1))`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r2 >>> 2]`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr. (r1 = Pointer ptr) /\
                (heap_lookup ptr (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                 SOME (DataOnly (i1 < 0) (mw (Num (ABS i1)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC heap_lookup_DataOnly_in_split
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [])
      \\ STRIP_TAC \\ fs []
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ `(n2mw (Num (ABS i1))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i1 < 0,n2mw (Num (ABS i1))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w) >>> 15 =
           x64_header (i1 < 0,n2mw (Num (ABS i1)))) /\
          x64_addr vs.current_heap (Pointer ptr) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i1 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r2 >>> 2])` by EVAL_TAC
      \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
      \\ fs [APPLY_UPDATE_THM]
      \\ `n2w (8 * (heap_length ys1 + sp)) + vs.current_heap +
          0xFFFFFFFFFFFFFFF0w <>
          x64_addr vs.current_heap (Pointer ptr) + 0x1w` by ALL_TAC THEN1
       (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC]
        \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
               LET_DEF,GSYM word_mul_n2w]
        \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
      \\ `x64_header (F,[x64_addr vs.current_heap r2 >>> 2]) <> 0x0w /\
          x64_addr vs.current_heap r2 >>> 2 <> 0x0w` by ALL_TAC THEN1
       (REPEAT (Q.PAT_ASSUM `i2mw ii = xxx` (ASSUME_TAC o GSYM)) \\ fs []
        \\ STRIP_TAC THEN1
         (fs [multiwordTheory.i2mw_def]
          \\ MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
        \\ fs [x64_addr_def,abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def]
        \\ Q.PAT_ASSUM `vals.reg1 >>> 2 <> 0x0w` MP_TAC \\ fs [x64_addr_def])
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [multiwordTheory.mw_ok_def]
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ fs [GSYM multiwordTheory.i2mw_def]
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr) + 0x1w,b2w (i1 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x10w,w7) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
          \\ `n2mw (Num (ABS i1)) <> []:word64 list` by ALL_TAC THEN1
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i1)):word64 list` \\ fs []
          \\ fs [one_list_def,x64_addr_def]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``~b /\ y ==> (if b then x else y)``)
          \\ STRIP_TAC THEN1
           (ONCE_REWRITE_TAC [word_eq_add_8]
            \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
          \\ SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number i1`,`Pointer ptr`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 i2):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ `n2w (8 * (heap_length ys1 + SUC (LENGTH rest + 2))) +
            vs.current_heap + 0xFFFFFFFFFFFFFFF0w <>
            vs.current_heap + n2w ptr  3 + 0x8w` by ALL_TAC THEN1
         (fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ `n2mw (Num (ABS i1)) <> []:word64 list` by
                (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i1)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ ONCE_REWRITE_TAC [word_eq_add_8]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM]) \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i2)) ++ zs1) ++
             [x64_addr vs.current_heap r2  2; w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma7]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (`0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
         0xFFFFFFFFFFFFFFF0w <> 0x8w * n2w ptr + vs.current_heap + 0x8w` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM)
          \\ fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC,word_mul_n2w,word_add_n2w]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ `n2mw (Num (ABS i1)) <> []:word64 list` by
                (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i1)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ ONCE_REWRITE_TAC [word_eq_add_vs_current_heap]
          \\ ONCE_REWRITE_TAC [word_eq_add_8]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM] \\ NO_TAC) \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
             [x64_addr vs.current_heap r2 >>> 2;w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma8]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`i2`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (small_int i1 /\ ~small_int i2 /\ (i1 <> 0) /\ (i2 <> 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ (0x1w && vals.reg0 = 0x0w) /\
          vals.reg0 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ ~(0x1w && vals.reg1 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i1 = (F,[x64_addr vs.current_heap r1 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r1 >>> 2]`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i2))`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr. (r2 = Pointer ptr) /\
                (heap_lookup ptr (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                 SOME (DataOnly (i2 < 0) (mw (Num (ABS i2)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC (heap_lookup_DataOnly_in_split |> Q.INST [`i1`|->`i2`])
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [])
      \\ STRIP_TAC \\ fs []
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ `(n2mw (Num (ABS i2))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i2 < 0,n2mw (Num (ABS i2))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w) >>> 15 =
           x64_header (i2 < 0,n2mw (Num (ABS i2)))) /\
          x64_addr vs.current_heap (Pointer ptr) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i2 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r1 >>> 2])` by EVAL_TAC
      \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
      \\ fs [APPLY_UPDATE_THM]
      \\ `n2w (8 * (heap_length ys1 + sp)) + vs.current_heap +
          0xFFFFFFFFFFFFFFF8w <>
          x64_addr vs.current_heap (Pointer ptr) + 0x1w` by ALL_TAC THEN1
       (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC]
        \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
               LET_DEF,GSYM word_mul_n2w]
        \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
      \\ `x64_header (F,[x64_addr vs.current_heap r1 >>> 2]) <> 0x0w /\
          x64_addr vs.current_heap r1 >>> 2 <> 0x0w` by ALL_TAC THEN1
       (REPEAT (Q.PAT_ASSUM `i2mw ii = xxx` (ASSUME_TAC o GSYM)) \\ fs []
        \\ STRIP_TAC THEN1
         (fs [multiwordTheory.i2mw_def]
          \\ MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
        \\ fs [x64_addr_def,abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def]
        \\ Q.PAT_ASSUM `vals.reg0 >>> 2 <> 0x0w` MP_TAC \\ fs [x64_addr_def])
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [multiwordTheory.mw_ok_def]
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ fs [GSYM multiwordTheory.i2mw_def]
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr) + 0x1w,b2w (i2 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x8w,w6) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
          \\ `n2mw (Num (ABS i2)) <> []:word64 list` by ALL_TAC THEN1
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i2)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``~b /\ y ==> (if b then x else y)``)
          \\ STRIP_TAC THEN1 (SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
          \\ SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number &k'`,`r1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 i2):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ `n2w (8 * (heap_length ys1 + SUC (LENGTH rest + 2))) +
            vs.current_heap + 0xFFFFFFFFFFFFFFF8w <>
            vs.current_heap + n2w ptr  3 + 0x8w` by ALL_TAC THEN1
         (fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ `n2mw (Num (ABS i2)) <> []:word64 list` by
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i2)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM]) \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i2)) ++ zs1) ++
             [w6; x64_addr vs.current_heap r1 >>> 2]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma7]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (`0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
         0xFFFFFFFFFFFFFFF8w <> 0x8w * n2w ptr + vs.current_heap + 0x8w` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM)
          \\ fs [LEFT_ADD_DISTRIB,ADD1,GSYM ADD_ASSOC,word_mul_n2w,word_add_n2w]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ `n2mw (Num (ABS i2)) <> []:word64 list` by
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i2)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ fs [GSYM word_add_n2w,x64_el_def,x64_payload_def,DataOnly_def,
                 LET_DEF,GSYM word_mul_n2w]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM]) \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
             [w6;x64_addr vs.current_heap r1 >>> 2]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma8]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`i2`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (small_int i1 /\ ~small_int i2 /\ (i1 = 0) /\ (i2 <> 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 = 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ ~(0x1w && vals.reg1 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i1 = (F,[]:word64 list)` by (fs [] \\ EVAL_TAC \\ NO_TAC)
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `[]`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i2))`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr. (r2 = Pointer ptr) /\
                (heap_lookup ptr (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                 SOME (DataOnly (i2 < 0) (mw (Num (ABS i2)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC (heap_lookup_DataOnly_in_split |> Q.INST [`i1`|->`i2`])
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [])
      \\ STRIP_TAC \\ fs []
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ `(n2mw (Num (ABS i2))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i2 < 0,n2mw (Num (ABS i2))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w) >>> 15 =
           x64_header (i2 < 0,n2mw (Num (ABS i2)))) /\
          x64_addr vs.current_heap (Pointer ptr) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i2 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `x64_addr vs.current_heap r1 = 0w` by fs [] \\ fs []
        \\ `n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `0x0w = x64_header (F,[])` by (EVAL_TAC \\ NO_TAC) \\ fs []
      \\ `x64_addr vs.current_heap r1 = x64_header (F,[])` by fs []
      \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [multiwordTheory.mw_ok_def]
        \\ `x64_addr vs.current_heap r1 = 0w` by fs [] \\ fs []
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ `x64_addr vs.current_heap r1 = 0w` by fs [] \\ fs []
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ fs [GSYM multiwordTheory.i2mw_def]
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw 0)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) 0 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw 0):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw 0):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr) + 0x1w,b2w (i2 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i2)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x8w,w6) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x10w,w7) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
          \\ `n2mw (Num (ABS i2)) <> []:word64 list` by ALL_TAC THEN1
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i2)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) 0 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            0 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) 0 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) 0 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) 0 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) 0 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number (&k')`,`r1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) 0 i2):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) 0 i2)) ++ zs1) ++
             [w6; w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma5]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) 0 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) 0 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) 0 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++ [w6;w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) 0 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              0 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma6]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) 0 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`0`,
              `j`|->`i2`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (~small_int i1 /\ small_int i2 /\ (i1 <> 0) /\ (i2 = 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ ~(0x1w && vals.reg0 = 0x0w)` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 = 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i2 = (F,[]:word64 list)` by (fs [] \\ EVAL_TAC \\ NO_TAC)
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `n2mw (Num (ABS i1))`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `[]`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `?ptr. (r1 = Pointer ptr) /\
                (heap_lookup ptr (ys1 ++ [Unused (sp - 1)] ++ ys2) =
                 SOME (DataOnly (i1 < 0) (mw (Num (ABS i1)))))` by
        (fs [abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def] \\ METIS_TAC [])
      \\ MP_TAC heap_lookup_DataOnly_in_split
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [])
      \\ STRIP_TAC \\ fs []
      \\ fs [STAR_ASSOC,SEP_CLAUSES]
      \\ fs [star_reorder]
      \\ `(n2mw (Num (ABS i1))) <> ([]:word64 list)` by ALL_TAC THEN1
           (fs [multiwordTheory.n2mw_NIL] \\ intLib.COOPER_TAC)
      \\ `x64_header (i1 < 0,n2mw (Num (ABS i1))) <> 0x0w` by ALL_TAC THEN1
           (MATCH_MP_TAC x64_header_NOT_ZERO \\ fs [] \\ DECIDE_TAC)
      \\ `((0x1w &&
            vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w)) +
           vals.memory (x64_addr vs.current_heap (Pointer ptr) + 0x1w) >>> 15 =
           x64_header (i1 < 0,n2mw (Num (ABS i1)))) /\
          x64_addr vs.current_heap (Pointer ptr) + 0x1w IN vals.memory_domain /\
          (0x7w && (x64_addr vs.current_heap (Pointer ptr) + 0x1w) = 0x0w) /\
          (0x7w && x64_addr vs.current_heap (Pointer ptr) + 0x9w = 0x0w)`
          by ALL_TAC THEN1
       (fs [x64_el_def,DataOnly_def,x64_addr_def,x64_payload_def,LET_DEF]
        \\ SEP_R_TAC \\ fs [x64_multiwordTheory.x64_header_def]
        \\ REVERSE (STRIP_TAC)
        THEN1 (Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
               \\ fs [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
        \\ Cases_on `i1 < 0` \\ fs [multiwordTheory.b2w_def,
             multiwordTheory.b2n_def,b2w_def,GSYM word_mul_n2w]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ `x64_addr vs.current_heap r2 = 0w` by fs [] \\ fs []
        \\ `n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) <+
              281474976710656w:word64` by
            (fs [WORD_LO] \\ MATCH_MP_TAC MOD_LESS_LEMMA \\ fs [] \\ NO_TAC)
        \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
      \\ `0x0w = x64_header (F,[])` by (EVAL_TAC \\ NO_TAC) \\ fs []
      \\ `x64_addr vs.current_heap r2 = x64_header (F,[])` by fs []
      \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [multiwordTheory.mw_ok_n2mw]
        \\ fs [num_size_def,mw_thm]
        \\ Q.PAT_ASSUM `xx = sp` (ASSUME_TAC o GSYM)
        \\ fs [multiwordTheory.mw_ok_def]
        \\ `x64_addr vs.current_heap r2 = 0w` by fs [] \\ fs []
        \\ fs [ADD1] \\ REPEAT STRIP_TAC THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ `x64_addr vs.current_heap r2 = 0w` by fs [] \\ fs []
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ fs [GSYM multiwordTheory.i2mw_def]
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw 0):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 0)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw 0):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw 0):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `
        one_list_exists vs.other_heap cs.heap_limit *
        one (x64_addr vs.current_heap (Pointer ptr) + 0x1w,b2w (i1 < 0) +
             n2w (LENGTH (n2mw (Num (ABS i1)):word64 list)) << 16 + 0x2w) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x8w,w6) *
        one (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
             vs.current_heap + 0x10w,w7) *
        other * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
          \\ `n2mw (Num (ABS i1)) <> []:word64 list` by ALL_TAC THEN1
            (fs [multiwordTheory.n2mw_NIL])
          \\ Cases_on `n2mw (Num (ABS i1)):word64 list` \\ fs []
          \\ fs [one_list_def]
          \\ SEP_NEQ_TAC \\ fs [AC STAR_ASSOC STAR_COMM])
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ fs [x64_el_def,DataOnly_def,x64_payload_def,LET_DEF]
          \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw,GSYM multiwordTheory.i2mw_def]
        \\ fs [x64_addr_def]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 0) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 0))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 0) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 0)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ fs [mw2i_ID]
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 0)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 0)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number i1`,`Pointer ptr`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [mw2i_ID,GSYM multiwordTheory.i2mw_def]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 0):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 0)) ++ zs1) ++
             [w6; w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma5]
        \\ ASM_SIMP_TAC std_ss []
        \\ fs [x64_el_def,DataOnly_def,LET_DEF,x64_payload_def]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 0) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 0)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 0)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ fs [GSYM multiwordTheory.i2mw_def]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++ [w6;w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 0))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 0))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `(n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64) /\
            (n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
             n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64)` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [STAR_ASSOC,GSYM ADD_ASSOC]
        \\ ONCE_REWRITE_TAC [star_reorder_lemma6]
        \\ ASM_SIMP_TAC std_ss [SEP_CLAUSES]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 0)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`0`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (small_int i1 /\ small_int i2 /\ (i1 = 0) /\ i2 <> 0)`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 = 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ (0x1w && vals.reg1 = 0x0w) /\
          vals.reg1 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i1 = (F,[]:word64 list)` by (fs [] \\ EVAL_TAC \\ NO_TAC)
      \\ `i2mw i2 = (F,[x64_addr vs.current_heap r2 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `[]`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r2 >>> 2]`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r2 >>> 2])` by EVAL_TAC
      \\ `x64_addr vs.current_heap r1 = 0x0w` by fs []
      \\ `0x0w = x64_header (F,[])` by (EVAL_TAC \\ NO_TAC)
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [x64_multiwordTheory.x64_header_def,multiwordTheory.mw_ok_def]
        \\ rfs [] \\ SRW_TAC [] []
        \\ IMP_RES_TAC num_size_1 \\ fs [] THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
            vs.current_heap *
        one
          (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
           vs.current_heap + 0x10w,w7) *
        x64_heap
          (0x8w * n2w (heap_length (ys1 ++ [Unused (sp - 1)])) +
           vs.current_heap) ys2 vs.current_heap vs.current_heap *
        one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) 0 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number (&k'')`,`r1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) 0 i2):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) 0 i2)) ++ zs1) ++
             [x64_addr vs.current_heap r2 >>> 2;
              w7]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
             [x64_addr vs.current_heap r2 >>> 2;
              w7]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) 0 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              0 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551608) =
            n2w (8 * LENGTH rest + 8 * heap_length ys1 + 16):word64` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) 0 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`0`,
              `j`|->`i2`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw ii` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (small_int i1 /\ small_int i2 /\ i1 <> 0 /\ (i2 = 0))`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ (0x1w && vals.reg0 = 0x0w) /\
          vals.reg0 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 = 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i1 = (F,[x64_addr vs.current_heap r1 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ `i2mw i2 = (F,[]:word64 list)` by (fs [] \\ EVAL_TAC \\ NO_TAC)
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r1 >>> 2]`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `[]`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r1 >>> 2])` by EVAL_TAC
      \\ `x64_addr vs.current_heap r2 = 0x0w` by fs []
      \\ `0x0w = x64_header (F,[])` by (EVAL_TAC \\ NO_TAC)
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM MP_TAC
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [x64_multiwordTheory.x64_header_def,multiwordTheory.mw_ok_def]
        \\ rfs [] \\ SRW_TAC [] []
        \\ IMP_RES_TAC num_size_1 \\ fs [] THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT (Q.PAT_ASSUM `0w = ww` (ASSUME_TAC o GSYM)) \\ fs []
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ rfs [] \\ fs []
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
            vs.current_heap *
        one
          (0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
           vs.current_heap + 0x8w,w6) *
        x64_heap
          (0x8w * n2w (heap_length (ys1 ++ [Unused (sp - 1)])) +
           vs.current_heap) ys2 vs.current_heap vs.current_heap *
        one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ rfs [] \\ fs [mw_ok_i2mw]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 0)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number (&k'')`,`r1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 0):(bool # word64 list)`
        \\ rfs [] \\ fs []
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 0)) ++ zs1) ++
             [w6;
              x64_addr vs.current_heap r1 >>> 2]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL] \\ rfs []
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ rfs [] \\ fs [] \\ DECIDE_TAC)
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw iii` (K ALL_TAC))
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
             [w6;
              x64_addr vs.current_heap r1 >>> 2]`]
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM))
        \\ TRY (Q.PAT_ASSUM `xxx = n2mw (Num (ABS i2))` (ASSUME_TAC o GSYM))
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 0))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 0))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ FULL_SIMP_TAC std_ss []
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ `n2w (8 * sp + 8 * heap_length ys1 + 18446744073709551600) =
            n2w (8 * LENGTH rest + 8 * heap_length ys1 + 8):word64` by ALL_TAC
        THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]
          \\ REWRITE_TAC [DECIDE ``m1+(m2+(m3+(m4+m5))) = (m1+m5)+(m2+(m3+m4)):num``]
          \\ SIMP_TAC std_ss []
          \\ ONCE_REWRITE_TAC [GSYM
               (MATCH_MP MOD_PLUS (DECIDE ``0 < 18446744073709551616:num``))]
          \\ SIMP_TAC std_ss [])
        \\ FULL_SIMP_TAC std_ss []
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw i2` (K ALL_TAC))
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 0)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`0`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw i2` (K ALL_TAC))
        \\ fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ REPEAT (Q.PAT_ASSUM `(F,[]) = i2mw i2` (K ALL_TAC))
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ Cases_on `ml_translator$CONTAINER
         (small_int i1 /\ small_int i2 /\ i1 <> 0 /\ i2 <> 0)`
    THEN1
     (POP_ASSUM (MP_TAC o RW [ml_translatorTheory.CONTAINER_def])
      \\ STRIP_TAC \\ fs []
      \\ `vals.reg0 <> 0w /\ (0x1w && vals.reg0 = 0x0w) /\
          vals.reg0 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ `vals.reg1 <> 0w /\ (0x1w && vals.reg1 = 0x0w) /\
          vals.reg1 >>> 2 <> 0w` by ALL_TAC THEN1
           (IMP_RES_TAC heap_inv_tests \\ fs [])
      \\ fs [x64_big_setup_def,x64_big_setup_pre_def,
             x64_move_ptr_def,x64_move_ptr_pre_def,LET_DEF,
             x64_move_ptr2_def,x64_move_ptr2_pre_def]
      \\ fs [heap_inv_def]
      \\ `vs.base_ptr + 0x18w IN vals.memory_domain /\
        (vals.memory (vs.base_ptr + 0x18w) = cs.putchar_ptr)` by ALL_TAC THEN1
       (fs [x64_store_def,one_list_def,word_arith_lemma1,heap_inv_def,SEP_CLAUSES]
        \\ SEP_R_TAC \\ fs [])
      \\ `i2mw i1 = (F,[x64_addr vs.current_heap r1 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ `i2mw i2 = (F,[x64_addr vs.current_heap r2 >>> 2])` by
            (fs [abs_ml_inv_def,bc_stack_ref_inv_def]
             \\ IMP_RES_TAC small_int_IMP_i2mw \\ fs [])
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["z"]))
      \\ Q.EXISTS_TAC `cs.putchar_ptr`
      \\ REPEAT STRIP_TAC
      \\ fs [x64_multiwordTheory.bignum_mem_def]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["xs"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r1 >>> 2]`
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["ys"]))
      \\ Q.EXISTS_TAC `[x64_addr vs.current_heap r2 >>> 2]`
      \\ fs [x64_multiwordTheory.array64_def,SEP_CLAUSES]
      \\ `unused_space_inv a sp heap` by fs [abs_ml_inv_def]
      \\ fs [unused_space_inv_def]
      \\ `sp <> 0` by DECIDE_TAC \\ fs []
      \\ IMP_RES_TAC heap_lookup_SPLIT
      \\ POP_ASSUM (fn th => fs [th])
      \\ POP_ASSUM (fn th => fs [th])
      \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def]
      \\ fs [DECIDE ``sp <> 0 ==> (sp - 1 + 1 = sp:num)``]
      \\ Q.PAT_ASSUM `xx (fun2set (vals.memory,vals.memory_domain))` MP_TAC
      \\ SIMP_TAC std_ss [Once one_list_exists_def]
      \\ fs [SEP_CLAUSES,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
      \\ CONV_TAC(RESORT_EXISTS_CONV(sort_vars["zs"]))
      \\ `?w5 w6 w7 rest. xs = w5::(rest ++ [w6] ++ [w7])` by ALL_TAC THEN1
       (SRW_TAC [] [] \\ Cases_on `xs` \\ fs []
        \\ STRIP_ASSUME_TAC (Q.ISPEC `t:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC)
        \\ STRIP_ASSUME_TAC (Q.ISPEC `l:word64 list` SNOC_CASES) \\ fs []
        THEN1 (`F` by DECIDE_TAC))
      \\ Q.EXISTS_TAC `rest` \\ fs [] \\ fs [one_list_def,one_list_APPEND]
      \\ `0x2w = x64_header (F,[x64_addr vs.current_heap r1 >>> 2])` by EVAL_TAC
      \\ fs []
      \\ ASSUME_TAC (x64_multiwordTheory.x64_iop_thm
           |> DISCH ``x64_header (t,ys) = x64_header (s,xs)``
           |> SIMP_RULE std_ss [] |> RW [AND_IMP_INTRO] |> GEN_ALL)
      \\ SEP_I_TAC "x64_iop"
      \\ POP_ASSUM (MP_TAC o Q.SPEC `F`)
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC
      THEN1
       (fs [x64_multiwordTheory.x64_header_def,multiwordTheory.mw_ok_def]
        \\ rfs [] \\ SRW_TAC [] []
        \\ IMP_RES_TAC num_size_1 \\ fs [] THEN1 DECIDE_TAC
        \\ fs [abs_ml_inv_def,heap_ok_def,heap_length_def,heap_length_APPEND,
               el_length_def] \\ DECIDE_TAC)
      \\ REPEAT STRIP_TAC \\ fs [EVAL ``x64_header (F,[x])``]
      \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND, x64_print_stack_IF]
      \\ REPEAT (Q.PAT_ASSUM `i2mw ii = xx` (ASSUME_TAC o GSYM)) \\ fs []
      \\ `mwi_op (n2iop (getNumber x4)) (i2mw i1)
             ((i2mw i2):(bool # word64 list)) =
          i2mw (int_op (n2iop (getNumber x4)) i1 i2)` by ALL_TAC THEN1
        (MATCH_MP_TAC multiwordTheory.mwi_op_thm \\ fs [])
      \\ exists_inst "q"
           `FST (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ exists_inst "qs"
           `SND (mwi_op (n2iop (getNumber x4))
              ((i2mw i1):(bool # word64 list))
              ((i2mw i2):(bool # word64 list)))`
      \\ fs [bignum_blast_lemma,GSYM word_mul_n2w,heap_vars_ok_def]
      \\ Q.EXISTS_TAC `x64_heap vs.current_heap ys1 vs.current_heap
            vs.current_heap *
        x64_heap
          (0x8w * n2w (heap_length (ys1 ++ [Unused (sp - 1)])) +
           vs.current_heap) ys2 vs.current_heap vs.current_heap *
        one_list_exists vs.other_heap cs.heap_limit * x64_store cs vs`
      \\ REWRITE_TAC [CONJ_ASSOC] \\ STRIP_TAC
      THEN1
       (Q.ABBREV_TAC `m = vals.memory`
        \\ Q.ABBREV_TAC `dm = vals.memory_domain`
        \\ Q.PAT_ASSUM `xx (fun2set (m,dm))` ASSUME_TAC
        \\ Q.PAT_ASSUM `xxx  = sp` (ASSUME_TAC o GSYM) \\ fs []
        \\ fs [heap_length_def,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [APPLY_UPDATE_THM]
        \\ `0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x8w <> vs.base_ptr + 0x18w /\
            0x8w * n2w (LENGTH rest) + 0x8w * n2w (heap_length ys1) +
            vs.current_heap + 0x10w <> vs.base_ptr + 0x18w` by
         (fs [x64_store_def,one_list_def,word_arith_lemma1,SEP_CLAUSES]
          \\ SRW_TAC [] [] \\ SEP_NEQ_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM,SEP_CLAUSES])
        \\ fs [] \\ SEP_R_TAC \\ fs []
        \\ REWRITE_TAC [GSYM CONJ_ASSOC] \\ STRIP_TAC
        THEN1
         (SEP_W_TAC \\ POP_ASSUM MP_TAC
          \\ fs [AC STAR_ASSOC STAR_COMM]
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
        \\ fs [mw_ok_i2mw]
        \\ MATCH_MP_TAC num_length_lemma \\ fs []
        \\ DECIDE_TAC)
      \\ fs [zBIGNUMS_ALT_def,SEP_IMP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ REPEAT STRIP_TAC \\ fs [zHEAP_def]
      \\ SIMP_TAC (std_ss++sep_cond_ss) [SEP_CLAUSES,cond_STAR,SEP_EXISTS_THM]
      \\ ONCE_REWRITE_TAC [CONJ_COMM]
      \\ fs [multiwordTheory.mw2i_i2mw]
      \\ Q.EXISTS_TAC `vals with <|
            stack := MAP (x64_addr vs.current_heap) roots ++
                     0x1w::cs.ret_address::cs.rest_of_stack ;
            reg10 := (HD (MAP (n2w o ORD) s.input ++ [not_0w])) ;
            reg9 := vs.base_ptr ;
            reg7 := (0x8w * n2w (heap_length ys1 + sp) + vs.current_heap +
                     -0x1w) ;
            reg1 := x64_addr vs.current_heap r2 ;
            reg2 := x64_addr vs.current_heap r3 ;
            reg3 := x64_addr vs.current_heap r4 ;
            reg6 := (0x8w * n2w (heap_length ys1) + vs.current_heap +
                     (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then 0x0w
                      else n2w (8 * LENGTH
                        ((SND (i2mw (int_op (n2iop (getNumber x4))
                            i1 i2))):word64 list) + 8)) + -0x1w) ;
            reg0 := (if small_int (int_op (n2iop (getNumber x4)) i1 i2) then
                       small_int_to_word (int_op (n2iop (getNumber x4)) i1 i2)
                     else
                       (0x8w * n2w (heap_length ys1) + vs.current_heap + -0x1w)) ;
            memory := m ;
            memory_domain := dm ;
            input_stream := MAP (n2w o ORD) (DROP 1 s.input) ;
            output_stream := MAP (n2w o ORD) s.output ++
              if n2iop (getNumber x4) = Dec then
                MAP (n2w o ORD) (int_to_str i1)
              else [] |>`
      \\ STRIP_TAC
      THEN1 (fs [zVALS_def] \\ fs [AC STAR_ASSOC STAR_COMM]
             \\ POP_ASSUM MP_TAC
             \\ MATCH_MP_TAC (METIS_PROVE [] ``(x=y)==>(x==>y)``)
             \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ fs [heap_inv_def,x64_multiwordTheory.bignum_mem_def]
      \\ Cases_on `small_int (int_op (n2iop (getNumber x4)) i1 i2)` \\ fs []
      THEN1
       (Q.LIST_EXISTS_TAC [`vs`,
           `Data (2w * n2w (Num (int_op (n2iop (getNumber x4)) i1 i2)))`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++ Unused (LENGTH xs  1)::ys2`,
           `heap_length ys1`,`sp`]
        \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
        \\ fs [word_mul_n2w,small_int_to_word_def,x64_addr_def]
        \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
        \\ STRIP_TAC THEN1
         (IMP_RES_TAC small_int_num_exists
          \\ SRW_TAC [] [] \\ fs [GSYM word_mul_n2w]
          \\ MATCH_MP_TAC abs_ml_inv_Num_new \\ fs []
          \\ Q.LIST_EXISTS_TAC [`Number (&k'')`,`r1`]
          \\ Q.PAT_ASSUM `abs_ml_inv xx yy tt ss` MP_TAC
          \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
          \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
          \\ REPEAT (POP_ASSUM (K ALL_TAC)) \\ fs [])
        \\ fs [x64_heap_APPEND,x64_heap_def,x64_el_def,el_length_def]
        \\ SRW_TAC [] [] \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ Q.ABBREV_TAC `result = i2mw
             (int_op (n2iop (getNumber x4)) i1 i2):(bool # word64 list)`
        \\ Q.EXISTS_TAC
            `b2w (FST (result:(bool # word64 list))) +
             n2w (LENGTH (SND (result:(bool # word64 list))))  16 + 0x2w::
             (SND (i2mw (int_op (n2iop (getNumber x4)) i1 i2)) ++ zs1) ++
             [x64_addr vs.current_heap r2 >>> 2;
              x64_addr vs.current_heap r1 >>> 2]` \\ Q.EXISTS_TAC `xs'`
        \\ fs [ADD1,GSYM ADD_ASSOC]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w,
                 AC WORD_MULT_COMM WORD_MULT_ASSOC,
                 AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      \\ Q.LIST_EXISTS_TAC [`vs`,
           `Pointer (heap_length ys1)`,
           `r2`,`r3`,`r4`,`roots`,`ys1 ++
             IntData (int_op (n2iop (getNumber x4)) i1 i2) ::
             Unused (LENGTH zs1 + 1)::ys2`,
           `heap_length ys1 +
            num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) + 1`,
           `sp - num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) - 1`]
      \\ fs [push_state_accesses,getNumber_def,heap_vars_ok_def]
      \\ REWRITE_TAC [CONJ_ASSOC] \\ REVERSE STRIP_TAC THEN1 SRW_TAC [] []
      \\ fs [x64_addr_def,WORD_MUL_LSL]
      \\ REVERSE (REPEAT STRIP_TAC)
      THEN1
       (Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ fs [ADD1,GSYM ADD_ASSOC,x64_heap_def,x64_heap_APPEND,
               IntData_def,DataOnly_def,x64_el_def,x64_payload_def,LET_DEF]
        \\ fs [one_list_def,one_list_APPEND,SEP_CLAUSES,array64_one_list]
        \\ fs [heap_length_def,heap_length_APPEND,el_length_def]
        \\ fs [GSYM heap_length_def,word_mul_n2w,word_add_n2w,
                 LEFT_ADD_DISTRIB,MULT_CLAUSES]
        \\ fs [GSYM word_mul_n2w,GSYM word_add_n2w,SEP_CLAUSES,array64_one_list]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss)
              [GSYM word_mul_n2w,GSYM word_add_n2w,cond_STAR,
               AC WORD_MULT_COMM WORD_MULT_ASSOC,
               AC WORD_ADD_COMM WORD_ADD_ASSOC]
        \\ fs [AC STAR_ASSOC STAR_COMM]
        \\ MATCH_MP_TAC (METIS_PROVE [] ``b /\ (x ==> y) ==> (x ==> b /\ y)``)
        \\ STRIP_TAC THEN1
         (fs [mw_thm]
          \\ MATCH_MP_TAC (RW [multiwordTheory.i2mw_def] num_length_lemma)
          \\ fs [] \\ DECIDE_TAC)
        \\ fs [multiwordTheory.i2mw_def,mw_thm]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
        \\ fs [one_list_exists_def,SEP_CLAUSES,SEP_EXISTS_THM]
        \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
        \\ REPEAT STRIP_TAC
        \\ Q.LIST_EXISTS_TAC [`xs''`,`zs1 ++
             [x64_addr vs.current_heap r2 >>> 2;
              x64_addr vs.current_heap r1 >>> 2]`]
        \\ Q.PAT_ASSUM `xxx = n2mw (Num (ABS i1))` (ASSUME_TAC o GSYM)
        \\ fs [one_list_def,SEP_CLAUSES,one_list_APPEND]
        \\ fs [word_mul_n2w,word_add_n2w]
        \\ `n2w (8 * LENGTH
             (n2mw (Num (ABS (int_op (n2iop (getNumber x4)) i1 i2))):word64 list) +
            8 * heap_length ys1 + 8 * LENGTH zs1) =
            n2w (8 * sp + 8 * heap_length ys1) - 24w:word64` by ALL_TAC THEN1
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB]
          \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w,GSYM word_add_n2w]
          \\ fs [] \\ FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss [] \\ fs []
        \\ Q.PAT_ASSUM `xxx (fun2set (m,dm))` MP_TAC
        \\ MATCH_MP_TAC (METIS_PROVE [] ``(x = y) ==> (x ==> y)``)
        \\ `!w v. n2w w + vs.current_heap + n2w v =
                  n2w (w + v) + vs.current_heap` by
         (FULL_SIMP_TAC std_ss [AC WORD_ADD_COMM WORD_ADD_ASSOC]
          \\ fs [WORD_ADD_ASSOC,word_add_n2w,AC ADD_COMM ADD_ASSOC])
        \\ FULL_SIMP_TAC std_ss []
        \\ `8 * LENGTH zs1 + 8 *
            LENGTH (n2mw (Num (ABS (int_op (n2iop (getNumber x4))
              i1 i2))):word64 list) +
            8 * heap_length ys1 + 24 =
            8 * heap_length ys1 + 8 * (sp  1) + 8` by
         (Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
          \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM) \\ fs []
          \\ fs [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB] \\ DECIDE_TAC)
        \\ fs []
        \\ fs [WORD_MUL_LSL,word_mul_n2w]
        \\ fs [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
        \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
      THEN1
       (fs [GSYM word_mul_n2w] \\ AP_TERM_TAC \\ AP_TERM_TAC
        \\ fs [GSYM ADD_ASSOC]
        \\ `num_size (Number (int_op (n2iop (getNumber x4)) i1 i2)) +
              2 <= sp` by
         (MP_TAC (Q.INST [`op`|->`(n2iop (getNumber x4))`,`i`|->`i1`,
              `j`|->`i1`] LENGTH_int_op)
          \\ fs [num_size_def,multiwordTheory.i2mw_def,mw_thm]
          \\ DECIDE_TAC)
        \\ DECIDE_TAC)
      THEN1
       (fs [LEFT_ADD_DISTRIB,num_size_def,mw_thm,multiwordTheory.i2mw_def,
            word_mul_n2w,word_add_n2w,AC ADD_COMM ADD_ASSOC])
      \\ MATCH_MP_TAC (abs_ml_inv_Num_BIG |> GEN_ALL)
      \\ Q.LIST_EXISTS_TAC [`Number i1`,`r1`] \\ fs []
      \\ fs [] \\ Q.PAT_ASSUM `xxx = LENGTH rest` (ASSUME_TAC o GSYM)
      \\ fs [] \\ Q.PAT_ASSUM `xxx = sp` (ASSUME_TAC o GSYM) \\ fs []
      \\ fs [multiwordTheory.i2mw_def,num_size_def,mw_thm]
      \\ DECIDE_TAC)

    \\ `F` by ALL_TAC
    \\ REPEAT (Q.PAT_ASSUM `~(CONTAINER bbb)` MP_TAC)
    \\ fs [ml_translatorTheory.CONTAINER_def]
    \\ `(small_int i1 \/ small_int i2) ==> (i1 <> i2)` by ALL_TAC THEN1
     (fs [heap_inv_def,abs_ml_inv_def,bc_stack_ref_inv_def,bc_value_inv_def]
      \\ POP_ASSUM MP_TAC \\ fs [] \\ Cases_on `i1 = i2` \\ fs []
      \\ SRW_TAC [] [] \\ REPEAT STRIP_TAC \\ fs [] \\ rfs [])
    \\ Cases_on `small_int i1` \\ fs []
    \\ Cases_on `small_int i2` \\ fs []
    \\ Cases_on `i1 = 0` \\ fs []
    \\ Cases_on `i2 = 0` \\ fs []
    \\ IMP_RES_TAC NOT_small_int_IMP_NOT_0 \\ fs [])

  val th = MP th lemma |> RW [GSYM SPEC_MOVE_COND]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS * zPC p *
      cond (isNumber x1 /\ isNumber x2 /\ isNumber x4 /\
            (((n2iop (getNumber x4)) = Div) ==> x2 <> Number 0) /\
            (((n2iop (getNumber x4)) = Mod) ==> x2 <> Number 0) /\
            0 <= getNumber x4 /\ getNumber x4 <= 7 /\
            num_size x1 + num_size x2 + 5 < 2**32)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_CALL_BIGNUM = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "mov r13, [r9+56]")
  val th = SPEC_COMPOSE_RULE [th,x64_call_r13,x64_pop_r13]
           |> SIMP_RULE std_ss [NOT_CONS_NIL,HD,TL,SEP_CLAUSES]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 56w) = cs.bignum_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals).
                (p + 0x7w = vals.reg13))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg13 := p + 7w |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;

val zHEAP_TEST_BIGNUM_SIZE_LIMIT = let
  val th1 = spec "mov r15,1"
  val th2 = spec "shl r15,34"
  val th = SPEC_COMPOSE_RULE [th1,th2,spec "cmp r14,r15"]
  val th = HIDE_STATUS_RULE false sts th
  val th = HIDE_POST_RULE ``zS1 Z_AF`` th
  val th = HIDE_POST_RULE ``zS1 Z_SF`` th
  val th = HIDE_POST_RULE ``zS1 Z_PF`` th
  val th = HIDE_POST_RULE ``zS1 Z_OF`` th
  val th = HIDE_POST_RULE ``zS1 Z_ZF`` th
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
              |> UNDISCH_ALL |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val inv = ``SOME (\(sp:num,vals). vals.reg14 = w)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^inv) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,^inv) * ~zS1 Z_AF *
      ~zS1 Z_ZF * ~zS1 Z_OF *
      ~zS1 Z_SF * zS1 Z_CF (SOME (w <+ n2w (2 ** 34))) *
      ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ NTAC 2 STRIP_TAC
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`vals with <| reg15 := 1w << 34 |>`]
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,zVALS_def]
    \\ `vals.reg14 = w` by fs [heap_inv_def] \\ fs []
    \\ STRIP_TAC THEN1 (fs [heap_inv_def] \\ METIS_TAC [])
    \\ fs [AC STAR_ASSOC STAR_COMM])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, ^inv) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM])
  val th = MP th lemma
  in th end;

val zHEAP_ALLOC_THEN_BIGNUM = let
  val th2 = SPEC_COMPOSE_RULE [zHEAP_ALLOC
                |> Q.INST [`needed`|->`num_size x1 + num_size x2 + 5`],
              zHEAP_PERFORM_BIGNUM]
            |> RW [SPEC_MOVE_COND] |> UNDISCH_ALL
  in th2 end

val heap_inv_num_size_LESS_1 = prove(
  ``isNumber x1 /\
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,space) vals ==>
    num_size x1 < 2**48``,
  fs [heap_inv_def] \\ Cases_on `x1` \\ fs [isNumber_def]
  \\ REPEAT STRIP_TAC \\ fs [abs_ml_inv_def,bc_stack_ref_inv_def]
  \\ fs [bc_value_inv_def]
  \\ Cases_on `small_int i` \\ fs [] THEN1
   (fs [small_int_def,num_size_def]
    \\ REVERSE (Cases_on `i`) \\ fs [] THEN1 EVAL_TAC
    \\ `(Num (ABS (&n))) = n` by intLib.COOPER_TAC \\ fs []
    \\ ONCE_REWRITE_TAC [mw_def] \\ fs []
    \\ `n DIV 18446744073709551616 = 0` by (fs [DIV_EQ_X] \\ DECIDE_TAC)
    \\ fs [] \\ EVAL_TAC)
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def,DataOnly_def]
  \\ fs [num_size_def]);

val heap_inv_num_size_LESS_2 = prove(
  ``isNumber x2 /\
    heap_inv (cs,x1,x2,x3,x4,refs,stack,s,space) vals ==>
    num_size x2 < 2**48``,
  fs [heap_inv_def] \\ Cases_on `x2` \\ fs [isNumber_def]
  \\ REPEAT STRIP_TAC \\ fs [abs_ml_inv_def,bc_stack_ref_inv_def]
  \\ fs [bc_value_inv_def]
  \\ Cases_on `small_int i` \\ fs [] THEN1
   (fs [small_int_def,num_size_def]
    \\ REVERSE (Cases_on `i`) \\ fs [] THEN1 EVAL_TAC
    \\ `(Num (ABS (&n))) = n` by intLib.COOPER_TAC \\ fs []
    \\ ONCE_REWRITE_TAC [mw_def] \\ fs []
    \\ `n DIV 18446744073709551616 = 0` by (fs [DIV_EQ_X] \\ DECIDE_TAC)
    \\ fs [] \\ EVAL_TAC)
  \\ IMP_RES_TAC heap_lookup_SPLIT
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [x64_heap_APPEND,x64_heap_def,x64_el_def,
         x64_payload_def,SEP_CLAUSES,cond_STAR,MAP,LET_DEF,LENGTH,one_list_def,
         x64_addr_def,WORD_MUL_LSL,BlockRep_def,DataOnly_def]
  \\ fs [num_size_def]);

val zHEAP_ALLOC_THEN_BIGNUM_GOOD_PRE = let
  val ((th2,_,_),x) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jb 4")
  fun the (SOME x) = x | the _ = fail()
  val (th2a,_,_) = the x
  val th = zHEAP_TEST_BIGNUM_SIZE_LIMIT
  val (th,goal) = SPEC_WEAKEN_RULE th
      ``zHEAP
          (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF * ~zS1 Z_ZF *
        ~zS1 Z_OF * ~zS1 Z_SF * zS1 Z_CF (SOME ((w:word64) <+ 0x400000000w)) *
        ~zS1 Z_PF * zPC (p + 0x11w)``
  val lemma = prove(goal,
    fs [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals` \\ fs []
    \\ fs [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma
  val th1 = SPEC_COMPOSE_RULE [th,th2a]
  val th1 = HIDE_STATUS_RULE true sts th1
  val thA = SPEC_COMPOSE_RULE [th1,zHEAP_TERMINATE_WITH_ERROR]
  val (_,_,code,_) = dest_spec (concl thA)
  val th = zHEAP_TEST_BIGNUM_SIZE_LIMIT
  val th = SPEC_COMPOSE_RULE [th,th2]
  val th = HIDE_STATUS_RULE true sts th
  val cc = SIMP_CONV std_ss [INSERT_SUBSET,EMPTY_SUBSET,IN_INSERT]
           THENC SIMP_CONV std_ss [SUBSET_DEF,IN_INSERT,IN_UNION]
  val th = MP (MATCH_MP SPEC_SUBSET_CODE th |> SPEC code
     |> CONV_RULE ((RATOR_CONV o RAND_CONV) cc)) TRUTH
  val th = th |> Q.INST [`w`|->`n2w (8 * (num_size x1 + num_size x2 + 5))`]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_ALLOC_THEN_BIGNUM]
  val thB = th |> DISCH_ALL
               |> SIMP_RULE (std_ss++sep_cond_ss) [GSYM SPEC_MOVE_COND,precond_def]
  val thA = thA |> Q.INST [`w`|->`n2w (8 * (num_size x1 + num_size x2 + 5))`]
                |> SIMP_RULE std_ss [precond_def]
  val (_,_,code,_) = dest_spec (concl thB)
  val thA = MP (MATCH_MP SPEC_SUBSET_CODE thA |> SPEC code
     |> CONV_RULE ((RATOR_CONV o RAND_CONV) cc)) TRUTH
  val lemma = SPEC_MERGE |> Q.SPECL [`x`,`p1`,`p2`,`c`,`SEP_F`,`c`]
                  |> SIMP_RULE std_ss [SEP_CLAUSES,UNION_IDEMPOT]
  val th = MATCH_MP lemma (CONJ thB thA)
           |> RW [SEP_CLAUSES,SEP_DISJ_ASSOC]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s, SOME (\(sp,vals).
              vals.reg14 = n2w (8 * (num_size x1 + num_size x2 + 5)))) *
      zPC p * ~zS * cond (isNumber x1 /\ isNumber x2 /\ isNumber x4 /\
            (((n2iop (getNumber x4)) = Div) ==> x2 <> Number 0) /\
            (((n2iop (getNumber x4)) = Mod) ==> x2 <> Number 0) /\
            0 <= getNumber x4 /\ getNumber x4 <= 7)``
  val lemma = prove(goal,
    fs [SEP_IMP_def]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [STAR_ASSOC,cond_STAR]
    \\ REPEAT STRIP_TAC
    \\ `(8 * (num_size x1 + num_size x2 + 5)) < 18446744073709551616` by
     (fs [zHEAP_def,SEP_CLAUSES,SEP_EXISTS_THM,STAR_ASSOC,cond_STAR]
      \\ IMP_RES_TAC heap_inv_num_size_LESS_1
      \\ IMP_RES_TAC heap_inv_num_size_LESS_2
      \\ fs [] \\ DECIDE_TAC)
    \\ fs [WORD_LO]
    \\ Cases_on `8 * (num_size x1 + num_size x2 + 5) < 17179869184` \\ fs []
    \\ fs [SEP_CLAUSES,cond_STAR]
    \\ DECIDE_TAC)
  val th = MP th lemma
  in th end

val zHEAP_BIGNUM_OP = let
  val th1 = zHEAP_CALL_BIGNUM
  val th2 = SPEC_COMPOSE_RULE [zHEAP_NUM_SIZE,zHEAP_ALLOC_THEN_BIGNUM_GOOD_PRE]
            |> RW [SPEC_MOVE_COND] |> UNDISCH_ALL
  val thA = SPEC_COMPOSE_RULE [zHEAP_PUSH_R13_IN_PARTS,th2,
                               zHEAP_POP_R13_IN_PARTS]
            |> Q.INST [`sss`|->`stack`] |> RW [SEP_CLAUSES]
            |> RW1 [EQ_SYM_EQ]
  val th3 = zHEAP_JMP_r13
  val (th3,goal) = SPEC_WEAKEN_RULE th3 ``(zHEAP
        (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC ret)``
  val lemma = prove(goal,
    SIMP_TAC std_ss [SEP_IMP_def,zHEAP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals` \\ FULL_SIMP_TAC std_ss []
    \\ IMP_RES_TAC heap_inv_IMP_NONE)
  val th3 = MP th3 lemma |> Q.INST [`P`|->`\x.T`] |> SIMP_RULE std_ss []
  val pc = find_term (can (match_term ``zPC xxx``)) (th |> concl |> rand)
  val th = SPEC_COMPOSE_RULE [thA,th3|>RW1[EQ_SYM_EQ]]
           |> DISCH_ALL |> RW [AND_IMP_INTRO]
           |> RW [GSYM SPEC_MOVE_COND,fetch "-" "temp_code_def"]
  val thA = th1
  val thB = th |> Q.INST [`r13`|->`p+7w`,`p`|->`cs.bignum_ptr + 0x2w`]
               |> SIMP_RULE std_ss [word_arith_lemma1,SPEC_MOVE_COND]
               |> UNDISCH_ALL
  val f = RW [STAR_ASSOC] o SIMP_RULE (std_ss++star_ss) []
  val th = MATCH_MP SPEC_COMPOSE (CONJ (f thA) (f thB))
  val th = th |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  val th = abbreviate_code "bignum" ``cs.bignum_ptr`` th
  in th end

fun get_INT_OP n = let
  val th = zHEAP_Num4 |> Q.INST [`k`|->`^n`]
           |> SIMP_RULE (srw_ss()) [w2w_def,w2n_n2w,SEP_CLAUSES]
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH4,th,zHEAP_BIGNUM_OP]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_POP4]
  val th = th |> SIMP_RULE (srw_ss()) [NOT_CONS_NIL,SEP_CLAUSES,
             getNumber_def,n2iop_def,multiwordTheory.int_op_def,HD,TL]
  in th end;

val zHEAP_Add = get_INT_OP ``0:num``;
val zHEAP_Sub = get_INT_OP ``1:num``;
val zHEAP_Lt  = get_INT_OP ``2:num``;
val zHEAP_Eq  = get_INT_OP ``3:num``;
val zHEAP_Mul = get_INT_OP ``4:num``;
val zHEAP_Div = get_INT_OP ``5:num``;
val zHEAP_Mod = get_INT_OP ``6:num``;
val zHEAP_Dec = get_INT_OP ``7:num``;

val zHEAP_ADD_SMALL_INT = let
  val th = zHEAP_Add
  val _ = add_compiled [th]
  in th end;

val zHEAP_SUB_SMALL_INT = let
  val th = zHEAP_Sub
  val _ = add_compiled [th]
  in th end;

val zHEAP_MUL_SMALL_INT = let
  val th = zHEAP_Mul
  val _ = add_compiled [th]
  in th end;

val zHEAP_DIV_SMALL_INT = let
  val th = zHEAP_Div
  in th end;

val zHEAP_MOD_SMALL_INT = let
  val th = zHEAP_Mod
  in th end;

val zHEAP_PRINT_SMALL_INT = let
  val th = zHEAP_Dec
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_PUSH2,
             zHEAP_MOVE_12,th,zHEAP_POP2,zHEAP_POP1]
  val th = th |> RW [TL,HD,NOT_CONS_NIL,SEP_CLAUSES]
  val _ = add_compiled [th]
  in th end;

val zHEAP_SMALL_INT = let
  val lemma1 = prove(
    ``((Number (if b then 1 else 0) = Number 1) <=> b) /\
      ((Number (if b then 1 else 0) = Number 0) <=> ~b) /\
      (~b \/ b <=> T)``,
    SRW_TAC [] [])
  val th = SPEC_COMPOSE_RULE [zHEAP_SWAP_12,zHEAP_Lt,zHEAP_BOOL_INTRO]
           |> RW [lemma1,SEP_CLAUSES]
  val _ = add_compiled [th]
  in th end;

(* number operations *)

val any_add_def = Define `any_add x1 x2 = Number (getNumber x1 + getNumber x2)`;
val any_sub_def = Define `any_sub x1 x2 = Number (getNumber x1 - getNumber x2)`;
val any_mul_def = Define `any_mul x1 x2 = Number (getNumber x1 * getNumber x2)`;

fun store_bignum_op th = let
  val th = th |> RW (map GSYM [any_add_def,any_sub_def,any_mul_def])
  in add_compiled [th] end

val _ = store_bignum_op zHEAP_ADD_SMALL_INT
val _ = store_bignum_op zHEAP_SUB_SMALL_INT
val _ = store_bignum_op zHEAP_MUL_SMALL_INT

(* print string *)

val (bc_print_chars_res,bc_print_chars_def,bc_print_chars_pre_def) = x64_compile `
  bc_print_chars (x1,stack,s) =
    let (x1,stack) = (HD stack, TL stack) in
      if isBlock x1 then (x1,stack,s) else
      if getNumber x1 = 9 then
        let s = s with output := s.output ++ "\\t" in
          bc_print_chars (x1,stack,s)
      else if getNumber x1 = 10 then
        let s = s with output := s.output ++ "\\n" in
          bc_print_chars (x1,stack,s)
      else  if getNumber x1 = 92 then
        let s = s with output := s.output ++ "\\\\" in
          bc_print_chars (x1,stack,s)
      else
        let s = s with output := s.output ++ [CHR (Num (getNumber x1))] in
          bc_print_chars (x1,stack,s)`;

val only_chars_def = Define `
  (only_chars [] = T) /\
  (only_chars ((Number n)::xs) <=> 0 <= n /\ n < 256 /\ only_chars xs) /\
  (only_chars (x::xs) <=> F)`

val bc_print_chars = prove(
  ``!xs x1 b s.
      isBlock b /\ only_chars xs ==>
      bc_print_chars_pre (x1,xs ++ b::stack,s) /\
      (bc_print_chars (x1,xs ++ b::stack,s) =
       (b,stack,s with output := s.output ++
           string_escape (MAP (CHR o Num o getNumber) xs)))``,
  Induct THEN1
   (ONCE_REWRITE_TAC [bc_print_chars_def,bc_print_chars_pre_def]
    \\ NTAC 2 Cases \\ ASM_SIMP_TAC (srw_ss()) [APPEND,LET_DEF,HD,TL,
          canCompare_def,isBlock_def,only_chars_def,
          semanticPrimitivesTheory.string_escape_def]
    \\ Cases \\ SRW_TAC [] (TypeBase.updates_of ``:zheap_state``))
  \\ Cases \\ FULL_SIMP_TAC std_ss [only_chars_def,is_char_def,APPEND]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC std_ss []
  \\ ONCE_REWRITE_TAC [bc_print_chars_def,bc_print_chars_pre_def]
  \\ ASM_SIMP_TAC (srw_ss()) [APPEND,LET_DEF,HD,TL,
          canCompare_def,isBlock_def,only_chars_def,getNumber_def]
  \\ Cases_on `i = 9` \\ Cases_on `i = 10` \\ Cases_on `i = 92`
  \\ FULL_SIMP_TAC (srw_ss()) [
        semanticPrimitivesTheory.string_escape_def,isNumber_def]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
  \\ `~(i < 0)` by intLib.COOPER_TAC
  \\ `CHR (Num i) <> #"\n" /\ CHR (Num i) <> #"\t" /\
      CHR (Num i) <> #"\\"` by ALL_TAC THEN1
   (Cases_on `i` \\ SRW_TAC [] [CHR_11]
    \\ TRY (`F` by intLib.COOPER_TAC)
    \\ `n < 256` by intLib.COOPER_TAC
    \\ FULL_SIMP_TAC std_ss [CHR_11] \\ intLib.COOPER_TAC)
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]);

val zHEAP_PRINT_STRING_BLOCK = let
  val th0 = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_EXPLODE_BLOCK_SIMPLE]
  val th1 =
    bc_print_chars_res
    |> Q.INST [`stack`|->`xs++b::stack`]
    |> DISCH ``isBlock b /\ only_chars xs``
    |> SIMP_RULE std_ss [bc_print_chars,LET_DEF]
    |> RW [GSYM SPEC_MOVE_COND,SEP_CLAUSES]
  val th = SPEC_COMPOSE_RULE [th0,th1]
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH3,zHEAP_PUSH2,th,zHEAP_POP2,zHEAP_POP3]
    |> SIMP_RULE std_ss [HD,TL,NOT_CONS_NIL,CONJ_ASSOC,SEP_CLAUSES]
  val _ = add_compiled [th]
  in th end;

val (_,bc_print_str_def,bc_print_str_pre_def) = x64_compile `
  bc_print_str (x1,s) =
    let s = s with output := s.output ++ "\"" in
    let s = s with output := STRCAT s.output (string_escape
                (MAP (CHR o Num o getNumber) (getContent x1))) in
    let s = s with output := s.output ++ "\"" in
      (x1,s)`

(* print *)

val (bc_print_aux_res,bc_print_aux_def,bc_print_aux_pre_def) = x64_compile `
  bc_print_aux (x1:bc_value,x2:bc_value,s) =
    if s.local.printing_on = 0x0w then
      (x1,x2,s)
    else if isNumber x1 then
      let s = s with output := STRCAT s.output (int_to_str (getNumber x1)) in
        (x1,x2,s)
    else if isBlock x1 then
      let x2 = x1 in
      let x1 = Number (&getTag x1) in
        if getNumber x1 = 10 then (* false *)
          let s = s with output := STRCAT s.output "false" in (x1,x2,s)
        else if getNumber x1 = 9 then (* true *)
          let s = s with output := STRCAT s.output "true" in (x1,x2,s)
        else if getNumber x1 = 3 then (* unit_tag *)
          let s = s with output := STRCAT s.output "(" in
          let s = s with output := STRCAT s.output ")" in (x1,x2,s)
        else if getNumber x1 = 2 then (* closure_tag *)
          let s = s with output := STRCAT s.output "<fn>" in (x1,x2,s)
        else if getNumber x1 = 1 then (* vector_tag *)
          let s = s with output := STRCAT s.output "<vector>" in (x1,x2,s)
        else if getNumber x1 = 0 then (* string_tag *)
          let x1 = x2 in
          let (x1,s) = bc_print_str (x1,s) in (x1,x2,s)
        else (* constructor *)
          let s = s with output := STRCAT s.output "<constructor>" in (x1,x2,s)
    else (* RefPtr, since CodePtr and StackPtr forbidden *)
      let s = s with output := STRCAT s.output "<ref>" in
        (x1,x2,s)`

val (bc_print_res,bc_print_def,bc_print_pre_def) = x64_compile `
  bc_print (x1:bc_value,x2:bc_value,s) =
    let (x1,x2,s) = bc_print_aux (x1,x2,s) in
    let x1 = Number 0 in
    let x2 = x1 in
      (x1,x2,s)`;

val bc_value1_size_thm = store_thm("bc_value1_size_thm",
  ``!ls. bc_value1_size ls = SUM (MAP bc_value_size ls) + LENGTH ls``,
  Induct THEN1 FULL_SIMP_TAC (srw_ss()) [bytecodeTheory.bc_value_size_def]
  THEN SRW_TAC [ARITH_ss][bytecodeTheory.bc_value_size_def])

val bvs_to_chars_lemma = prove(
  ``!l xs.
       only_chars l ==> (bvs_to_chars l xs =
                           SOME (REVERSE xs ++ MAP (CHR o Num o getNumber) l))``,
  Induct THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ Cases \\ ASM_SIMP_TAC std_ss [only_chars_def,is_char_def,bvs_to_chars_def]
  \\ SRW_TAC [] [getNumber_def]
  \\ REPEAT AP_TERM_TAC
  \\ intLib.COOPER_TAC);

val bvs_to_chars_imp = prove(
  ``l acc z. (bvs_to_chars l acc = SOME z)  only_chars l``,
  Induct >> simp[bvs_to_chars_def,only_chars_def] >>
  Cases >> simp[bvs_to_chars_def,only_chars_def] >>
  rw[] >> res_tac);

val int_to_string_lemma = prove(
  ``int_to_string = int_to_str``,
  fs [semanticPrimitivesTheory.int_to_string_def,FUN_EQ_THM,
      multiwordTheory.int_to_str_def] \\ SRW_TAC [] []
  \\ Cases_on `x` \\ fs [] \\ intLib.COOPER_TAC);

val bc_print_thm = prove(
  ``IS_SOME (bv_to_string x1) ==>
    bc_print_pre (x1,x2,s) /\
    (bc_print (x1,x2,s) =
      (Number 0,Number 0,
       if s.local.printing_on = 0x0w then s else
       s with output := s.output ++ THE (bv_to_string x1)))``,
  Cases_on`x1` >> rw[] >>
  simp[bc_print_pre_def,bc_print_aux_pre_def,getNumber_def,isNumber_def,
       isBlock_def,getTag_def,canCompare_def,bv_to_string_def,
       bc_print_aux_def,bc_print_def,bc_print_str_def,
       bc_print_str_pre_def,getContent_def,int_to_string_lemma] >>
  rw[] >> fs[bv_to_string_def,miscTheory.IS_SOME_EXISTS] >> rw[] >>
  BasicProvers.EVERY_CASE_TAC >> fs[] >>
  simp[theorem"zheap_state_component_equality"] >> rw[] >>
  simp[IMPLODE_EXPLODE_I] >>
  imp_res_tac bvs_to_chars_imp >>
  imp_res_tac bvs_to_chars_lemma >> fs[] >>
  EVAL_TAC)

val zHEAP_RAW_PRINT =
  bc_print_res
    |> DISCH ``IS_SOME (bv_to_string x1)``
    |> SIMP_RULE std_ss [bc_print_thm,SEP_CLAUSES,LET_DEF]
    |> RW [GSYM SPEC_MOVE_COND]

(* IsBlock instruction *)

val (bc_is_block_res,bc_is_block_def,bc_is_block_pre_def) = x64_compile `
  bc_is_block x1 =
    if isBlock x1 then
      let x1 = bool_to_val T in x1
    else
      let x1 = bool_to_val F in x1`

val bc_is_block_thm = prove(
  ``bc_is_block x1 = bool_to_val (isBlock x1)``,
  SRW_TAC [] [bc_is_block_def]);

val zHEAP_isBlock_Intr = bc_is_block_res
  |> SIMP_RULE std_ss [bc_is_block_thm,LET_DEF,bc_is_block_pre_def]


(* ret *)

val ret_lemma =
  abs_ml_inv_stack_permute
  |> Q.SPECL [`[(x1,r1);(x2,r2);(x3,r3);(x4,r4);(x5,r5)]`,
              `[(x1,r1);(x2,r2);(x3,r3);(x4,r4)]`]
  |> SIMP_RULE std_ss [MAP,APPEND,SUBSET_DEF,MEM,DISJ_IMP] |> GEN_ALL

val zHEAP_RET_1 = let
  val th = x64_ret_spec_1
  val th = th |> Q.INST [`rip`|->`p`]
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            stack <> [] /\ isCodePtr (HD stack))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_1_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,x1,x2,x3,x4,refs,TL stack,s,NONE) * ~zS *
     zPC (2w * n2w (getCodePtr (HD stack)))`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    Cases_on `stack` \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,HD,TL]
    \\ Cases_on `h` \\ FULL_SIMP_TAC std_ss [isCodePtr_def]
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ FULL_SIMP_TAC std_ss [Once heap_inv_def,getCodePtr_def]
    \\ STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()) [])
    \\ `?rs. (roots = Data (n2w n) :: rs)` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,
        APPEND,LIST_REL_def] \\ Cases_on `roots`
      \\ FULL_SIMP_TAC (srw_ss()) [LIST_REL_def,bc_value_inv_def,CONS_11])
    \\ FULL_SIMP_TAC std_ss [APPEND,HD,TL,MAP]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| stack := TL vals.stack |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ `x64_addr vs.current_heap (Data (n2w n)) = 2w * n2w n` by ALL_TAC THEN1
     (SIMP_TAC (srw_ss()) [x64_addr_def,WORD_MUL_LSL,w2w_def,word_mul_n2w,w2n_n2w]
      \\ FULL_SIMP_TAC (srw_ss()) [MOD_COMMON_FACTOR])
    \\ FULL_SIMP_TAC std_ss [TL]
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ POP_ASSUM MP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [x64_addr_def]
      \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM APPEND_ASSOC,APPEND])
    \\ POP_ASSUM (K ALL_TAC) \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`rs`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ MATCH_MP_TAC ret_lemma \\ METIS_TAC [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_1_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (stack <> [] /\ isCodePtr (HD stack))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_RET = MATCH_MP SPEC_1_IMP_SPEC zHEAP_RET_1 |> RW [SEP_CLAUSES];


(* call R15 *)

val EVEN_w2n = prove(
  ``!w. EVEN (w2n w) = ~(w ' 0)``,
  Cases \\ FULL_SIMP_TAC (srw_ss()) [word_index,ZERO_LT_dimword,bitTheory.BIT_def,
    bitTheory.BITS_THM,EVEN_MOD2]
  \\ `n MOD 2 < 2` by FULL_SIMP_TAC std_ss [MOD_LESS]
  \\ DECIDE_TAC);

val zHEAP_CALL_R15 = let
  val th = x64_call_r15
  val th = SPEC_FRAME_RULE th ``~zS``
  val ss = ``SOME (\(sp:num,vals). vals.reg15 = r15)``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,^ss) vals /\ EVEN (w2n (p + 3w)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,
                           CodePtr ((w2n (p+3w:word64)) DIV 2)::stack,s,NONE) * ~zS *
                           zPC r15`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with stack := (p+3w) :: vals.stack`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
         `(Data (n2w (w2n (p+3w) DIV 2)))::roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [CONS_11,MAP]
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,roots_ok_def,MEM]
      \\ STRIP_TAC THEN1 METIS_TAC []
      \\ FULL_SIMP_TAC (srw_ss()) [bc_stack_ref_inv_def,LIST_REL_def,
            reachable_refs_def,MEM]
      \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC (srw_ss()) [bc_value_inv_def,w2w_def]
      \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL]
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
      \\ NTAC 2 (POP_ASSUM MP_TAC)
      \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]
      \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [EVEN_w2n]
    \\ SIMP_TAC std_ss [x64_addr_def,GSYM w2w_def,
         w2n_lsr |> Q.SPECL [`w`,`1`] |> SIMP_RULE std_ss [] |> GSYM]
    \\ POP_ASSUM MP_TAC \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^ss) * ~zS * zPC p * cond (EVEN (w2n (p + 3w)))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;


(* load stop_addr *)

val zHEAP_LOAD_STOP_ADDR = let
  val th = spec "mov r13, [r9+136]"
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 136w) = s.local.stop_addr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals). (s.local.stop_addr = vals.reg13))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg13 := s.local.stop_addr |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in GSYM th end;

val zHEAP_JMP_STOP_ADDR = let
  val th = zHEAP_JMP_r13 |> Q.INST [`P`|->`\x.T`] |> SIMP_RULE std_ss []
  val th = SPEC_COMPOSE_RULE [zHEAP_LOAD_STOP_ADDR,th]
  val (th,goal) = SPEC_WEAKEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * zS * zPC s.local.stop_addr``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [SEP_IMP_def,SEP_EXISTS_THM,cond_STAR,zHEAP_def,SEP_CLAUSES]
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `vals`
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ METIS_TAC [])
  val th = MP th lemma
  in th end


(* call-lex-ptr-pop-and-store stop_addr *)

val zHEAP_CALL_LEX_WITH_STOP_ADDR = let
  val th1 = compose_specs ["mov r15,[r9+120]"]
  val th2 = compose_specs ["mov [r9+136],r15"]
  val th = SPEC_COMPOSE_RULE [th1,x64_call_r15,x64_pop_r15,th2]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,HD,TL] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 0x78w) = cs.lex_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
              s with local := (s.local with stop_addr := p+7w),NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := p + 7w;
         memory := (vals.reg9 + 0x88w =+ p + 0x7w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with stop_addr := p+7w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL,x64_store_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `f = vals.memory`
    \\ Q.ABBREV_TAC `df = vals.memory_domain`
    \\ SEP_WRITE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* call-install-ptr-pop-and-store stop_addr *)

val zHEAP_CALL_INSTALL_WITH_STOP_ADDR = let
  val th1 = compose_specs ["mov r15,[r9+128]"]
  val th2 = compose_specs ["mov [r9+136],r15"]
  val th = SPEC_COMPOSE_RULE [th1,x64_call_r15,x64_pop_r15,th2]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,HD,TL] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 128w) = cs.install_and_run_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
              s with local := (s.local with stop_addr := p + 10w),NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := p + 10w;
         memory := (vals.reg9 + 0x88w =+ p + 10w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with stop_addr := p + 10w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL,x64_store_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `f = vals.memory`
    \\ Q.ABBREV_TAC `df = vals.memory_domain`
    \\ SEP_WRITE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* set stop_addr using jump *)

val zHEAP_SET_STOP_ADDR = let
  val th2 = compose_specs ["mov [r9+136],r15"]
  val th = SPEC_COMPOSE_RULE [x64_call_imm,x64_pop_r15,th2]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> DISCH_ALL |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,HD,TL,NOT_CONS_NIL] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
              s with local := (s.local with stop_addr := p+6w),NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    fs []
    \\ SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := p + 6w;
         memory := (vals.reg9 + 0x88w =+ p + 0x6w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with stop_addr := p+6w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL,x64_store_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `f = vals.memory`
    \\ Q.ABBREV_TAC `df = vals.memory_domain`
    \\ SEP_WRITE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* set stop_addr using jump -- alternative version *)

val zHEAP_SET_STOP_ADDR_ALT = let
  val th0 = x64_call_imm |> Q.INST [`imm32`|->`0w`]
              |> SIMP_RULE std_ss [EVAL ``(sw2sw:word32->word64) 0w``,
                    word_arith_lemma1,EVAL ``IMM32 0w``]
  val th1 = compose_specs ["add r13,18","mov [r9+136],r13"]
  val ((jmp_imm,_,_),_) = prog_x64Lib.x64_spec "E9"
  val th = SPEC_COMPOSE_RULE [th0,x64_pop_r13,th1,jmp_imm]
              |> SIMP_RULE std_ss [NOT_CONS_NIL,HD,TL,
                   SEP_CLAUSES,word_arith_lemma1,ADD_ASSOC]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> DISCH_ALL |> SIMP_RULE (std_ss++sep_cond_ss)
             [SPEC_MOVE_COND,HD,TL,NOT_CONS_NIL] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
              s with local := (s.local with stop_addr := p + 0x18w),NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    fs [] \\ SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,heap_vars_ok_def]
      \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg13 := p + 0x18w;
         memory := (vals.reg9 + 0x88w =+ p + 0x18w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with stop_addr := p+0x18w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL,x64_store_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `f = vals.memory`
    \\ Q.ABBREV_TAC `df = vals.memory_domain`
    \\ SEP_WRITE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* set stop_addr to zero *)

val zHEAP_ZERO_STOP_ADDR = let
  val th = compose_specs ["mov r15,0","mov [r9+136], r15"]
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,HD,TL] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
              s with local := (s.local with stop_addr := 0w),NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := 0w;
         memory := (vals.reg9 + 0x88w =+ 0w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs with local := (s.local with stop_addr := 0w)`,
         `r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL,x64_store_def]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
    \\ SEP_R_TAC \\ FULL_SIMP_TAC (srw_ss()) [heap_vars_ok_def,SEP_CLAUSES]
    \\ Q.ABBREV_TAC `f = vals.memory`
    \\ Q.ABBREV_TAC `df = vals.memory_domain`
    \\ SEP_WRITE_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in th end;


(* load equal_ptr *)

val zHEAP_LOAD_EQUAL_PTR = let
  val th = spec "mov r15, [r9+64]"
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 64w) = cs.equal_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals). (cs.equal_ptr = vals.reg15))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := cs.equal_ptr |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma= prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in GSYM th end;


(* load print_ptr *)

val zHEAP_LOAD_PRINT_PTR = let
  val th = spec "mov r15, [r9+72]"
  val th = th |> Q.INST [`rip`|->`p`]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = DISCH ``vals.memory (vals.reg9 + 72w) = cs.print_ptr`` th
              |> SIMP_RULE std_ss []
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val inv = ``SOME (\(sp:num,vals). (cs.print_ptr = vals.reg15))``
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,^inv) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := cs.print_ptr |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in GSYM th end;


(* full EQUAL *)

val EVEN_w2n_IMP = prove(
  ``!w. EVEN (w2n w) ==> (0x2w * n2w (w2n w DIV 2) = (w:word64))``,
  SIMP_TAC std_ss [EVEN_w2n,n2w_w2n,
    GSYM (w2n_lsr |> Q.SPECL [`w`,`1`] |> SIMP_RULE std_ss [])]
  \\ blastLib.BBLAST_TAC);

val zHEAP_EQUAL = let
  val th1 = SPEC_COMPOSE_RULE [zHEAP_NOP,zHEAP_LOAD_EQUAL_PTR,zHEAP_CALL_R15]
  val th = SPEC_COMPOSE_RULE [zHEAP_RAW_EQUAL,zHEAP_RET]
  val th = SPEC_COMPOSE_RULE [th1,th]
  val th = abbreviate_code "equal" ``cs.equal_ptr`` th
  val lemma = prove(
    ``EVEN (w2n (w + 12w)) = EVEN (w2n (w:word64))``,
    SIMP_TAC std_ss [EVEN_w2n] \\ blastLib.BBLAST_TAC);
  val th = th |> RW [TL,HD,getCodePtr_def,NOT_CONS_NIL,isCodePtr_def,SEP_CLAUSES]
              |> SIMP_RULE (std_ss++sep_cond_ss) [EVEN_w2n_IMP,SPEC_MOVE_COND]
              |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND]
  val th = SPEC_COMPOSE_RULE [zHEAP_POP2,th] |> RW [lemma]
  in th end


(* full PRINT *)

val zHEAP_PRINT = let
  val th1 = SPEC_COMPOSE_RULE [zHEAP_NOP,zHEAP_LOAD_PRINT_PTR,zHEAP_CALL_R15]
  val th = SPEC_COMPOSE_RULE [zHEAP_RAW_PRINT,zHEAP_RET]
  val th = th |> SIMP_RULE std_ss [word_arith_lemma1]
  val th = SPEC_COMPOSE_RULE [th1,th]
  val th = abbreviate_code "print" ``cs.print_ptr`` th
  val th = SIMP_RULE std_ss [NOT_CONS_NIL,TL,HD] th
  val lemma = prove(
    ``EVEN (w2n (w + 10w)) = EVEN (w2n (w:word64))``,
    SIMP_TAC std_ss [EVEN_w2n] \\ blastLib.BBLAST_TAC);
  val th = th |> RW [TL,HD,getCodePtr_def,NOT_CONS_NIL,isCodePtr_def,SEP_CLAUSES]
              |> SIMP_RULE (std_ss++sep_cond_ss) [EVEN_w2n_IMP,SPEC_MOVE_COND]
              |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_MOVE_COND,lemma]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_POP1]
  in th end


(* jmp pointer *)

val zHEAP_JMP_PTR = let
  val th = spec "jmp r1"
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ isCodePtr x2)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS *
                         zPC (n2w (2 * getCodePtr x2))`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals` \\ FULL_SIMP_TAC std_ss []
    \\ `n2w (2 * getCodePtr x2) = vals.reg1` by ALL_TAC
    \\ FULL_SIMP_TAC (std_ss++star_ss) [zVALS_def]
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def]
    \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isCodePtr_def,getCodePtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,bc_stack_ref_inv_def,
          LIST_REL_def,bc_value_inv_def,x64_addr_def,w2w_def,WORD_MUL_LSL]
    \\ FULL_SIMP_TAC std_ss [word_mul_n2w]
    \\ FULL_SIMP_TAC (srw_ss()) [n2w_11]
    \\ FULL_SIMP_TAC (srw_ss()) [MOD_COMMON_FACTOR])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p * cond (isCodePtr x2)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES]
    \\ SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  val th1 = zHEAP_MOVE_12
  val th2 = zHEAP_POP1
  val th = SPEC_COMPOSE_RULE [th1,th2,th]
  in th end;


(* call pointer *)

val zHEAP_CALL_2 = let
  val th = x64_call_r1
  val th = SPEC_FRAME_RULE th ``~zS``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            EVEN (w2n (p + 3w)) /\ isCodePtr x2)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,
                           CodePtr ((w2n (p+3w:word64)) DIV 2)::stack,s,NONE) * ~zS *
                           zPC (n2w (2 * getCodePtr x2))`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with stack := (p+3w) :: vals.stack`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REVERSE STRIP_TAC THEN1
     (POP_ASSUM MP_TAC \\ SIMP_TAC std_ss [STAR_ASSOC] \\ ASM_SIMP_TAC std_ss []
      \\ Cases_on `x2` \\ FULL_SIMP_TAC std_ss [isCodePtr_def,getCodePtr_def]
      \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
      \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,x64_addr_def]
      \\ `(w2w:63 word -> word64) (n2w n) << 1 = n2w (2 * n)` by ALL_TAC THEN1
        (SIMP_TAC (srw_ss()) [w2w_def,WORD_MUL_LSL,word_mul_n2w,MOD_COMMON_FACTOR])
      \\ FULL_SIMP_TAC (std_ss++star_ss) [])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
         `(Data (n2w (w2n (p+3w) DIV 2)))::roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [CONS_11,MAP]
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,roots_ok_def,MEM]
      \\ STRIP_TAC THEN1 METIS_TAC []
      \\ FULL_SIMP_TAC (srw_ss()) [bc_stack_ref_inv_def,LIST_REL_def,
            reachable_refs_def,MEM]
      \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC (srw_ss()) [bc_value_inv_def,w2w_def]
      \\ FULL_SIMP_TAC std_ss [PULL_EXISTS,PULL_FORALL]
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
      \\ NTAC 2 (POP_ASSUM MP_TAC)
      \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM]
      \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [EVEN_w2n]
    \\ SIMP_TAC std_ss [x64_addr_def,GSYM w2w_def,
         w2n_lsr |> Q.SPECL [`w`,`1`] |> SIMP_RULE std_ss [] |> GSYM]
    \\ Q.PAT_ASSUM `~(p + 0x3w) ' 0` MP_TAC \\ blastLib.BBLAST_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p *
      cond (EVEN (w2n (p + 3w)) /\ isCodePtr x2)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_CALL_PTR =
  SPEC_COMPOSE_RULE [zHEAP_MOVE_12,zHEAP_POP1,zHEAP_CALL_2]


(* call instruction *)

val EVEN_LEMMA = prove(
  ``EVEN n ==> (2 * (n DIV 2) = n:num)``,
  SIMP_TAC std_ss [RW1 [MULT_COMM] EVEN_EXISTS]
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [MULT_DIV]
  \\ SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC]);

val zHEAP_CALL_IMM_1 = let
  val th = x64_call_imm_spec_1
  val th = th |> RW [GSYM IMM32_def] |> Q.INST [`rip`|->`p`]
  val th = MATCH_MP SPEC_1_FRAME th |> Q.SPEC `~zS` |> RW [SEP_CLAUSES]
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            EVEN (w2n (p+6w:word64)))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal,SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_1_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,
                           CodePtr ((w2n (p+6w:word64)) DIV 2)::stack,s,NONE) * ~zS *
                           zPC (p + 0x6w + sw2sw (imm32:word32))`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [zHEAP_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `vals with stack := (p+6w) :: vals.stack`
    \\ FULL_SIMP_TAC (srw_ss()) [zVALS_def]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,
         `Data (n2w ((w2n (p + 6w:word64) DIV 2))) :: roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [MAP,MAP_APPEND,x64_addr_def,CONS_11]
    \\ SIMP_TAC std_ss [WORD_MUL_LSL,w2w_def,n2w_w2n,word_mul_n2w,w2n_n2w]
    \\ `(w2n (p + 0x6w) DIV 2) < dimword (:63)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [DIV_LT_X] \\ EVAL_TAC
      \\ ASSUME_TAC (w2n_lt |> INST_TYPE [``:'a``|->``:64``])
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss [EVEN_LEMMA]
    \\ SIMP_TAC std_ss [n2w_w2n]
    \\ FULL_SIMP_TAC (srw_ss()) [abs_ml_inv_def,roots_ok_def,MEM]
    \\ STRIP_TAC THEN1 METIS_TAC []
    \\ FULL_SIMP_TAC std_ss [bc_stack_ref_inv_def]
    \\ Q.EXISTS_TAC `f` \\ FULL_SIMP_TAC std_ss [LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def]
    \\ REPEAT STRIP_TAC
    \\ FIRST_ASSUM MATCH_MP_TAC
    \\ FULL_SIMP_TAC std_ss [reachable_refs_def]
    \\ Q.EXISTS_TAC `x` \\ Q.EXISTS_TAC `r` \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [MEM]
    \\ NTAC 2 (POP_ASSUM MP_TAC)
    \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_1_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p *
      cond (EVEN (w2n (p + 6w)))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_CALL_IMM =
  MATCH_MP SPEC_1_IMP_SPEC zHEAP_CALL_IMM_1 |> RW [SEP_CLAUSES];


(* load pointer *)

val zHEAP_LOAD_PTR = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec_memory64 "4805"
  val th = HIDE_STATUS_RULE true sts th
  val th = th |> Q.INST [`rip`|->`p`]
  val th = RW [GSYM IMM32_def,sw2sw_lemma] th
  val th1 = x64_call_imm |> Q.INST [`imm32`|->`0w`]
      |> RW [EVAL ``(sw2sw:word32->word64) 0w``,EVAL ``IMM32 0w``,WORD_ADD_0]
  val th1 = SPEC_COMPOSE_RULE [th1,x64_pop_r0]
  val th1 = SIMP_RULE std_ss [NOT_CONS_NIL,TL,HD,SEP_CLAUSES] th1
  val th = SPEC_COMPOSE_RULE [th1,th]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            EVEN (w2n (p + 0x6w + sw2sw (imm32:word32))))``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,CodePtr (w2n ((p:word64) + 6w + sw2sw (imm32:word32)) DIV 2),x2,x3,
            x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg0 := p + 0x6w + sw2sw imm32`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC std_ss [abs_ml_inv_def,bc_stack_ref_inv_def,LIST_REL_def]
    \\ FULL_SIMP_TAC std_ss [bc_value_inv_def,PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`,`f`]
    \\ FULL_SIMP_TAC std_ss [APPEND,LIST_REL_def,x64_addr_def,roots_ok_def]
    \\ FULL_SIMP_TAC (srw_ss()) [MEM] \\ STRIP_TAC THEN1 METIS_TAC []
    \\ REPEAT STRIP_TAC THEN1
     (FIRST_ASSUM MATCH_MP_TAC
      \\ FULL_SIMP_TAC std_ss [reachable_refs_def]
      \\ Q.LIST_EXISTS_TAC [`x`,`r`] \\ FULL_SIMP_TAC std_ss []
      \\ NTAC 2 (POP_ASSUM MP_TAC)
      \\ FULL_SIMP_TAC std_ss [MEM]
      \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM])
    \\ SIMP_TAC std_ss [w2w_def,WORD_MUL_LSL,word_mul_n2w,w2n_n2w]
    \\ `(w2n (p + sw2sw (imm32:word32) + 0x6w) DIV 2) < dimword (:63)` by
     (SIMP_TAC std_ss [DIV_LT_X] \\ EVAL_TAC
      \\ ASSUME_TAC (w2n_lt |> INST_TYPE [``:'a``|->``:64``])
      \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss [EVEN_LEMMA,n2w_w2n])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (EVEN (w2n (p + 0x6w + sw2sw (imm32:word32))))``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
                                AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;


(* load small const *)

val zHEAP_LOAD_IMM1 = let
  val th1 = spec "xor r0,r0"
  val ((th2,_,_),_) = prog_x64Lib.x64_spec_memory64 "05"
  val th = SPEC_COMPOSE_RULE [th1,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE true sts th
  val th = th |> SIMP_RULE (srw_ss()) [w2w_n2w]
  val lemma = prove(
    ``4 * k < 2 ** 31 ==>
      ((n2w (BITS 31 0 (SIGN_EXTEND 32 64 (w2n ((n2w (4 * k)):word32))
       MOD 4294967296))) = n2w (4 * k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(4 * k) < 4294967296 /\ ~(2147483648 <= 4 * k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = RW [lemma] (th |> Q.INST [`imm32`|->`n2w (4 * k)`,`rip`|->`p`])
           |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  val pc = get_pc th
  val pre = ``4 * (k:num) < 2 ** 31``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,Number (& k),x2,x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg0 := n2w (4 * k)`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`Data (n2w (2 * k))`,
         `r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ `BITS 62 0 (2 * k) = 2 * k` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [bitTheory.BITS_THM]
      \\ FULL_SIMP_TAC std_ss [small_int_def,integerTheory.INT_LT]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [w2w_n2w,WORD_MUL_LSL,word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x1`,`r1`]
    \\ FULL_SIMP_TAC std_ss []
    \\ DECIDE_TAC)
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_LOAD_IMM2 = let
  val th1 = spec "xor r1,r1"
  val ((th2,_,_),_) = prog_x64Lib.x64_spec_memory64 "4881C1"
  val th = SPEC_COMPOSE_RULE [th1,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE true sts th
  val th = th |> SIMP_RULE (srw_ss()) [w2w_n2w]
  val lemma = prove(
    ``4 * k < 2 ** 31 ==>
      ((n2w ( (SIGN_EXTEND 32 64 (w2n ((n2w (4 * k)):word32))))) =
       n2w (4 * k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(4 * k) < 4294967296 /\ ~(2147483648 <= 4 * k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = RW [lemma] (th |> Q.INST [`imm32`|->`n2w (4 * k)`,`rip`|->`p`])
           |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  val pc = get_pc th
  val pre = ``4 * k:num < 2 ** 31``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,x1,Number (& k),x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ ASM_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg1 := n2w (4 * k)`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`Data (n2w (2 * k))`,
         `r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ `BITS 62 0 (2 * k) = 2 * k` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [bitTheory.BITS_THM]
      \\ FULL_SIMP_TAC std_ss [small_int_def,integerTheory.INT_LT]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [w2w_n2w,WORD_MUL_LSL,word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ MATCH_MP_TAC swap12_lemma
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x2`,`r2`]
    \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE STRIP_TAC THEN1 DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [small_int_def,integerTheory.INT_LT]
    \\ MATCH_MP_TAC swap12_lemma
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;

val zHEAP_LOAD_IMM2_ALT = let
  val th1 = spec "xor r1,r1"
  val ((th2,_,_),_) = prog_x64Lib.x64_spec_memory64 "81C1"
  val th = SPEC_COMPOSE_RULE [th1,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = HIDE_STATUS_RULE true sts th
  val th = th |> SIMP_RULE (srw_ss()) [w2w_n2w]
  val lemma = prove(
    ``4 * k < 2 ** 31 ==>
      ((n2w (BITS 31 0 (SIGN_EXTEND 32 64 (w2n ((n2w (4 * k)):word32))
       MOD 4294967296))) = n2w (4 * k):word64)``,
    FULL_SIMP_TAC (srw_ss()) [bitTheory.SIGN_EXTEND_def,
       LET_DEF,bitTheory.BIT_def,bitTheory.BITS_THM2]
    \\ REPEAT STRIP_TAC
    \\ `(4 * k) < 4294967296 /\ ~(2147483648 <= 4 * k)` by DECIDE_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [DIV_EQ_X]) |> UNDISCH
  val th = RW [lemma] (th |> Q.INST [`imm32`|->`n2w (4 * k)`,`rip`|->`p`])
           |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]
  val pc = get_pc th
  val pre = ``4 * k:num < 2 ** 31``
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\ ^pre)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC
    `zHEAP (cs,x1,Number (& k),x3,x4,refs,stack,s,NONE) * ~zS * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    FULL_SIMP_TAC std_ss [SEP_CLAUSES]
    \\ SIMP_TAC std_ss [Once heap_inv_def] \\ STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ ASM_SIMP_TAC std_ss []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with reg1 := n2w (4 * k)`
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ REVERSE STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()++star_ss) [zVALS_def])
    \\ FULL_SIMP_TAC (srw_ss()) [heap_inv_def]
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`Data (n2w (2 * k))`,
         `r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [x64_addr_def]
    \\ `BITS 62 0 (2 * k) = 2 * k` by ALL_TAC THEN1
     (FULL_SIMP_TAC std_ss [bitTheory.BITS_THM]
      \\ FULL_SIMP_TAC std_ss [small_int_def,integerTheory.INT_LT]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [w2w_n2w,WORD_MUL_LSL,word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [MULT_ASSOC]
    \\ MATCH_MP_TAC swap12_lemma
    \\ FULL_SIMP_TAC std_ss [GSYM word_mul_n2w]
    \\ MATCH_MP_TAC abs_ml_inv_Num
    \\ Q.LIST_EXISTS_TAC [`x2`,`r2`]
    \\ FULL_SIMP_TAC std_ss []
    \\ REVERSE STRIP_TAC THEN1 DECIDE_TAC
    \\ FULL_SIMP_TAC std_ss [small_int_def,integerTheory.INT_LT]
    \\ MATCH_MP_TAC swap12_lemma
    \\ FULL_SIMP_TAC std_ss [])
  val th = MP th lemma |> DISCH_ALL |> RW [AND_IMP_INTRO]
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p * cond ^pre``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
      AC CONJ_COMM CONJ_ASSOC])
  val th = MP th lemma
  in th end;


(* TagEq *)

val (bc_tag_eq_res,bc_tag_eq_def,bc_tag_eq_pre_def) = x64_compile `
  bc_tag_eq (x1,x2) =
    let x1 = Number (&getTag x1) in
      if getNumber x1 = getNumber x2 then
        let x1 = bool_to_val T in (x1,x2)
      else
        let x1 = bool_to_val F in (x1,x2)`

val tag_eq_thm = prove(
  ``(bc_tag_eq (x1,Number (& n)) = (bool_to_val (getTag x1 = n), Number (& n)))``,
  SIMP_TAC (srw_ss()) [bc_tag_eq_def,LET_DEF,getNumber_def] \\ SRW_TAC [] []);

val zHEAP_TagEq =
  SPEC_COMPOSE_RULE [zHEAP_LOAD_IMM2_ALT,bc_tag_eq_res]
  |> SIMP_RULE std_ss [LET_DEF,tag_eq_thm]


(* collection of bytecode code abbreviations *)

val code_abbrevs_def = Define `
  code_abbrevs cs =
    bignum_code cs.bignum_ptr UNION
    alloc_code cs.alloc_ptr UNION
    equal_code cs.equal_ptr UNION
    print_code cs.print_ptr UNION
    error_code cs.error_ptr`;


(* --- translation from bytecode to x64 --- *)

fun MERGE_CODE th = let
  val th = MATCH_MP prog_x64Theory.SPEC_X64_MERGE_CODE th
  val th = CONV_RULE (RATOR_CONV (SIMP_CONV std_ss [LENGTH,ADD1])) th
  val th = RW [APPEND] th
  val _ = not (is_imp (concl th)) orelse fail()
  in MERGE_CODE th end handle HOL_ERR _ => th;

val SPEC_PULL_EXISTS = prove(
  ``(?x. SPEC m p c (q x)) ==> SPEC m p c (SEP_EXISTS x. q x)``,
  REPEAT STRIP_TAC \\ REVERSE (`SEP_IMP (q x) ((SEP_EXISTS x. q x))` by ALL_TAC)
  THEN1 (IMP_RES_TAC SPEC_WEAKEN)
  \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ METIS_TAC []);

val SPEC_REMOVE_POST = prove(
  ``SPEC m p c q ==> SPEC m p c (q \/ q2)``,
  `SEP_IMP q (q \/ q2)` by FULL_SIMP_TAC std_ss [SEP_IMP_def,SEP_DISJ_def]
  \\ METIS_TAC [SPEC_WEAKEN]);

fun SPEC_EX q = HO_MATCH_MP_TAC SPEC_PULL_EXISTS \\ Q.EXISTS_TAC q

val SPEC_CODE_ABBREV = prove(
  ``SPEC m p (c INSERT d) q ==> !d2. d SUBSET d2 ==> SPEC m p (c INSERT d2) q``,
  REPEAT STRIP_TAC \\ REVERSE (`(c INSERT d2) = (c INSERT d) UNION d2` by ALL_TAC)
  THEN1 METIS_TAC [SPEC_ADD_CODE]
  \\ FULL_SIMP_TAC std_ss [EXTENSION,IN_INSERT,IN_UNION,SUBSET_DEF]
  \\ METIS_TAC []);

val CODE_POOL_LEMMA = prove(
  ``!c c' i. ?r. CODE_POOL i (c UNION c') = CODE_POOL i c * r``,
  REPEAT STRIP_TAC \\ REWRITE_TAC [CODE_POOL_def,IMAGE_UNION,BIGUNION_UNION,STAR_def]
  \\ Q.EXISTS_TAC `\s. s = BIGUNION (IMAGE i c') DIFF BIGUNION (IMAGE i c)`
  \\ ONCE_REWRITE_TAC [FUN_EQ_THM] \\ SIMP_TAC std_ss []
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC bool_ss [SPLIT_def,EXTENSION,IN_BIGUNION,IN_DIFF,
       IN_UNION,DISJOINT_DEF,IN_INTER,NOT_IN_EMPTY] \\ METIS_TAC []);

val SPEC_1_ADD_CODE = prove(
  ``!x p c q err. SPEC_1 x p c q err ==> !c'. SPEC_1 x p (c UNION c') q err``,
  REPEAT STRIP_TAC \\ PairCases_on `x`
  \\ fs [SPEC_1_def,TEMPORAL_def,LET_DEF,T_IMPLIES_def,
     NOW_def,T_OR_F_def,EVENTUALLY_def,SEP_CLAUSES,SEP_REFINE_def]
  \\ `?t. CODE_POOL x2 (c UNION c') = CODE_POOL x2 c * t` by
        METIS_TAC [CODE_POOL_LEMMA] \\ fs [GSYM STAR_ASSOC]
  \\ METIS_TAC []);

val SPEC_1_SUBSET_CODE = prove(
  ``!x p c q err.
      SPEC_1 x p c q err ==> !c'. c SUBSET c' ==> SPEC_1 x p c' q err``,
  REPEAT STRIP_TAC \\ REVERSE (`c' = c UNION c'` by ALL_TAC)
  THEN1 METIS_TAC [SPEC_1_ADD_CODE]
  \\ fs [EXTENSION,SUBSET_DEF,IN_UNION] \\ METIS_TAC []);

val SPEC_1_CODE_ABBREV = prove(
  ``SPEC_1 m p (c INSERT d) q err ==>
    !d2. d SUBSET d2 ==> SPEC_1 m p (c INSERT d2) q err``,
  REPEAT STRIP_TAC \\ REVERSE (`(c INSERT d2) = (c INSERT d) UNION d2` by ALL_TAC)
  THEN1 METIS_TAC [SPEC_1_ADD_CODE]
  \\ FULL_SIMP_TAC std_ss [EXTENSION,IN_INSERT,IN_UNION,SUBSET_DEF]
  \\ METIS_TAC []);

val SPEC_1_ERR_INTRO = prove(
  ``SPEC_1 m p c q SEP_F ==> !err. SPEC_1 m p c q err``,
  PairCases_on `m` \\ fs [SPEC_1_def,TEMPORAL_def,LET_DEF,T_IMPLIES_def,
     NOW_def,T_OR_F_def,EVENTUALLY_def,SEP_CLAUSES,SEP_REFINE_def]
  \\ fs [SEP_F_def] \\ METIS_TAC []);

val (_,_,sts,_) = prog_x64Lib.x64_tools

fun lisp_pc_s th = let
  val (_,_,_,q) = dest_spec (concl th)
  val c = MOVE_OUT_CONV ``zPC`` THENC MOVE_OUT_CONV ``zS``
  val d = if can dest_star q then I else (RATOR_CONV o RAND_CONV)
  val c = PRE_CONV c THENC POST_CONV (d c)
  in CONV_RULE c th end

val pattern = ``(p1,xs1) INSERT (p2:word64,xs2:word8 list) INSERT s``
fun sort_swap_conv tm = let
  val m = fst (match_term pattern tm)
  val p1 = subst m (mk_var("p1",``:word64``))
  val p2 = subst m (mk_var("p2",``:word64``))
  fun foo tm = if is_var tm then 0 else tm |> cdr |> cdr |> numSyntax.int_of_term
  val _ = foo p2 < foo p1 orelse fail()
  val (x1,s1) = pred_setSyntax.dest_insert tm
  val (x2,s2) = pred_setSyntax.dest_insert s1
  in ISPECL [x1,x2,s2] INSERT_COMM end

fun SORT_CODE th = CONV_RULE (REDEPTH_CONV sort_swap_conv) th

val INSERT_UNION_INSERT = store_thm("INSERT_UNION_INSERT",
  ``x INSERT (y UNION (z INSERT t)) = x INSERT z INSERT (y UNION t)``,
  SIMP_TAC std_ss [EXTENSION,IN_INSERT,IN_UNION] \\ METIS_TAC []);

val th = zHEAP_NEW_REF

fun fix_code th = let
  val (_,_,c,_) = dest_spec (concl th)
                  handle HOL_ERR _ => dest_spec_1 (concl th)
  val tms = find_terms (can (match_term ``(x:'a) INSERT y``)) (concl th)
              |> map rator
  val id_tm = ``I:(word64 # word8 list) set -> (word64 # word8 list) set``
  val rest_code = c |> subst (map (fn tm => tm |-> id_tm) tms)
                    |> REWRITE_CONV [I_THM,UNION_EMPTY] |> concl |> rand
  fun iset [] t = t
    | iset (x::xs) t = pred_setSyntax.mk_insert(x,iset xs t)
  val c = iset (map rand (rev tms)) rest_code
  val th = MATCH_MP SPEC_SUBSET_CODE th |> SPEC c
           handle HOL_ERR _ =>
           MATCH_MP SPEC_1_SUBSET_CODE th |> SPEC c
  val goal = concl th |> dest_imp |> fst
  val lemma = prove(goal,
    SIMP_TAC (srw_ss()) [SUBSET_DEF,IN_INSERT,AC DISJ_COMM DISJ_ASSOC])
  fun intro_abbrev th = MATCH_MP SPEC_CODE_ABBREV th
                        handle HOL_ERR _ =>
                        MATCH_MP SPEC_1_CODE_ABBREV th
  val th = MP th lemma
  val th = th
  |> SIMP_RULE std_ss [INSERT_UNION_INSERT,UNION_EMPTY]
  |> SORT_CODE
  |> SIMP_RULE std_ss [INSERT_UNION_EQ,UNION_EMPTY]
  |> SORT_CODE
  |> SIMP_RULE std_ss [INSERT_INSERT,AC UNION_ASSOC UNION_COMM,UNION_IDEMPOT]
  |> MERGE_CODE
  |> intro_abbrev |> Q.SPEC `code_abbrevs cs`
  |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV std_ss
       [SUBSET_DEF,NOT_IN_EMPTY,IN_UNION,code_abbrevs_def,DISJ_IMP])) |> RW []
  val (_,_,c,_) = dest_spec (concl th)
                  handle HOL_ERR _ => dest_spec_1 (concl th)
  val code_length = c  |> find_term (can (match_term ``(p:word64,(x:word8)::xs)``))
                       |> rand |> listSyntax.dest_list |> fst |> length
                    handle HOL_ERR _ => 0
  val _ = if (code_length mod 2 = 0) then () else print "\nWARNING: odd length\n"
  in th end;

fun get_code th = let
  val (_,_,c,_) = fix_code th |> UNDISCH_ALL |> concl |> dest_spec
  in c |> rator |> rand |> rand end

(* turn SPEC_1 into SPEC *)

val SPEC_1_PRE_EXISTS = prove(
  ``!x p c q err. (!y. SPEC_1 x (p y) c q err) <=>
                  SPEC_1 x (SEP_EXISTS y. p y) c q err``,
  fs [SPEC_1_def,FORALL_PROD,TEMPORAL_def,T_IMPLIES_def,NOW_def,LET_DEF]
  \\ fs [SEP_REFINE_def,PULL_EXISTS,T_OR_F_def,SEP_CLAUSES,SEP_EXISTS_THM]
  \\ METIS_TAC []);

val SPEC_1_WEAKEN = prove(
  ``!x p c q err.
       SPEC_1 x p c q err ==> !r. SEP_IMP q r ==> SPEC_1 x p c r err``,
  fs [SPEC_1_def,FORALL_PROD,TEMPORAL_def,T_IMPLIES_def,NOW_def,LET_DEF]
  \\ fs [SEP_REFINE_def,PULL_EXISTS,T_OR_F_def,SEP_CLAUSES,SEP_EXISTS_THM,
         NEXT_def,EVENTUALLY_def,NOW_def,PULL_EXISTS]
  \\ REPEAT STRIP_TAC \\ TRY (METIS_TAC [])
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`seq'`,`r'`])
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC \\ fs []
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (METIS_TAC [])
  \\ REPEAT STRIP_TAC \\ TRY (METIS_TAC [])
  \\ IMP_RES_TAC SEP_IMP_FRAME \\ fs [GSYM STAR_ASSOC]
  \\ fs [SEP_IMP_def] \\ METIS_TAC []);

val X64_SPEC_IMP_SPEC_1_ALT = prove(
  ``SPEC X64_MODEL (p * zPC pc1) code (q * zPC pc2) ==>
    pc1 <> pc2 ==>
    SPEC_1 X64_MODEL (p * zPC pc1) code (q * zPC pc2) (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC
  \\ MATCH_MP_TAC (MP_CANON X64_SPEC_IMP_SPEC_1) \\ fs []
  \\ IMP_RES_TAC SPEC_WEAKEN \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SEP_IMP_def,SEP_DISJ_def]);

fun spec_to_spec_1 th = let
  val th = CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``)) th
  val th = CONV_RULE (POST_CONV
             ((RATOR_CONV o RAND_CONV) (MOVE_OUT_CONV ``zPC``))) th
  val th = CONV_RULE (POST_CONV (MOVE_OUT_CONV ``zPC``)) th
  val th = MATCH_MP X64_SPEC_IMP_SPEC_1 th handle HOL_ERR _ =>
           MATCH_MP X64_SPEC_IMP_SPEC_1_ALT th
  val th = CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss())
             [WORD_EQ_ADD_CANCEL])) th
  val th = MP th TRUTH
  val c = PRE_CONV (MOVE_OUT_CONV ``zS`` THENC
                    SIMP_CONV (pure_ss++sep_cond_ss) []) THENC
          POST_CONV (MOVE_OUT_CONV ``zS``)
  val th = CONV_RULE (RATOR_CONV c) th
  in th end

(* --- a lemma for each bytecode instruction --- *)

val zBC_Pop = zHEAP_POP1 |> fix_code
val zBC_Pops = SPEC_COMPOSE_RULE [zHEAP_NOP,zHEAP_POPS] |> fix_code
val zBC_Load = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_LOAD] |> fix_code
val zBC_Store = SPEC_COMPOSE_RULE [zHEAP_STORE,zHEAP_POP1]
  |> RW [IMM32_def] |> fix_code

val zBC_Error = zHEAP_TERMINATE_WITH_ERROR |> fix_code

val zBC_Ref = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_NEW_REF] |> fix_code
val zBC_Deref = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_DEREF,zHEAP_NOP] |> fix_code
val zBC_Update = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_POP3,zHEAP_UPDATE_REF,zHEAP_POP1,zHEAP_NOP] |> fix_code

val zBC_Tick = zHEAP_NOP2 |> fix_code
val zBC_Equal = zHEAP_EQUAL |> fix_code
val zBC_Return = zHEAP_RET |> fix_code
val zBC_Return_1 = zHEAP_RET_1 |> fix_code
val zBC_PrintC = SPEC_COMPOSE_RULE [zHEAP_COND_PUT_CHAR,zHEAP_NOP] |> fix_code

val zBC_Jump_1 = let
  val th = x64_ret_raw_spec_1 |> RW [GSYM IMM32_def] |> Q.INST [`rip`|->`p`]
  val th = MATCH_MP SPEC_1_FRAME th
    |> Q.SPEC `zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS`
  val th = th |> SIMP_RULE std_ss [SEP_CLAUSES]
  val th = th |> RW [word_arith_lemma1]
  in th end |> fix_code

val zBC_Jump = MATCH_MP SPEC_1_IMP_SPEC zBC_Jump_1 |> RW [SEP_CLAUSES]

val zBC_JumpIf_1 = let
  val SPEC_IF = prove(
    ``SPEC m (p * precond b) c (q q1 * t) /\
      SPEC m (p * precond ~b) c (q q2 * t) ==>
      SPEC m p c (q (if b then q1 else q2) * t)``,
    Cases_on `b` \\ FULL_SIMP_TAC std_ss [precond_def,SEP_CLAUSES]);
  fun the (SOME x) = x | the _ = fail()
  val th1 = zHEAP_CMP_FALSE
  val th2 = zHEAP_POP1
  val ((th3,_,_),th3i) = prog_x64Lib.x64_spec_memory64 "0F85"
  val (th3i,_,_) = the th3i
  val th3 = MATCH_MP SPEC_IF (CONJ th3i th3)
  val th23 = SPEC_COMPOSE_RULE [th2,th3]
  val th23 = SPEC_FRAME_RULE th23 ``~zS1 Z_CF * ~zS1 Z_PF * ~zS1 Z_AF *
                                    ~zS1 Z_SF * ~zS1 Z_OF``
  val th23 = Q.INST [`p`|->`p+4w`] th23 |> SIMP_RULE std_ss [word_arith_lemma1]
  val (_,_,c,_) = dest_spec (concl th1)
  val th23 = MATCH_MP SPEC_ADD_CODE th23 |> Q.SPEC `^c`
             |> RW [INSERT_UNION_EQ,UNION_EMPTY]
  val (_,_,c,_) = dest_spec (concl th23)
  val th1 = MATCH_MP SPEC_SUBSET_CODE th1 |> SPEC c
            |> SIMP_RULE std_ss [SUBSET_DEF,IN_INSERT,NOT_IN_EMPTY]
  val f = UNDISCH_ALL o SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
  val th1 = th1 |> fix_code |> f
  val th23 = th23 |> fix_code |> f
  val lemma = X64_SPEC_IMP_SPEC_1 |> Q.INST [`err`|->`SEP_F`]
                 |> RW [SEP_CLAUSES]
  val g = RW [STAR_ASSOC] o SIMP_RULE (std_ss++star_ss) []
  val th1 = th1 |> g
  val th23 = th23 |> Q.INST [`z_zf`|->`x1 = bool_to_val F`] |> g
  val th1 = CONV_RULE (POST_CONV (MOVE_OUT_CONV ``zPC``)) th1
  val th1 = CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``)) th1
  val th23 = CONV_RULE (POST_CONV (MOVE_OUT_CONV ``zPC``)) th23
  val th23 = CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``)) th23
  val th1 = MATCH_MP lemma th1 |> RW [WORD_EQ_ADD_CANCEL]
             |> SIMP_RULE (srw_ss()) [n2w_11]
  val th1 = RW [SPEC_1_EQ_SPEC_N] th1 |> g
  val th23 = MATCH_MP SPEC_IMP_SPEC_N_ALT th23
  val th = MATCH_MP (MATCH_MP SPEC_N_COMPOSE th23
             |> RW [EVAL ``bool_to_val F``] |> g) (th1)
             |> RW [GSYM (EVAL ``bool_to_val F``)]
  val th = SIMP_RULE std_ss [ADD_ASSOC] th
  val (th,goal) = SPEC_WEAKEN_RULE (th |> RW [GSYM SPEC_1_EQ_SPEC_N])
    ``zHEAP (cs,HD stack,x2,x3,x4,refs,TL stack,s,NONE) *
      zPC (if x1 = bool_to_val F then p + 0xCw
           else p + n2w (12 + SIGN_EXTEND 32 64 (w2n (imm32:word32)))) * ~zS``
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val lemma = prove(goal,
    fs [sts] \\ fs [SEP_HIDE_def,SEP_CLAUSES,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`x'`,`x'''`,`x`,`(SOME (x1 = Block 10 []))`,`x''''`,`x''`]
    \\ fs [AC STAR_ASSOC STAR_COMM]
    \\ POP_ASSUM MP_TAC \\ fs [STAR_ASSOC])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_1_MOVE_COND]
  val th = RW [GSYM word_add_n2w] th
  in th end

val zHEAP_JumpIf =
  MATCH_MP SPEC_1_IMP_SPEC zBC_JumpIf_1 |> RW [SEP_CLAUSES]

val zHEAP_CALL_PTR_1 = let
  val th1 = zHEAP_MOVE_12
  val th2 = SPEC_COMPOSE_RULE [zHEAP_POP1,zHEAP_CALL_2] |> Q.INST [`p`|->`p+3w`]
  val (_,_,c,_) = dest_spec (concl th1)
  val th2 = MATCH_MP SPEC_ADD_CODE th2 |> Q.SPEC `^c`
             |> RW [INSERT_UNION_EQ,UNION_EMPTY]
             |> SIMP_RULE std_ss [word_arith_lemma1]
  val (_,_,c,_) = dest_spec (concl th2)
  val th1 = MATCH_MP SPEC_SUBSET_CODE th1 |> SPEC c
            |> SIMP_RULE std_ss [SUBSET_DEF,IN_INSERT,NOT_IN_EMPTY,word_arith_lemma1]
  val f = UNDISCH_ALL o SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
  val th1 = th1 |> fix_code |> f
  val th2 = th2 |> fix_code |> f
  val lemma = X64_SPEC_IMP_SPEC_1 |> Q.INST [`err`|->`SEP_F`]
                 |> RW [SEP_CLAUSES]
  val g = RW [STAR_ASSOC] o SIMP_RULE (std_ss++star_ss) []
  val th1 = th1 |> g
  val th2 = th2 |> Q.INST [`x2`|->`x1`] |> g
  val th1 = CONV_RULE (POST_CONV (MOVE_OUT_CONV ``zPC``)) th1
  val th1 = CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``)) th1
  val th2 = CONV_RULE (POST_CONV (MOVE_OUT_CONV ``zPC``)) th2
  val th2 = CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``)) th2
  val th1 = MATCH_MP lemma th1 |> RW [WORD_EQ_ADD_CANCEL]
             |> SIMP_RULE (srw_ss()) [n2w_11]
  val th1 = RW [SPEC_1_EQ_SPEC_N] th1 |> g
  val th2 = MATCH_MP SPEC_IMP_SPEC_N_ALT th2
  val th = MATCH_MP (MATCH_MP SPEC_N_COMPOSE th2 |> g) (th1)
  val th = SIMP_RULE std_ss [ADD_ASSOC] th
  val th = RW [GSYM SPEC_1_EQ_SPEC_N] th
  val th = th |> DISCH_ALL |> RW [AND_IMP_INTRO] |> RW [GSYM SPEC_1_MOVE_COND]
  val th = RW [GSYM word_add_n2w] th
  in th end

val zBC_JumpIf = MATCH_MP SPEC_1_IMP_SPEC zBC_JumpIf_1 |> RW [SEP_CLAUSES]
val zBC_JumpPtr = zHEAP_JMP_PTR |> fix_code
val zBC_CallPtr = zHEAP_CALL_PTR |> fix_code
val zBC_CallPtr_1 = zHEAP_CALL_PTR_1 |> fix_code
val zBC_Call = zHEAP_CALL_IMM |> fix_code
val zBC_Call_1 = zHEAP_CALL_IMM_1 |> fix_code
val zBC_PushPtr = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_LOAD_PTR] |> fix_code
val zBC_PushExc = zBC_PushExc_raw |> fix_code
val zBC_PopExc = zBC_PopExc_raw |> fix_code
val zBC_Print = zHEAP_PRINT |> fix_code
val zBC_IsBlock = zHEAP_isBlock_Intr |> fix_code
val zBC_TagEq = zHEAP_TagEq |> fix_code
val zBC_El = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_EL,zHEAP_NOP] |> fix_code
val zBC_PushInt = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_LOAD_IMM1] |> fix_code
val zBC_LengthBlock = zHEAP_GET_LENGTH |> fix_code
val zBC_LengthByte = zHEAP_GET_LENGTH_BYTE |> fix_code
val zBC_Length = zHEAP_GET_LENGTH_ARRAY |> fix_code

val zBC_Cons = SPEC_COMPOSE_RULE [zHEAP_BIG_CONS_VAR,zHEAP_NOP]
  |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND,GSYM CONJ_ASSOC] |> fix_code

val zBC_Add = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_ADD_SMALL_INT] |> fix_code
val zBC_Sub = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_SWAP_12,zHEAP_SUB_SMALL_INT,zHEAP_NOP] |> fix_code
val zBC_Mul = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_MUL_SMALL_INT] |> fix_code
val zBC_Div = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_SWAP_12,zHEAP_DIV_SMALL_INT,zHEAP_NOP] |> fix_code
val zBC_Mod = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_SWAP_12,zHEAP_MOD_SMALL_INT,zHEAP_NOP] |> fix_code
val zBC_Less = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_SMALL_INT] |> fix_code

val zBC_Galloc = zBC_Tick

val zBC_Gread = let
  val Num0 =
    zHEAP_LOAD_IMM1 |> Q.INST [`k`|->`0`] |> SIMP_RULE std_ss [SEP_CLAUSES]
      |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_MOVE_42,
          Num0,zHEAP_EL,zHEAP_MOVE_12,zHEAP_LOAD_IMM1,zHEAP_DEREF]
    |> SIMP_RULE (srw_ss()) [getNumber_def,isNumber_def]
  in th end |> fix_code

val zBC_Gupdate = let
  val Num0 =
    zHEAP_LOAD_IMM1 |> Q.INST [`k`|->`0`] |> SIMP_RULE std_ss [SEP_CLAUSES]
      |> CONV_RULE ((RATOR_CONV o RAND_CONV) EVAL)
  val th = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_MOVE_42,
          Num0,zHEAP_EL,zHEAP_MOVE_13,zHEAP_LOAD_IMM2,zHEAP_POP1,
          zHEAP_UPDATE_REF,zHEAP_POP1]
    |> SIMP_RULE (srw_ss()) [getNumber_def,isNumber_def,SEP_CLAUSES]
  in th end |> fix_code

val zBC_Shift0 = SPEC_COMPOSE_RULE [zHEAP_POPS,zHEAP_POP1,zHEAP_NOP]
   |> RW [IMM32_def] |> fix_code
val zBC_Shift1 = SPEC_COMPOSE_RULE [zHEAP_NOP,zHEAP_POPS] |> fix_code
val zBC_Shift2 = SPEC_COMPOSE_RULE [zHEAP_NOP,zHEAP_SIMPLE_Shift] |> fix_code
val zBC_Shift3 = zHEAP_GENERAL_Shift |> fix_code

val zBC_Stop_T = SPEC_COMPOSE_RULE
   [zHEAP_PUSH1,zHEAP_NOP,
    zHEAP_Nil1 |> Q.INST [`k`|->`9`] |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]
        |> RW [GSYM (EVAL ``bool_to_val T``)],
    zHEAP_JMP_STOP_ADDR] |> fix_code

val zBC_Stop_F = SPEC_COMPOSE_RULE
   [zHEAP_PUSH1,zHEAP_NOP,
    zHEAP_Nil1 |> Q.INST [`k`|->`10`] |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]
        |> RW [GSYM (EVAL ``bool_to_val F``)],
    zHEAP_JMP_STOP_ADDR] |> fix_code

val (zBC_EndOfCode, end_of_code_def) = let
  val th = SPEC_COMPOSE_RULE
   [zHEAP_PUSH1,
    zHEAP_Nil1 |> Q.INST [`k`|->`0`] |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]
        |> RW [GSYM (EVAL ``bool_to_val F``)],
    zHEAP_NOP,
    zHEAP_JMP_STOP_ADDR] |> fix_code
  val code = th |> concl |> rator |> rand |> rator |> rand |> rand
  val end_of_code_def = Define `end_of_code = ^code`;
  val th = RW [GSYM end_of_code_def] th
  in (th, end_of_code_def) end

val zBC_LoadRev = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_LoadRev,zHEAP_NOP]
   |> RW [IMM32_def] |> fix_code

val zBC_END_OF_CODE = SPEC_COMPOSE_RULE
   [zHEAP_PUSH1,
    zHEAP_LOAD_IMM1 |> Q.INST [`k`|->`0`] |> SIMP_RULE (srw_ss()) [SEP_CLAUSES],
    zHEAP_JMP_STOP_ADDR] |> fix_code

val zBC_Error6 = let
  val th = MATCH_MP SPEC_SUBSET_CODE zHEAP_TERMINATE_WITH_ERROR
           |> Q.SPEC `(p,[0x49w; 0xFFw; 0x61w; 0x28w]) INSERT
                      (p+4w,[0xFFw; 0xC0w]) INSERT error_code cs.error_ptr`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,SIMP_TAC (srw_ss()) [SUBSET_DEF] \\ METIS_TAC [])
  val th6 = MP th lemma
  in th6 |> fix_code end

val zBC_Error12 = let
  val th = MATCH_MP SPEC_SUBSET_CODE zHEAP_TERMINATE_WITH_ERROR
           |> Q.SPEC `(p,[0x49w; 0xFFw; 0x61w; 0x28w]) INSERT
                      (p+4w,[0xFFw; 0xC0w]) INSERT
                      (p+6w,[0xFFw; 0xC0w]) INSERT
                      (p+8w,[0xFFw; 0xC0w]) INSERT
                      (p+10w,[0xFFw; 0xC0w]) INSERT error_code cs.error_ptr`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,SIMP_TAC (srw_ss()) [SUBSET_DEF] \\ METIS_TAC [])
  val th6 = MP th lemma
  in th6 |> fix_code end

val zBC_Error16 = let
  val th = MATCH_MP SPEC_SUBSET_CODE zHEAP_TERMINATE_WITH_ERROR
           |> Q.SPEC `(p,[0x49w; 0xFFw; 0x61w; 0x28w]) INSERT
                      (p+4w,[0xFFw; 0xC0w]) INSERT
                      (p+6w,[0xFFw; 0xC0w]) INSERT
                      (p+8w,[0xFFw; 0xC0w]) INSERT
                      (p+10w,[0xFFw; 0xC0w]) INSERT
                      (p+12w,[0xFFw; 0xC0w]) INSERT
                      (p+14w,[0xFFw; 0xC0w]) INSERT error_code cs.error_ptr`
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,SIMP_TAC (srw_ss()) [SUBSET_DEF] \\ METIS_TAC [])
  val th6 = MP th lemma
  in th6 |> fix_code end


(* translation function *)

val small_offset_def = Define `
  small_offset n x =
    if n < 268435456:num then x else ^(get_code zBC_Error)`;

val small_offset6_def = Define `
  small_offset6 n x =
    if n < 268435456:num then x else ^(get_code zBC_Error6)`;

val small_offset12_def = Define `
  small_offset12 n x =
    if n < 268435456:num then x else ^(get_code zBC_Error12)`;

val small_offset16_def = Define `
  small_offset16 n x =
    if n < 268435456:num then x else ^(get_code zBC_Error16)`;

val x64_def = Define `
  (x64 i (Stack Pop) = ^(get_code zBC_Pop)) /\
  (x64 i (Stack (Pops k)) = small_offset k ^(get_code zBC_Pops)) /\
  (x64 i (Stack (Load k)) = small_offset k ^(get_code zBC_Load)) /\
  (x64 i (Stack (Store k)) = small_offset k ^(get_code zBC_Store)) /\
  (x64 i (Stack Add) = ^(get_code zBC_Add)) /\
  (x64 i (Stack Sub) = ^(get_code zBC_Sub)) /\
  (x64 i (Stack Mult) = ^(get_code zBC_Mul)) /\
  (x64 i (Stack Div) = ^(get_code zBC_Div)) /\
  (x64 i (Stack Mod) = ^(get_code zBC_Mod)) /\
  (x64 i (Stack Less) = ^(get_code zBC_Less)) /\
  (x64 i (Stack Equal) = ^(get_code zBC_Equal)) /\
  (x64 i (Stack IsBlock) = ^(get_code zBC_IsBlock)) /\
  (x64 i (Stack (TagEq k)) = small_offset k (^(get_code zBC_TagEq))) /\
  (x64 i (Stack El) = ^(get_code zBC_El)) /\
  (x64 i (Stack LengthBlock) = ^(get_code zBC_LengthBlock)) /\
  (x64 i (Stack (Cons tag)) =
     if tag < 4096 then
       let n = tag in ^(get_code zBC_Cons)
     else ^(get_code zBC_Error)) /\
  (x64 i (Stack (PushInt j)) =
     small_offset (Num (ABS j))
       (if j < 0 then ^(get_code zBC_Error) else
          let k = Num j in ^(get_code zBC_PushInt))) /\
  (x64 i LengthByte = ^(get_code zBC_LengthByte)) /\
  (x64 i Length = ^(get_code zBC_Length)) /\
  (x64 i (Jump (Addr l)) =
     small_offset6 l (small_offset6 i
       (let imm32 = n2w (2 * l) - n2w i - 6w in ^(get_code zBC_Jump)))) /\
  (x64 i (JumpIf (Addr l)) =
     small_offset12 l (small_offset12 i
       (let imm32 = n2w (2 * l) - n2w i - 12w in ^(get_code zBC_JumpIf)))) /\
  (x64 i (Call (Addr l)) =
     small_offset6 l (small_offset6 i
       (let imm32 = n2w (2 * l) - n2w i - 6w in ^(get_code zBC_Call)))) /\
  (x64 i (PushPtr (Addr l)) =
     small_offset16 l (small_offset16 i
       (let imm32 = n2w (2 * l) - n2w i - 8w in ^(get_code zBC_PushPtr)))) /\
  (x64 i (Jump (Lab _)) = ^(get_code zBC_Error6)) /\
  (x64 i (JumpIf (Lab _)) = ^(get_code zBC_Error12)) /\
  (x64 i (Call (Lab _)) = ^(get_code zBC_Error6)) /\
  (x64 i (PushPtr (Lab _)) = ^(get_code zBC_Error16)) /\
  (x64 i (CallPtr) = ^(get_code zBC_CallPtr)) /\
  (x64 i (Return) = ^(get_code zBC_Return)) /\
  (x64 i (Deref) = ^(get_code zBC_Deref)) /\
  (x64 i (Ref) = ^(get_code zBC_Ref)) /\
  (x64 i (Update) = ^(get_code zBC_Update)) /\
  (x64 i (Galloc k) = ^(get_code zBC_Galloc)) /\
  (x64 i (Gread k) =
     if k < globals_count
     then ^(get_code zBC_Gread)
     else ^(get_code zBC_Error)) /\
  (x64 i (Gupdate k) =
     if k < globals_count
     then ^(get_code zBC_Gupdate)
     else ^(get_code zBC_Error)) /\
  (x64 i (PopExc) = ^(get_code zBC_PopExc)) /\
  (x64 i (PushExc) = ^(get_code zBC_PushExc)) /\
  (x64 i (Label l) = []) /\
  (x64 i (Tick) = ^(get_code zBC_Tick)) /\
  (x64 i (Print) = ^(get_code zBC_Print)) /\
  (x64 i (PrintC c) =
     (let c = n2w (ORD c):word8 in ^(get_code zBC_PrintC))) /\
  (x64 i (Stop T) = ^(get_code zBC_Stop_T)) /\
  (x64 i (Stop F) = ^(get_code zBC_Stop_F)) /\
  (x64 i _ = ^(get_code zBC_Error))`;

val x64_length_def = Define `
  x64_length bc = LENGTH (x64 0 bc)`;

val x64_inst_length_def = Define `
  x64_inst_length bc = (x64_length bc DIV 2) - 1`;

val LENGTH_IF = prove(
  ``(LENGTH (if b then xs else ys) = if b then LENGTH xs else LENGTH ys) /\
    ((if b then m else n) DIV 2 - 1 = if b then m DIV 2 - 1 else n DIV 2 - 1)``,
  SRW_TAC [] []);

val PushInt_SIMP = prove(
  ``(if Num (ABS v28) < 268435456 then if v28 < 0 then 1 else 4 else 1) =
    if v28 < 268435456 then if v28 < 0 then 1 else 4 else 1:num``,
  intLib.COOPER_TAC);

val lemma = prove(
  ``((if b then x else y) DIV 2 = (if b then x DIV 2 else y DIV 2)) /\
    ((if b then x else y) - 1 = (if b then x - 1 else y - 1))``,
  SRW_TAC [] []);

val x64_inst_length_thm = prove(
  ``!bc. x64_inst_length bc = case bc of (Label l) => 0
                              | Stack Add => x64_inst_length (Stack Add)
                              | Jump (Lab l) => x64_inst_length (Jump (Lab l))
                              | JumpIf (Lab l) => x64_inst_length (JumpIf (Lab l))
                              | Call (Lab l) => x64_inst_length (Call (Lab l))
                              | PushPtr (Lab l) => x64_inst_length (PushPtr (Lab l))
                              | Stop F => x64_inst_length (Stop F)
                              | Stop T => x64_inst_length (Stop T)
                              | i => x64_inst_length i``,
  Cases \\ EVAL_TAC \\ TRY (Cases_on `b`) \\ EVAL_TAC
  \\ TRY (Cases_on `l`) \\ EVAL_TAC)
  |> SPEC_ALL |> CONV_RULE (RAND_CONV (REWRITE_CONV [x64_inst_length_def,
       x64_length_def,x64_def,LENGTH]))
  |> SIMP_RULE std_ss [LET_DEF,LENGTH,small_offset_def,LENGTH_IF,lemma,
       small_offset16_def,small_offset12_def,small_offset6_def,PushInt_SIMP,
       IMM32_def,LENGTH_NTIMES,LENGTH_APPEND,ADD1,GSYM ADD_ASSOC,globals_count_def];

val real_inst_length_thm = store_thm("real_inst_length_thm",
  ``x64_inst_length = real_inst_length``,
  fs [x64_inst_length_thm,real_inst_length_def,FUN_EQ_THM]
  \\ Cases \\ SRW_TAC [] [] \\ TRY (Cases_on `b`) \\ fs []
  \\ TRY (Cases_on `l`) \\ fs []);

val EVEN_LENGTH_small_offset = prove(
  ``EVEN (LENGTH x) ==> EVEN (LENGTH (small_offset n x))``,
  SRW_TAC [] [small_offset_def]);

val EVEN_LENGTH_small_offset6 = prove(
  ``EVEN (LENGTH x) ==> EVEN (LENGTH (small_offset6 n x))``,
  SRW_TAC [] [small_offset6_def]);

val EVEN_LENGTH_small_offset12 = prove(
  ``EVEN (LENGTH x) ==> EVEN (LENGTH (small_offset12 n x))``,
  SRW_TAC [] [small_offset12_def]);

val EVEN_LENGTH_small_offset16 = prove(
  ``EVEN (LENGTH x) ==> EVEN (LENGTH (small_offset16 n x))``,
  SRW_TAC [] [small_offset16_def]);

val x64_length_EVEN = prove(
  ``!bc. EVEN (x64_length bc)``,
  Cases \\ TRY (Cases_on `b:bc_stack_op`) \\ TRY (Cases_on `l:loc`)
  \\ TRY (Cases_on `b:bool`)
  \\ SIMP_TAC std_ss [x64_length_def,x64_def,LENGTH,EVEN,LET_DEF]
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset6)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset6)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset12)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset12)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset16)
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset16)
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss [LENGTH,EVEN,IMM32_def]
  \\ TRY (MATCH_MP_TAC EVEN_LENGTH_small_offset)
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss [LENGTH,EVEN,IMM32_def]
  \\ FULL_SIMP_TAC std_ss [LENGTH_NTIMES,LENGTH]
  \\ FULL_SIMP_TAC std_ss [EVEN_ADD,EVEN_MULT]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss [LENGTH,EVEN,IMM32_def]
  \\ FULL_SIMP_TAC std_ss [EVEN_ADD,EVEN_MULT]);

val x64_length_LESS = prove(
  ``!bc. ~is_Label bc ==> 1 < x64_length bc``,
  Cases \\ TRY (Cases_on `b:bc_stack_op`) \\ TRY (Cases_on `l:loc`)
  \\ TRY (Cases_on `b:bool`)
  \\ SIMP_TAC std_ss [x64_length_def,x64_def,LENGTH,EVEN,LET_DEF]
  \\ EVAL_TAC \\ SRW_TAC [] [is_Label_def]);

val x64_length_NOT_ZERO = prove(
  ``!bc. ~is_Label bc ==> x64_length bc <> 0``,
  REPEAT STRIP_TAC \\ IMP_RES_TAC x64_length_LESS \\ DECIDE_TAC);

val LENGTH_x64_IGNORE = prove(
  ``!i n. LENGTH (x64 n i) = LENGTH (x64 0 i)``,
  Cases \\ TRY (Cases_on `b`)  \\ TRY (Cases_on `l`)
  \\ EVAL_TAC \\ SIMP_TAC std_ss [] \\ SRW_TAC [] []
  \\ FULL_SIMP_TAC std_ss [] \\ EVAL_TAC);

val LENGTH_x64_DIV2_TIMES2 = prove(
  ``!k. ~is_Label bc ==>
        (2 * (LENGTH (x64 k bc) DIV 2) - 2 + 2 = LENGTH (x64 k bc))``,
  fs [LENGTH_x64_IGNORE,GSYM x64_length_def]
  \\ REPEAT STRIP_TAC \\ IMP_RES_TAC x64_length_LESS
  \\ STRIP_ASSUME_TAC (MATCH_MP (Q.SPEC `2` DIVISION) (DECIDE ``0<2:num``)
                 |> Q.SPEC `x64_length bc` |> GSYM)
  \\ `x64_length bc MOD 2 = 0` by METIS_TAC [EVEN_MOD2,x64_length_EVEN]
  \\ fs [AC MULT_COMM MULT_ASSOC] \\ DECIDE_TAC);

val x64_code_def = zDefine `
  (x64_code i [] = []) /\
  (x64_code i (b::bs) = x64 i b ++ x64_code (i + x64_length b) bs)`;

local val fs = fsrw_tac[] in
val x64_code_EQ_x64 = prove(
  ``!bc_code p n.
      (bc_fetch_aux bc_code x64_inst_length (p - n) = SOME i) /\ n <= p ==>
      ?ys1 ys2.
        (x64_code (2 * n) bc_code = ys1 ++ x64 (2 * p) i ++ ys2) /\
        (2 * (p - n) = LENGTH ys1)``,
  Induct \\ fs [bc_fetch_aux_def]
  \\ REPEAT STRIP_TAC \\ Cases_on `is_Label h` \\ fs []
  THEN1 (Cases_on `h` \\ fs [is_Label_def,x64_def,x64_code_def,
           EVAL ``x64_length (Label n')``])
  \\ Cases_on `p <= n` \\ fs [] THEN1
   (`p = n` by DECIDE_TAC \\ fs []
    \\ SRW_TAC [] [] \\ Q.EXISTS_TAC `[]` \\ fs [x64_code_def])
  \\ fs [GSYM SUB_PLUS] \\ RES_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ POP_ASSUM MP_TAC
  \\ MATCH_MP_TAC IMP_IMP
  \\ STRIP_TAC THEN1 DECIDE_TAC
  \\ REPEAT STRIP_TAC \\ fs [NOT_LESS]
  \\ Q.PAT_ASSUM `~is_Label h` ASSUME_TAC
  \\ fs [x64_code_def,x64_length_def,x64_inst_length_def,LEFT_ADD_DISTRIB,
         LENGTH_x64_DIV2_TIMES2,LEFT_SUB_DISTRIB]
  \\ Q.LIST_EXISTS_TAC [`x64 (2 * n) h ++ ys1`,`ys2`]
  \\ fs [] \\ POP_ASSUM MP_TAC
  \\ fs [LENGTH_x64_IGNORE]
  \\ POP_ASSUM (fn th => fs [GSYM th])
  \\ IMP_RES_TAC (DECIDE ``n <= p ==> 2 * n <= 2 * p:num``)
  \\ FULL_SIMP_TAC bool_ss [LEFT_ADD_DISTRIB,LEFT_SUB_DISTRIB]
  \\ REPEAT STRIP_TAC \\ fs [LENGTH_x64_DIV2_TIMES2]
  \\ DECIDE_TAC)
  |> Q.SPECL [`bc_code`,`p`,`0`] |> SIMP_RULE std_ss [];
end

val x64_code_APPEND = prove(
  ``!xs1 xs2 p.
      x64_code p (xs1 ++ xs2) =
      x64_code p xs1 ++
      x64_code (p + SUM (MAP x64_length xs1)) xs2``,
  Induct \\ SIMP_TAC std_ss [APPEND,x64_code_def,MAP,SUM,WORD_ADD_0]
  \\ ASM_SIMP_TAC std_ss [APPEND_ASSOC,LEFT_ADD_DISTRIB,ADD_ASSOC]);

val LENGTH_x64_code = prove(
  ``!xs p. LENGTH (x64_code p xs) = SUM (MAP x64_length xs)``,
  Induct \\ ASM_SIMP_TAC std_ss [x64_code_def,SUM,MAP,LENGTH,
       LENGTH_APPEND,x64_length_def,LENGTH_x64_IGNORE]);

val x64_code_ALT = store_thm("x64_code_ALT",
  ``!b. x64_code i (b::bs) =
          let c = x64 i b in c ++ x64_code (i + LENGTH c) bs``,
  SIMP_TAC std_ss [x64_code_def,LET_DEF,x64_length_def,LENGTH_x64_IGNORE]);

val LENGTH_small_offset = prove(
  ``LENGTH (small_offset n xs) =
      if n < 268435456 then LENGTH xs else 4``,
  SRW_TAC [] [small_offset_def]);

val LENGTH_IF = store_thm("LENGTH_IF",
  ``LENGTH (if b then xs else ys) = if b then LENGTH xs else LENGTH ys``,
  SRW_TAC [] []);

val APPEND_IF = store_thm("APPEND_IF",
  ``(if b then xs else ys) ++ zs = if b then xs ++ zs else ys ++ zs:'a list``,
  SRW_TAC [] []);

val IF_AND = store_thm("IF_AND",
  ``(if (b1 /\ b2) then c else d) =
    if b1 then (if b2 then c else d) else d``,
  SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []);

val x64_code_eval = save_thm("x64_code_eval",
  ([],``!b. x64_code i (b::bs) =
          let c = x64 i b in c ++ x64_code (i + LENGTH c) bs``)
  |> (Cases \\ TRY (Cases_on `b'`) \\ TRY (Cases_on `l`)) |> fst
  |> map (SIMP_RULE std_ss [LET_DEF] o REWRITE_CONV [x64_code_ALT] o snd)
  |> (fn thms => LIST_CONJ (CONJUNCT1 x64_code_def::thms))
  |> SIMP_RULE std_ss [x64_def,LET_DEF,APPEND,LENGTH,small_offset_def,
       small_offset6_def,small_offset12_def,small_offset16_def,IMM32_def,LENGTH_IF]
  |> REWRITE_RULE [APPEND_IF,APPEND,IF_AND]
  |> SIMP_RULE std_ss []
  |> REWRITE_RULE [GSYM IF_AND])

val length_ok_x64_inst_length = prove(
  ``length_ok x64_inst_length``,
  SIMP_TAC std_ss [bytecodeLabelsTheory.length_ok_def]
  \\ Cases \\ Cases_on `ARB:loc`
  \\ SIMP_TAC (srw_ss()) [x64_inst_length_thm]);


(* install code *)

val append_imm_code_def = Define `
  (append_imm_code [] = []) /\
  (append_imm_code (imm8::imms) =
      0x4Dw::0x8Bw::0x79w::0x50w::
      0x41w::0xC6w::0x7w::imm8::
      0x49w::0xFFw::0xC7w::
      0x4Dw::0x89w::0x79w::0x50w::
      append_imm_code imms)`;

val SET_LEMMA = prove(
  ``{x1;x2} = {x1} UNION {x2}``,
  fs [EXTENSION]);

val zHEAP_CODE_SNOC_IMM_compacted =
  zHEAP_CODE_SNOC_IMM
  |> MATCH_MP SPEC_X64_MERGE_CODE |> SIMP_RULE std_ss [LENGTH,LENGTH_APPEND]
  |> MATCH_MP SPEC_X64_MERGE_CODE |> SIMP_RULE std_ss [LENGTH,LENGTH_APPEND]
  |> MATCH_MP SPEC_X64_MERGE_CODE |> SIMP_RULE std_ss [LENGTH,LENGTH_APPEND]
  |> RW [APPEND]

val append_imm_code = prove(
  ``!imms p s.
      LENGTH s.code + LENGTH imms <= s.code_max_length /\
      (s.code_mode = SOME F) ==>
      SPEC X64_MODEL
       (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * ~zS * zPC p)
       {(p,append_imm_code imms)}
       (zHEAP
        (cs,x1,x2,x3,x4,refs,stack,s with code := s.code ++ imms,
         NONE) * ~zS * zPC (p + n2w (15 * LENGTH imms)))``,
  Induct \\ SIMP_TAC std_ss [LENGTH,APPEND,WORD_ADD_0,APPEND_NIL]
  THEN1 (REPEAT STRIP_TAC \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``)
    \\ FULL_SIMP_TAC std_ss [SPEC_REFL])
  \\ REPEAT STRIP_TAC
  \\ SIMP_TAC std_ss [append_imm_code_def]
  \\ REWRITE_TAC
      [EVAL ``0x4Dw::0x8Bw::0x79w::0x50w::0x41w::0xC6w::0x7w::h::0x49w::0xFFw::
        0xC7w::0x4Dw::0x89w::0x79w::0x50w::[] ++ append_imm_code imms`` |> GSYM]
  \\ MATCH_MP_TAC (MP_CANON SPEC_X64_MERGE_CODE |> GEN_ALL)
  \\ fs [SET_LEMMA]
  \\ MATCH_MP_TAC progTheory.SPEC_COMPOSE
  \\ Q.EXISTS_TAC `zHEAP (cs,x1,x2,x3,x4,refs,stack,
       s with code := SNOC h s.code,NONE) * ~zS * zPC (p + 15w)`
  \\ REPEAT STRIP_TAC THEN1
   (MATCH_MP_TAC (RW [SPEC_MOVE_COND] zHEAP_CODE_SNOC_IMM_compacted)
    \\ FULL_SIMP_TAC std_ss [] \\ DECIDE_TAC)
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`p + 15w`,`s with code := SNOC h s.code`])
  \\ SIMP_TAC (srw_ss()) [] \\ MATCH_MP_TAC IMP_IMP
  \\ STRIP_TAC THEN1 (FULL_SIMP_TAC std_ss [] \\ DECIDE_TAC)
  \\ FULL_SIMP_TAC std_ss [MULT_CLAUSES,GSYM word_add_n2w,SNOC_APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,
       AC WORD_ADD_COMM WORD_ADD_ASSOC])
  |> SIMP_RULE std_ss [GSYM SPEC_MOVE_COND];


(* code for installing no arg bytecode instructions *)

fun gen_code_for ins = let
  val name = (concat o map (fst o dest_const) o list_dest dest_comb) ins
  val ty = ``:zheap_state -> zheap_state``
  val v = mk_var("ic_" ^ name,ty)
  val x = ``x64 0 ^ins``
  val ev = EVAL x
  val th =
    append_imm_code |> SPEC x |> SPEC_ALL
      |> SIMP_RULE std_ss [ev,LENGTH,ADD1]
      |> PURE_REWRITE_RULE [append_imm_code_def,word_arith_lemma1]
      |> SIMP_RULE std_ss [] |> CONV_RULE (RAND_CONV (REWRITE_CONV [GSYM ev]))
  val _ = add_compiled [th]
  val (res,def,pre_def) = x64_compile `
    ^v (s:zheap_state) =
      let s = s with code := s.code ++ ^x in
        (s)`
  in (ins, CONJ def pre_def |> SIMP_RULE std_ss [LET_DEF]) end

fun closed tm = (length (free_vars tm) = 0)
fun spec_all tm = let
  val vs = free_vars tm
  val i = map (fn v => v |-> (if type_of v = ``:num`` then ``0:num``
                              else if type_of v = ``:int`` then ``0:int``
                              else mk_arb (type_of v))) vs
  in subst i tm end

val no_arg_codes =
  x64_def |> SPEC_ALL |> CONJUNCTS |> map (dest_eq o concl)
          |> filter (closed o snd) |> map (spec_all o fst) |> map rand
          |> filter (fn tm => tm <> ``Label 0``)

fun index tm = ``FST (bc_num ^tm)`` |> EVAL |> concl |> rand

val ic_no_args_def = let
  val is_no_args = map gen_code_for no_arg_codes
  val rest = ``(x1:bc_value,s:zheap_state)``
  fun mk_ic_case ((ins,defs),rest) = let
    val lhs = defs |> CONJUNCT1 |> concl |> dest_eq |> fst
    in ``if getNumber x1 = & (^(index ins)) then
           let (s) = ^lhs in (x1,s)
         else ^rest`` end
  val tm = foldr mk_ic_case rest is_no_args
  val (res,def,pre_def) = x64_compile `ic_no_args ^rest = ^tm`
  val thms = map snd is_no_args
  val ic_no_args_def = CONJ def pre_def
                       |> REWRITE_RULE thms |> SIMP_RULE std_ss [LET_DEF]
  in ic_no_args_def end;


(* simple one arg *)

fun gen tm = let
  val th = append_imm_code |> SPEC tm |> SPEC_ALL
      |> SIMP_RULE std_ss [LENGTH,ADD1]
      |> PURE_REWRITE_RULE [append_imm_code_def,word_arith_lemma1]
      |> SIMP_RULE std_ss []
  val _ = add_compiled [th]
  in tm end;

(*
  EVAL ``x64 i (Stack (Pops k))``
*)

val pops = ``[0x4Dw; 0x31w; 0xFFw; 0x48w; 0x81w; 0xC4w]:word8 list`` |> gen
val err = ``[0x49w; 0xFFw; 0x61w; 0x28w]:word8 list`` |> gen

val (res,ic_Pops_def,ic_Pops_pre_def) = x64_compile `
  ic_Pops (x2,s) =
    if isSmall x2 then
    if getNumber x2 < 268435456 then
      let x2 = Number (getNumber x2 * 8) in
      let s = s with code := s.code ++ ^pops in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(*
  EVAL ``x64 i (Stack (TagEq k))``
*)

val tageq1 = ``[0x48w; 0x31w; 0xC9w; 0x81w; 0xC1w]:word8 list`` |> gen
val tageq2 = ``[0x48w; 0xA9w; 0x1w; 0x0w; 0x0w;
      0x0w; 0x48w; 0x75w; 0x7w; 0x48w; 0x83w; 0xE8w; 0x2w; 0x48w; 0xEBw;
      0xEw; 0x48w; 0x8Bw; 0x40w; 0x1w; 0x48w; 0x25w; 0xFFw; 0xFFw; 0x0w;
      0x0w; 0x48w; 0xC1w; 0xE8w; 0x2w; 0x48w; 0x39w; 0xC8w; 0x48w;
      0x75w; 0x8w; 0xB8w; 0x26w; 0x0w; 0x0w; 0x0w; 0x48w; 0xEBw; 0x5w;
      0xB8w; 0x2Aw; 0x0w; 0x0w; 0x0w]:word8 list`` |> gen

val (res,ic_TagEq_def,ic_TagEq_pre_def) = x64_compile `
  ic_TagEq (x2,s) =
    if isSmall x2 then
    if getNumber x2 < 268435456 then
      let x2 = Number (getNumber x2 * 4) in
      let s = s with code := s.code ++ ^tageq1 in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^tageq2 in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(*
  EVAL ``x64 i (Stack (PushInt k))``
*)

val pushint = ``[0x48w; 0x50w; 0x48w; 0x31w; 0xC0w; 0x5w]:word8 list`` |> gen

val (res,ic_PushInt_def,ic_PushInt_pre_def) = x64_compile `
  ic_PushInt (x2,x3,s) =
    if isSmall x2 then
    if getNumber x2 < 268435456 then
    if getNumber x3 = 0 then
      let x2 = Number (getNumber x2 * 4) in
      let s = s with code := s.code ++ ^pushint in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
        (x2,x3,s)
    else if getNumber x2 = 0 then
      let x2 = Number (getNumber x2 * 4) in
      let s = s with code := s.code ++ ^pushint in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
        (x2,x3,s)
    else
      let s = s with code := s.code ++ ^err in (x2,x3,s)
    else let s = s with code := s.code ++ ^err in (x2,x3,s)
    else let s = s with code := s.code ++ ^err in (x2,x3,s)`

(*
  EVAL ``x64 i (PrintC c)``
*)

val printc1 = ``[0x4Dw; 0x8Bw; 0xB9w; 0x90w; 0x0w; 0x0w; 0x0w; 0x4Dw; 0x85w; 0xFFw;
    0x48w; 0x74w; 0x34w; 0x48w; 0x50w; 0x48w; 0x51w; 0x48w; 0x52w;
    0x48w; 0x53w; 0x48w; 0x56w; 0x48w; 0x57w; 0x49w; 0x50w; 0x49w;
    0x51w; 0x49w; 0x52w; 0x49w; 0x53w; 0xBFw]:word8 list`` |> gen
val printc2 = ``[0x0w; 0x0w;
    0x0w; 0x49w; 0x8Bw; 0x41w; 0x18w; 0x48w; 0xFFw; 0xD0w; 0x49w; 0x5Bw;
    0x49w; 0x5Aw; 0x49w; 0x59w; 0x49w; 0x58w; 0x48w; 0x5Fw; 0x48w;
    0x5Ew; 0x48w; 0x5Bw; 0x48w; 0x5Aw; 0x48w; 0x59w; 0x48w; 0x58w;
    0x4Dw; 0x31w; 0xFFw]:word8 list`` |> gen

val (res,ic_PrintC_test_def,ic_PrintC_test_pre_def) = x64_compile `
  ic_PrintC_test (x2) =
    if isSmall x2 then
      if getNumber x2 < 256 then x2 else let x2 = Number 0 in x2
    else let x2 = Number 0 in x2`;

val (res,ic_PrintC_def,ic_PrintC_pre_def) = x64_compile `
  ic_PrintC (x2,s) =
    let s = s with code := s.code ++ ^printc1 in
    let x2 = ic_PrintC_test x2 in
    let s = s with code := SNOC (n2w (Num (getNumber x2))) s.code in
    let s = s with code := s.code ++ ^printc2 in
      (x2,s)`

(*
  EVAL ``x64 i (Gread k)``
*)

val gread1 = ``[0x48w; 0x50w; 0x48w; 0x8Bw; 0xCBw; 0x48w; 0x31w; 0xC0w; 0x5w;
      0x0w; 0x0w; 0x0w; 0x0w; 0x48w; 0x8Bw; 0x44w; 0x41w; 0x9w; 0x48w;
      0x8Bw; 0xC8w; 0x48w; 0x31w; 0xC0w; 0x5w]:word8 list`` |> gen
val gread2 = ``[0x48w; 0x8Bw; 0x44w; 0x41w; 0x9w]:word8 list`` |> gen

val (res,ic_Gread_def,ic_Gread_pre_def) = x64_compile `
  ic_Gread (x2,s) =
    if isSmall x2 then
    if getNumber x2 < &^(globals_count_def |> concl |> rand) then
      let x2 = Number (getNumber x2 * 4) in
      let s = s with code := s.code ++ ^gread1 in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^gread2 in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(*
  EVAL ``x64 i (Gupdate k)``
*)

val gupdate1 = ``[0x48w; 0x50w; 0x48w; 0x8Bw; 0xCBw; 0x48w; 0x31w; 0xC0w; 0x5w;
      0x0w; 0x0w; 0x0w; 0x0w; 0x48w; 0x8Bw; 0x44w; 0x41w; 0x9w; 0x48w;
      0x8Bw; 0xD0w; 0x48w; 0x31w; 0xC9w; 0x48w; 0x81w; 0xC1w]:word8 list`` |> gen
val gupdate2 = ``[0x48w; 0x58w; 0x48w; 0x89w;
      0x44w; 0x4Aw; 0x9w; 0x48w; 0x58w]:word8 list`` |> gen

val (res,ic_Gupdate_def,ic_Gupdate_pre_def) = x64_compile `
  ic_Gupdate (x2,s) =
    if isSmall x2 then
    if getNumber x2 < &^(globals_count_def |> concl |> rand) then
      let x2 = Number (getNumber x2 * 4) in
      let s = s with code := s.code ++ ^gupdate1 in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^gupdate2 in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(*
  EVAL ``x64 i (Stack (Store x))``
*)

val store1 = ``[0x48w; 0x89w; 0x84w; 0x24w]:word8 list`` |> gen
val store2 = ``[0x48w; 0x58w]:word8 list`` |> gen

val (res,ic_Store_def,ic_Store_pre_def) = x64_compile `
  ic_Store (x2,s) =
    if isSmall x2 then
    if getNumber x2 < 268435456 then
      let x2 = Number (getNumber x2 * 8) in
      let s = s with code := s.code ++ ^store1 in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^store2 in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(*
  EVAL ``x64 i (Stack (Load x))``
*)

val load = ``[0x48w; 0x50w; 0x48w; 0x8Bw; 0x84w; 0x24w]:word8 list`` |> gen

val (res,ic_Load_def,ic_Load_pre_def) = x64_compile `
  ic_Load (x2,s) =
    if isSmall x2 then
    if getNumber x2 < 268435456 then
      let x2 = Number (getNumber x2 * 8) in
      let s = s with code := s.code ++ ^load in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
        (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)
    else let s = s with code := s.code ++ ^err in (x2,s)`

(* complicated one args *)

(*
  ``x64 i (Jump (Addr a))`` |> SIMP_CONV std_ss [x64_def,small_offset_def,LET_DEF]
*)

val jmp = ``[0x48w;0xE9w]:word8 list`` |> gen
val err6 = ``[0x49w; 0xFFw; 0x61w; 0x28w; 0xFFw; 0xC0w]:word8 list`` |> gen

val (res,ic_Jump_def,ic_Jump_pre_def) = x64_compile `
  ic_Jump (x1,x2,x3:bc_value,s) =
    let x3 = Number (&LENGTH s.code) in
    if ~isSmall x2 then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~isSmall x3 then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~(getNumber x2 < 268435456) then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~(getNumber x3 < 268435456) then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s)
    else
      let x2 = Number (getNumber x2 * 2) in
      let x1 = Number 6 in
      let s = s with code := s.code ++ ^jmp in
      let s = s with code := s.code ++ IMM32 (addr_calc x1 x2 x3) in
        (x1,x2,x3,s)`

(*
  ``x64 i (Call (Addr a))`` |> SIMP_CONV std_ss [x64_def,small_offset_def,LET_DEF]
*)

val call = ``[0x48w;0xE8w]:word8 list`` |> gen

val _ = hide "ic_Call"

val (res,ic_Call_def,ic_Call_pre_def) = x64_compile `
  ic_Call (x1,x2,x3:bc_value,s) =
    let x3 = Number (&LENGTH s.code) in
    if ~isSmall x2 then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~isSmall x3 then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~(getNumber x2 < 268435456) then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s) else
    if ~(getNumber x3 < 268435456) then
      let s = s with code := s.code ++ ^err6 in (x1,x2,x3,s)
    else
      let x2 = Number (getNumber x2 * 2) in
      let x1 = Number 6 in
      let s = s with code := s.code ++ ^call in
      let s = s with code := s.code ++ IMM32 (addr_calc x1 x2 x3) in
        (x1,x2,x3,s)`

(*
  ``x64 i (JumpIf (Addr a))`` |> SIMP_CONV std_ss [x64_def,small_offset_def,LET_DEF]
*)

val jumpif = ``[0x48w; 0x83w; 0xF8w; 0x2Aw; 0x48w; 0x58w; 0xFw;
                0x85w]:word8 list`` |> gen
val err12 = ``[0x49w; 0xFFw; 0x61w; 0x28w; 0xFFw; 0xC0w; 0xFFw;
               0xC0w; 0xFFw; 0xC0w; 0xFFw; 0xC0w]:word8 list`` |> gen

val _ = hide "ic_JumpIf"

val (res,ic_JumpIf_def,ic_JumpIf_pre_def) = x64_compile `
  ic_JumpIf (x1,x2,x3:bc_value,s) =
    let x3 = Number (&LENGTH s.code) in
    if ~isSmall x2 then
      let s = s with code := s.code ++ ^err12 in (x1,x2,x3,s) else
    if ~isSmall x3 then
      let s = s with code := s.code ++ ^err12 in (x1,x2,x3,s) else
    if ~(getNumber x2 < 268435456) then
      let s = s with code := s.code ++ ^err12 in (x1,x2,x3,s) else
    if ~(getNumber x3 < 268435456) then
      let s = s with code := s.code ++ ^err12 in (x1,x2,x3,s)
    else
      let x2 = Number (getNumber x2 * 2) in
      let x1 = Number 12 in
      let s = s with code := s.code ++ ^jumpif in
      let s = s with code := s.code ++ IMM32 (addr_calc x1 x2 x3) in
        (x1,x2,x3,s)`

(*
  ``x64 i (PushPtr (Addr a))`` |> SIMP_CONV std_ss [x64_def,small_offset_def,LET_DEF]
*)

val pushptr = ``[0x48w; 0x50w; 0x48w; 0xE8w; 0x0w; 0x0w; 0x0w; 0x0w; 0x48w;
                 0x58w; 0x48w; 0x5w]:word8 list`` |> gen
val err16 = ``[0x49w; 0xFFw; 0x61w; 0x28w; 0xFFw; 0xC0w; 0xFFw;
               0xC0w; 0xFFw; 0xC0w; 0xFFw; 0xC0w; 0xFFw; 0xC0w;
               0xFFw; 0xC0w]:word8 list`` |> gen

val _ = hide "ic_PushPtr";

val (res,ic_PushPtr_def,ic_PushPtr_pre_def) = x64_compile `
  ic_PushPtr (x1,x2,x3:bc_value,s) =
    let x3 = Number (&LENGTH s.code) in
    if ~isSmall x2 then
      let s = s with code := s.code ++ ^err16 in (x1,x2,x3,s) else
    if ~isSmall x3 then
      let s = s with code := s.code ++ ^err16 in (x1,x2,x3,s) else
    if ~(getNumber x2 < 268435456) then
      let s = s with code := s.code ++ ^err16 in (x1,x2,x3,s) else
    if ~(getNumber x3 < 268435456) then
      let s = s with code := s.code ++ ^err16 in (x1,x2,x3,s)
    else
      let x2 = Number (getNumber x2 * 2) in
      let x1 = Number 8 in
      let s = s with code := s.code ++ ^pushptr in
      let s = s with code := s.code ++ IMM32 (addr_calc x1 x2 x3) in
        (x1,x2,x3,s)`

(*
  ``x64 i (Stack (Cons a))`` |> SIMP_CONV std_ss [x64_def,small_offset_def,LET_DEF]
*)

val cons1 = ``[0x48w; 0x83w; 0xF8w; 0x0w; 0x48w; 0x74w; 0x6Fw; 0x48w; 0xA9w;
      0x3w; 0x0w; 0x0w; 0x0w; 0x48w; 0x75w; 0x9w; 0x48w; 0x3Dw; 0x0w;
      0x0w; 0x2w; 0x0w; 0x48w; 0x72w; 0x4w; 0x49w; 0xFFw; 0x61w; 0x28w;
      0x4Cw; 0x8Bw; 0xF0w; 0x49w; 0xD1w; 0xE6w; 0x49w; 0x83w; 0xC6w;
      0x8w; 0x4Cw; 0x8Bw; 0xFFw; 0x49w; 0x29w; 0xF7w; 0x4Dw; 0x39w;
      0xF7w; 0x73w; 0x7w; 0x4Dw; 0x8Bw; 0x69w; 0x30w; 0x49w; 0xFFw;
      0xD5w; 0x41w; 0xBEw]:word8 list`` |> gen
val cons2 = ``[0x49w; 0xC1w; 0xE6w; 0x4w;
      0x4Cw; 0x8Bw; 0xF8w; 0x49w; 0xC1w; 0xE7w; 0xEw; 0x4Dw; 0x1w;
      0xFEw; 0x4Dw; 0x8Bw; 0xFEw; 0x49w; 0xC1w; 0xEFw; 0x10w; 0x48w;
      0x58w; 0x48w; 0x83w; 0xEFw; 0x8w; 0x48w; 0x89w; 0x47w; 0x1w;
      0x49w; 0xFFw; 0xCFw; 0x49w; 0x83w; 0xFFw; 0x0w; 0x48w; 0x75w;
      0xECw; 0x48w; 0x83w; 0xEFw; 0x8w; 0x4Cw; 0x89w; 0x77w; 0x1w;
      0x48w; 0x8Bw; 0xC7w; 0x48w; 0xEBw; 0x5w; 0xB8w]:word8 list`` |> gen
val cons3 = ``[0x4Dw; 0x31w; 0xFFw]:word8 list`` |> gen

val (res,ic_Cons_def,ic_Cons_pre_def) = x64_compile `
  ic_Cons (x1:bc_value,x2:bc_value,x3:bc_value,s) =
    if ~isSmall x2 then
      let s = s with code := s.code ++ ^err in (x1,x2,x3,s)
    else if ~(getNumber x2 < 4096) then
      let s = s with code := s.code ++ ^err in (x1,x2,x3,s)
    else
      let s = s with code := s.code ++ ^cons1 in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^cons2 in
      let x2 = Number (getNumber x2 * 4) in
      let x2 = Number (getNumber x2 + 1) in
      let x2 = Number (getNumber x2 + 1) in
      let s = s with code := s.code ++ IMM32 (n2w (Num (getNumber x2))) in
      let s = s with code := s.code ++ ^cons3 in
        (x1:bc_value,x2,x3,s)`


(* putting them all together *)

val (ic_Any_res,ic_Any_def,ic_Any_pre_def) = x64_compile `
  ic_Any (x1,x2,x3,s) =
    if getNumber x1 = & ^(index ``Jump (Addr a)``) then
      let (x1,x2,x3,s) = ic_Jump (x1,x2,x3,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``JumpIf (Addr a)``) then
      let (x1,x2,x3,s) = ic_JumpIf (x1,x2,x3,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``PushPtr (Addr a)``) then
      let (x1,x2,x3,s) = ic_PushPtr (x1,x2,x3,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Call (Addr a)``) then
      let (x1,x2,x3,s) = ic_Call (x1,x2,x3,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (Pops a)``) then
      let (x2,s) = ic_Pops (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (Load a)``) then
      let (x2,s) = ic_Load (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (Store a)``) then
      let (x2,s) = ic_Store (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Gread k``) then
      let (x2,s) = ic_Gread (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Gupdate k``) then
      let (x2,s) = ic_Gupdate (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``PrintC c``) then
      let (x2,s) = ic_PrintC (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Label l``) then
      (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (TagEq a)``) then
      let (x2,s) = ic_TagEq (x2,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (PushInt a)``) then
      let (x2,x3,s) = ic_PushInt (x2,x3,s) in (x1,x2,x3,s)
    else if getNumber x1 = & ^(index ``Stack (Cons a)``) then
      let (x1,x2,x3,s) = ic_Cons (x1,x2,x3,s) in (x1,x2,x3,s)
    else
      let (x1,s) = ic_no_args (x1,s) in (x1,x2,x3,s)`;

val s_with_code = prove(
  ``!s. s = s with code := s.code``,
  Cases_on `s` \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``));

val ORD_BOUND_LARGE = prove(
  ``ORD c < 2305843009213693952``,
  ASSUME_TAC (Q.SPEC `c` ORD_BOUND) \\ DECIDE_TAC);

val lemma = prove(
  ``(Num ((&n + 1 + 1) * 8) = (n + 2) * 8) /\
    (Num ((&n + 1 + 1 + 1) * 8) = (n + 3) * 8) /\
    (Num (&(n * 4) + 1 + 1) = (n * 4) + 2) /\
    (Num ((&n0 + 1) * 8) = (n0 + 1) * 8) /\
    (Num (&m + &n) = m + n)``,
  intLib.COOPER_TAC);

val ic_PrintC_test_thm = prove(
  ``ic_PrintC_test_pre (Number (&n)) /\
    (Num (getNumber (ic_PrintC_test (Number (&n)))) = if n < 256 then n else 0) /\
    small_int (getNumber (ic_PrintC_test (Number (&n)))) /\
    isNumber (ic_PrintC_test (Number (&n))) /\
    ~(getNumber (ic_PrintC_test (Number (&n))) < 0)``,
  SIMP_TAC (srw_ss()) [ic_PrintC_test_pre_def,ic_PrintC_test_def,
    getNumber_def,LET_DEF,isSmall_def,canCompare_def,small_int_def]
  \\ SRW_TAC [] [isNumber_def,getNumber_def] \\ intLib.COOPER_TAC);

val LENGTH_x64_LESS = prove(
  ``!i n. LENGTH (x64 n i) < 200``,
  Cases \\ SIMP_TAC (srw_ss()) [x64_def]
  \\ TRY (Cases_on `b`) \\ TRY (Cases_on `l`)
  \\ SRW_TAC [] [x64_def,small_offset12_def,small_offset6_def,
       small_offset16_def,small_offset_def,IMM32_def] \\ SRW_TAC [] []);

fun ASSERT_TAC P goal = if P goal then ALL_TAC goal
                        else (print "ASSERT_TAC failed."; NO_TAC goal);

val ic_Any_thm = prove(
  ``!n1 n2 n3.
      (s.code_mode = SOME F) ==>
      ?x1 x2 x3.
        (LENGTH s.code + LENGTH (x64 (LENGTH s.code) (num_bc (n1,n2,n3))) <=
          s.code_max_length ==>
         ic_Any_pre (Number (& n1),Number (& n2),Number (& n3),s)) /\
        (ic_Any (Number (& n1),Number (& n2),Number (& n3),s) =
           (x1,x2,x3,s with code := s.code ++
              x64 (LENGTH s.code) (num_bc (n1,n2,n3))))``,
  REVERSE (Cases \\ NTAC 22 (TRY (Cases_on `n`) \\ TRY (Cases_on `n'`)))
  \\ FULL_SIMP_TAC (srw_ss()) [ADD1,GSYM ADD_ASSOC]
  \\ FULL_SIMP_TAC (srw_ss()) [num_bc_def,DECIDE ``k < n ==> m + n <> k:num``]
  \\ STRIP_TAC \\ STRIP_TAC
  \\ Q.ABBREV_TAC `k = n` \\ POP_ASSUM (K ALL_TAC)
  \\ Q.ABBREV_TAC `n = n2` \\ POP_ASSUM (K ALL_TAC)
  \\ Q.ABBREV_TAC `n0 = n3` \\ POP_ASSUM (K ALL_TAC)
  \\ SIMP_TAC (srw_ss()) [num_bc_def,LET_DEF,ic_Any_def,ic_Any_pre_def,
       getNumber_def,ic_no_args_def,isNumber_def,
       ic_Pops_def,ic_Pops_pre_def,
       ic_PrintC_def,ic_PrintC_pre_def,
       ic_Load_def,ic_Load_pre_def,
       ic_Store_def,ic_Store_pre_def,
       ic_Gread_def,ic_Gread_pre_def,
       ic_Gupdate_def,ic_Gupdate_pre_def,
       ic_PushInt_def,ic_PushInt_pre_def,
       ic_TagEq_def,ic_TagEq_pre_def,
       isSmall_def,canCompare_def]
  \\ FULL_SIMP_TAC (srw_ss()) [num_bc_def,DECIDE ``k < n ==> m + n <> k:num``]
  \\ TRY (SIMP_TAC std_ss [x64_def,LENGTH,LET_DEF] \\ NO_TAC)
  \\ TRY (Cases_on `n < 268435456`
    \\ FULL_SIMP_TAC (srw_ss()) [small_int_def,x64_def,LET_DEF,addr_calc_def,
      small_offset_def,LENGTH,IMM32_def,APPEND_ASSOC,APPEND,ic_PrintC_test_thm,
      SNOC_APPEND,getNumber_def]
    \\ SRW_TAC [] []
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,GSYM ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC,ORD_BOUND_LARGE,lemma]
    \\ CCONTR_TAC \\ intLib.COOPER_TAC)
  \\ TRY (Cases_on `n < ^(globals_count_def |> concl |> rand)`
    \\ FULL_SIMP_TAC (srw_ss()) [small_int_def,x64_def,LET_DEF,addr_calc_def,
      small_offset_def,LENGTH,IMM32_def,APPEND_ASSOC,APPEND,ic_PrintC_test_thm,
      SNOC_APPEND,getNumber_def,globals_count_def]
    \\ SRW_TAC [] []
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND,GSYM ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC,ORD_BOUND_LARGE,lemma]
    \\ CCONTR_TAC \\ intLib.COOPER_TAC)
  \\ TRY (SIMP_TAC std_ss [x64_def,APPEND_NIL,s_with_code] \\ NO_TAC)
  \\ TRY (
    rw[] >> fs[] >> fsrw_tac[ARITH_ss][x64_def] >>
    simp[theorem"zheap_state_component_equality"] >>
    NO_TAC)
  \\ TRY (Cases_on `n < 268435456` \\ Cases_on `LENGTH s.code < 268435456`
    \\ IMP_RES_TAC (DECIDE ``n < (268435456:num) ==> n < 2305843009213693952``)
    \\ IMP_RES_TAC (DECIDE ``n < (268435456:num) ==> n < 4611686018427387904``)
    \\ FULL_SIMP_TAC (srw_ss()) [small_int_def,x64_def,
        small_offset_def, small_offset6_def, small_offset12_def, small_offset16_def,
        LENGTH,IMM32_def,APPEND_ASSOC,APPEND,
        ic_Jump_def,ic_Jump_pre_def,
        ic_JumpIf_def,ic_JumpIf_pre_def,
        ic_Call_def,ic_Call_pre_def,
        ic_PushPtr_def,ic_PushPtr_pre_def,
        LET_DEF,isSmall_def,
        isNumber_def,getNumber_def,canCompare_def,addr_calc_def,
        AC MULT_COMM MULT_ASSOC]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
    \\ REPEAT STRIP_TAC \\ intLib.COOPER_TAC)
  \\ ASSERT_TAC (fn (_,goal) =>
       can (find_term (can (match_term ``Stack (Cons n)``))) goal)
  \\ fs [ic_Cons_def,ic_Cons_pre_def]
  \\ Cases_on `n < 4096`
  \\ TRY (`n < 2305843009213693952` by DECIDE_TAC)
  \\ TRY (`n < 4611686018427387904` by DECIDE_TAC)
  \\ FULL_SIMP_TAC (srw_ss()) [small_int_def,x64_def,
        small_offset_def, small_offset6_def, small_offset12_def, small_offset16_def,
        LENGTH,IMM32_def,APPEND_ASSOC,APPEND,
        ic_Jump_def,ic_Jump_pre_def,
        ic_JumpIf_def,ic_JumpIf_pre_def,
        ic_Call_def,ic_Call_pre_def,
        ic_PushPtr_def,ic_PushPtr_pre_def,
        LET_DEF,isSmall_def,
        isNumber_def,getNumber_def,canCompare_def,addr_calc_def,
        AC MULT_COMM MULT_ASSOC]
  \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,APPEND]
  \\ fs [fetch "-" "zheap_state_component_equality",lemma]
  \\ REPEAT STRIP_TAC \\ intLib.COOPER_TAC);

(* add check for code_heap limit *)

val (check_code_limit_res,check_code_limit_def) =
  x64_decompile_no_status "check_code_limit" `
    mov r15,[r9+80]
    mov r14,[r9+96]
    sub r15,r14
    add r15,200
    mov r14,[r9+88]
    cmp r15,r14 `

val zHEAP_CODE_LIMIT = let
  val th = check_code_limit_res
  val th = HIDE_STATUS_RULE false sts th
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
              |> UNDISCH |> Q.INST [`rip`|->`p`]
  val pc = get_pc th
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals /\
            LENGTH s.code <= s.code_max_length)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma |> DISCH_ALL |> DISCH T
                       |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (cs,
       x1,x2,x3,x4,refs,stack,s,NONE) * ~zS1 Z_AF *
      zS1 Z_CF (SOME (LENGTH s.code + 200 < s.code_max_length)) *
      ~zS1 Z_OF * ~zS1 Z_SF * ~zS1 Z_ZF * ~zS1 Z_PF * ^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ fs [check_code_limit_def,LET_DEF]
    \\ STRIP_TAC \\ fs [PULL_FORALL,PULL_EXISTS_IMP,PULL_EXISTS]
    \\ STRIP_TAC
    \\ Q.ABBREV_TAC `t1 = vals.memory (vals.reg9 + 0x50w)`
    \\ Q.ABBREV_TAC `t2 = vals.memory (vals.reg9 + 0x60w)`
    \\ Q.ABBREV_TAC `t3 = vals.memory (vals.reg9 + 0x58w)`
    \\ Q.EXISTS_TAC `vals with <| reg14 := t3; reg15 := (t1 + -0x1w * t2 + 200w) |>`
    \\ `(LENGTH s.code + 200 < s.code_max_length <=>
         t1 + -0x1w * t2 + 200w <+ t3) /\
        vals.reg9 + 0x50w IN vals.memory_domain /\
        (0x7w && vals.reg9 + 0x50w = 0x0w) /\
        vals.reg9 + 0x60w IN vals.memory_domain /\
        (0x7w && vals.reg9 + 0x60w = 0x0w) /\
        vals.reg9 + 0x58w IN vals.memory_domain /\
        (0x7w && vals.reg9 + 0x58w = 0x0w)` by ALL_TAC THEN1
     (fs [heap_inv_def,heap_vars_ok_def,x64_store_def,one_list_def]
      \\ UNABBREV_ALL_TAC \\ SEP_R_TAC \\ fs [] \\ REVERSE STRIP_TAC THEN1
       (Q.PAT_ASSUM `0x7w && vs.base_ptr = 0x0w` MP_TAC \\ blastLib.BBLAST_TAC)
      \\ Q.PAT_ASSUM `kkk (fun2set (vals.memory,vals.memory_domain))` (K ALL_TAC)
      \\ fs [code_heap_inv_def] \\ rfs []
      \\ Q.PAT_ASSUM `xxx = vs.code_ptr` (MP_TAC o GSYM) \\ fs []
      \\ fs [word_add_n2w,WORD_LO]
      \\ `(LENGTH s.code + 200) < 18446744073709551616 /\
          cs.code_heap_length < 18446744073709551616` by ALL_TAC \\ fs []
      \\ REPEAT STRIP_TAC \\ DECIDE_TAC) \\ fs []
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ fs [zVALS_def] \\ REPEAT STRIP_TAC
    THEN1 (fs [heap_inv_def] \\ METIS_TAC [])
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ fs [SEP_HIDE_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ Q.LIST_EXISTS_TAC [`NONE`,
         `(SOME ((word_msb (t1 + -0x1w * t2 + 200w) <=/=> word_msb
            t3) /\ (word_msb (t1 + -0x1w * t2 + -0x1w * t3 + 200w)
            <=/=> word_msb (t1 + -0x1w * t2 + 200w))))`,
         `(SOME (byte_parity ((w2w:word64->word8)
            (t1 + -0x1w * t2 + -0x1w * t3 + 200w:word64))))`,
         `(SOME (word_msb (t1 + -0x1w * t2 + -0x1w * t3 + 200w)))`,
         `(SOME (t1 + -0x1w * t2 + 200w = t3))`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p *
      cond (IS_SOME s.code_mode)``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++sep_cond_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES,
         AC CONJ_ASSOC CONJ_COMM,SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ fs [cond_STAR]
    \\ Q.EXISTS_TAC `vals` \\ fs []
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [zVALS_def,zOPTION_CODE_HEAP_def,heap_inv_def]
    \\ fs [code_heap_inv_def] \\ rfs [code_heap_inv_def]
    \\ Cases_on `s.code_mode` \\ fs [zOPTION_CODE_HEAP_def]
    \\ fs [zCODE_HEAP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR] \\ DECIDE_TAC)
  val th = MP th lemma
  in th end;

val zHEAP_CODE_LIMIT_TEST = let
  val th0 = zHEAP_CODE_LIMIT
  val ((th1,_,_),th2a) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode "jb 4")
  fun the (SOME x) = x | the _ = fail()
  val th2 = th2a |> the |> #1
  val thA = SPEC_COMPOSE_RULE [th0,th1]
  val thB = SPEC_COMPOSE_RULE [th0,th2]
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val thA = HIDE_STATUS_RULE true sts thA
  val thB = HIDE_STATUS_RULE true sts thB
  val thA = thA |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val thB = thB |> SIMP_RULE (std_ss++sep_cond_ss) [precond_def]
  val IF_COMPOSE_LEMMA = prove(
    ``SPEC m (p * cond (b /\ d)) c q1 /\ SPEC m (p * cond (~b /\ d)) c q2 ==>
      SPEC m (p * cond d) c (if b then q1 else q2)``,
    Cases_on `b` \\ fs [SEP_CLAUSES]);
  val th = MATCH_MP IF_COMPOSE_LEMMA (CONJ thA thB)
  in th end;

val my_imp_def = Define `my_imp b1 b2 = (b1 ==> b2)`;

val ic_Any_with_test = let
  val th = zHEAP_CODE_LIMIT_TEST
  val th1 = DISCH ``LENGTH s.code + 200 < s.code_max_length`` th
            |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val th2 = DISCH ``~(LENGTH s.code + 200 < s.code_max_length)`` th
            |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val th2 = SPEC_COMPOSE_RULE [th2,zHEAP_TERMINATE_WITH_ERROR]
  val th2 = DISCH ``my_imp (LENGTH s.code + 200 < s.code_max_length)
         (ic_Any_pre (x1,x2,x3,s))`` th2 |> RW [GSYM SPEC_MOVE_COND]
  val (_,_,c,_) = dest_spec (concl th2)
  val th0 = MATCH_MP SPEC_SUBSET_CODE th1 |> SPEC c
            |> SIMP_RULE std_ss [INSERT_SUBSET,IN_INSERT,EMPTY_SUBSET]
  val th1 = SPEC_COMPOSE_RULE [th0,ic_Any_res]
  val lemma = prove(``(b1 ==> b2 ==> b3) ==>
                      (b1 ==> (my_imp b1 b2) ==> b3)``,fs [my_imp_def])
  val th1 = MATCH_MP lemma (th1 |> RW1 [SPEC_MOVE_COND] |> DISCH_ALL)
            |> UNDISCH |> RW [GSYM SPEC_MOVE_COND]
  val lemma = prove(
    ``(b1 ==> SPEC m p c1 q1) /\
      (~b1 ==> SPEC m p c2 q2) ==>
      c2 SUBSET c1 ==>
      SPEC m p c1 (q1 \/ q2)``,
    Cases_on `b1` \\ fs []
    \\ REPEAT STRIP_TAC
    \\ `SEP_IMP q1 (q1 \/ q2)` by fs [SEP_IMP_def,SEP_DISJ_def]
    \\ `SEP_IMP q2 (q1 \/ q2)` by fs [SEP_IMP_def,SEP_DISJ_def]
    \\ IMP_RES_TAC SPEC_WEAKEN
    \\ IMP_RES_TAC SPEC_ADD_CODE
    \\ REPEAT (FIRST_X_ASSUM (MP_TAC o Q.SPEC `c1`))
    \\ `c2 UNION c1 = c1` by (fs [SUBSET_DEF,EXTENSION] \\ METIS_TAC [])
    \\ fs []);
  val th = MATCH_MP lemma (CONJ (DISCH_ALL th1) (DISCH_ALL th2))
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    REWRITE_TAC [INSERT_SUBSET,IN_INSERT]
    \\ REWRITE_TAC [SUBSET_DEF,IN_INSERT,IN_UNION]
    \\ REPEAT STRIP_TAC \\ ASM_REWRITE_TAC [])
  val th = MP th lemma
  val pc = get_pc th
  val (th,goal) = SPEC_WEAKEN_RULE th ``
       let (x1,x2,x3,s) = ic_Any (x1,x2,x3,s) in
         ~zS * ^pc *
         zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) \/ zHEAP_ERROR cs``
  val lemma = prove(goal,
    fs []
    \\ Cases_on `ic_Any (x1,x2,x3,s)`
    \\ PairCases_on `r` \\ fs[LET_DEF,SEP_IMP_def,cond_STAR]
    \\ REPEAT STRIP_TAC \\ fs [])
  val th = MP th lemma |> SIMP_RULE (std_ss++sep_cond_ss) []
  in th end;

val _ = add_compiled [ic_Any_with_test];

(* code install that walks down a list *)

val (res,ic_List_def,ic_List_pre_def) = x64_compile `
  ic_List (x1,x2,x3,x4,s,stack) =
    if isSmall x4 then (x1,x2,x3,x4,s,stack) else
      let x1 = x4 in
      let x2 = Number 0 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* HD *)
      let x3 = x1 in
      let x1 = x4 in
      let x2 = Number 1 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* TL *)
      let x4 = x1 in
      let x1 = x3 in
      let x2 = Number 0 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* FST o HD *)
      let stack = x1::stack in
      let x1 = x3 in
      let x2 = Number 1 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* SND o HD *)
      let x3 = x1 in
      let x2 = Number 0 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* FST o SND o HD *)
      let stack = x1::stack in
      let x1 = x3 in
      let x2 = Number 1 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in (* SND o SND o HD *)
      let x3 = x1 in
      let (x2,stack) = (HD stack,TL stack) in
      let (x1,stack) = (HD stack,TL stack) in
      let (x1,x2,x3,s) = ic_Any (x1,x2,x3,s) in
        ic_List (x1,x2,x3,x4,s,stack)`

val install_x64_code_lists_def = Define `
  (install_x64_code_lists [] s_code = s_code) /\
  (install_x64_code_lists ((x:num # num # num)::xs) s_code =
     install_x64_code_lists xs
       (s_code ++ x64_code (LENGTH s_code) [num_bc x]))`;

val ic_List_thm = prove(
  ``!code x1 x2 x3 s stack.
      (s.code_mode = SOME F) ==>
      ?y1 y2 y3.
        (ic_List_pre (x1,x2,x3,BlockList (MAP BlockNum3 code),s,stack)) /\
        (ic_List (x1,x2,x3,BlockList (MAP BlockNum3 code),s,stack) =
           (y1,y2,y3,BlockList [],
            s with code := install_x64_code_lists code s.code,stack))``,
  Induct \\ SIMP_TAC std_ss [MAP,APPEND] THEN1
   (FULL_SIMP_TAC std_ss [APPEND] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [Once ic_List_def,Once ic_List_pre_def,BlockList_def]
    \\ FULL_SIMP_TAC std_ss [x64_code_def,APPEND_NIL,install_x64_code_lists_def]
    \\ FULL_SIMP_TAC std_ss [LET_DEF,HD,TL,EVAL ``isSmall BlockNil``]
    \\ EVAL_TAC \\ fs [fetch "-" "zheap_state_component_equality"])
  \\ SIMP_TAC std_ss [Once ic_List_def,Once ic_List_pre_def]
  \\ SIMP_TAC std_ss [isSmall_def,x64_code_def,LET_DEF,
         APPEND_NIL,s_with_code,canCompare_def,NOT_CONS_NIL]
  \\ SIMP_TAC std_ss [getNumber_def,getContent_def,BlockList_def,
       BlockNum3_def,isSmall_def,BlockCons_def]
  \\ SIMP_TAC (srw_ss()) [EVAL ``Num 0``,EVAL ``Num 1``,EL,HD,TL,getContent_def,
       isBlock_def,BlockNum3_def,isNumber_def,getNumber_def] \\ REPEAT STRIP_TAC
  \\ `?h1 h2 h3. h = (h1,h2,h3)` by METIS_TAC [PAIR]
  \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC (srw_ss()) [EVAL ``Num 0``,EVAL ``Num 1``,EL,HD,TL,getContent_def,
       isBlock_def,BlockNum3_def,isNumber_def,getNumber_def,canCompare_def,
       BlockPair_def] \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss []
  \\ MP_TAC (Q.SPECL [`h1`,`h2`,`h3`] ic_Any_thm)
  \\ REPEAT STRIP_TAC \\ fs [] \\ rfs []
  \\ SEP_I_TAC "ic_List" \\ fs [] \\ rfs []
  \\ REPEAT STRIP_TAC
  \\ fs [BlockList_def,install_x64_code_lists_def,x64_code_def]
  \\ fs [my_imp_def]
  \\ `LENGTH (x64 (LENGTH s.code) (num_bc (h1,h2,h3))) < 200` by
         fs [LENGTH_x64_LESS] \\ fs [] \\ REPEAT STRIP_TAC
  \\ FIRST_X_ASSUM MATCH_MP_TAC \\ DECIDE_TAC);

val (ic_full_res,ic_full_def,ic_full_pre_def) = x64_compile `
  ic_full (x1,x2,x3,x4,s,stack) =
    let stack = x1 :: stack in
    let stack = x2 :: stack in
    let stack = x3 :: stack in
    let s = s with code_start := s.code in
    let (x1,x2,x3,x4,s,stack) = ic_List (x1,x2,x3,x4,s,stack) in
    let (x3,stack) = (HD stack, TL stack) in
    let (x2,stack) = (HD stack, TL stack) in
    let (x1,stack) = (HD stack, TL stack) in
    let x4 = x1 in
      (x1,x2,x3,x4,s,stack)`

val ic_full_thm = prove(
  ``(s.code_mode = SOME F) ==>
    ic_full_pre (x1,x2,x3,BlockList (MAP BlockNum3 code),s,stack) /\
    (ic_full (x1,x2,x3,BlockList (MAP BlockNum3 code),s,stack) =
      (x1,x2,x3,x1,s with <| code := install_x64_code_lists code s.code ;
                             code_start := s.code |>, stack))``,
  Q.SPEC_TAC (`x4`,`x4`) \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [ic_full_def,ic_full_pre_def,LET_DEF]
  \\ MP_TAC (ic_List_thm |> SPEC_ALL |> Q.INST [`stack`|->`x3::x2::x1::stack`,
               `s`|->`s with code_start := s.code`])
  \\ fs [] \\ STRIP_TAC \\ FULL_SIMP_TAC (srw_ss()) []);

val zHEAP_INSTALL_CODE = let
  val th = ic_full_res
    |> DISCH ``(x4 = BlockList (MAP BlockNum3 code))``
    |> DISCH ``s.code_mode = SOME F``
    |> SIMP_RULE std_ss [ic_full_thm,LET_DEF,SEP_CLAUSES]
    |> GSYM |> SIMP_RULE std_ss []
    |> RW [GSYM SPEC_MOVE_COND] |> GSYM
  val th = SPEC_COMPOSE_RULE [zHEAP_CALL_INSTALL_WITH_STOP_ADDR,
             zHEAP_CODE_UNSAFE,th,
             zHEAP_CODE_SAFE,zHEAP_POP1,
             zHEAP_JMP_CODE_START]
  val th = th |> CONV_RULE (PRE_CONV (SIMP_CONV (srw_ss()) [SEP_CLAUSES]))
  val th = th |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss()) [SEP_CLAUSES]))
  val th = abbreviate_code "install_and_run" ``cs.install_and_run_ptr`` th
  in th end;


(* --- lexer --- *)

val bool2int_def = Define `
  bool2int b = if b then 1:int else 0`;

val s_with_input = prove(
  ``!s. s = s with input := s.input``,
  Cases_on `s` \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``));

val bool2int_thm = prove(
  ``!b. (bool2int b = 0) <=> ~b``,
  Cases \\ EVAL_TAC);

val DROP_1_CONS = EVAL ``DROP 1 (x::xs)``

(* isSpace *)

val (res,is_space_def,is_space_pre_def) = x64_compile `
  is_space (s:zheap_state) =
    let x1 = Number 1 in
      if HD s.input = CHR 32 then (x1,s) else
      if ~(ORD (HD s.input) < 9) /\ ORD (HD s.input) < 14 then (x1,s) else
        let x1 = Number 0 in (x1,s)`

val is_space_thm = prove(
  ``(is_space_pre s = s.input <> "") /\
    (is_space s = (Number (bool2int (isSpace (HD s.input))), s))``,
  SIMP_TAC std_ss [is_space_def,is_space_pre_def,LET_DEF,isSpace_def]
  \\ Cases_on `HD s.input` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ SRW_TAC [] [bool2int_def] \\ intLib.COOPER_TAC);

(* isDigit *)

val (res,is_digit_def,is_digit_pre_def) = x64_compile `
  is_digit (s:zheap_state) =
    if ORD (HD s.input) < 48 then let x1 = Number 0 in (x1,s) else
    if ORD (HD s.input) < 58 then let x1 = Number 1 in (x1,s) else
      let x1 = Number 0 in (x1,s)`

val is_digit_thm = prove(
  ``(is_digit_pre s = s.input <> "") /\
    (is_digit s = (Number (bool2int (isDigit (HD s.input))), s))``,
  SIMP_TAC std_ss [is_digit_def,is_digit_pre_def,LET_DEF,isDigit_def]
  \\ Cases_on `HD s.input` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ SRW_TAC [] [bool2int_def] \\ intLib.COOPER_TAC);

(* isAlpha *)

val (res,is_alpha_def,is_alpha_pre_def) = x64_compile `
  is_alpha (s:zheap_state) =
    if ORD (HD s.input) < 65 then let x1 = Number 0 in (x1,s) else
    if ORD (HD s.input) < 91 then let x1 = Number 1 in (x1,s) else
    if ORD (HD s.input) < 97 then let x1 = Number 0 in (x1,s) else
    if ORD (HD s.input) < 123 then let x1 = Number 1 in (x1,s) else
      let x1 = Number 0 in (x1,s)`

val is_alpha_thm = prove(
  ``(is_alpha_pre s = s.input <> "") /\
    (is_alpha s = (Number (bool2int (isAlpha (HD s.input))), s))``,
  SIMP_TAC std_ss [is_alpha_def,is_alpha_pre_def,LET_DEF,
    isAlpha_def,isLower_def,isUpper_def]
  \\ Cases_on `HD s.input` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ SRW_TAC [] [bool2int_def] \\ intLib.COOPER_TAC);

(* isAlphaNum *)

val (res,is_alphanum_def,is_alphanum_pre_def) = x64_compile `
  is_alphanum (s:zheap_state) =
    let (x1,s) = is_alpha s in
      if getNumber x1 = 1 then (x1,s) else
        let (x1,s) = is_digit s in (x1,s)`

val is_alphanum_thm = prove(
  ``(is_alphanum_pre s = s.input <> "") /\
    (is_alphanum s = (Number (bool2int (isAlphaNum (HD s.input))), s))``,
  SIMP_TAC std_ss [is_alphanum_def,is_alphanum_pre_def,LET_DEF,
    isAlphaNum_def,is_alpha_thm,is_digit_thm,getNumber_def,isNumber_def]
  \\ SRW_TAC [] [bool2int_def] \\ FULL_SIMP_TAC (srw_ss()) []);

(* isAlphaNumPrime *)

val (res,is_alphanumprime_def,is_alphanumprime_pre_def) = x64_compile `
  is_alphanumprime (s:zheap_state) =
    let x1 = Number 1 in
      if HD s.input = #"'" then (x1,s) else
      if HD s.input = #"_" then (x1,s) else
        let (x1,s) = is_alphanum s in
          (x1,s)`

val is_alphanumprime_thm = prove(
  ``(is_alphanumprime_pre s = s.input <> "") /\
    (is_alphanumprime s = (Number (bool2int (isAlphaNumPrime (HD s.input))), s))``,
  SIMP_TAC std_ss [is_alphanumprime_def,is_alphanumprime_pre_def,LET_DEF,
    isAlphaNumPrime_def,is_alphanum_thm,getNumber_def,isNumber_def]
  \\ SRW_TAC [] [bool2int_def] \\ FULL_SIMP_TAC (srw_ss()) []);

(* isSymbol *)

val (res,is_symbol_def,is_symbol_pre_def) = x64_compile `
  is_symbol (s:zheap_state) =
    let x1 = Number 1 in
      if HD s.input = CHR 96 then (x1,s) else
      if HD s.input = #"!" then (x1,s) else
      if HD s.input = #"%" then (x1,s) else
      if HD s.input = #"&" then (x1,s) else
      if HD s.input = #"$" then (x1,s) else
      if HD s.input = #"#" then (x1,s) else
      if HD s.input = #"+" then (x1,s) else
      if HD s.input = #"-" then (x1,s) else
      if HD s.input = #"/" then (x1,s) else
      if HD s.input = #":" then (x1,s) else
      if HD s.input = #"<" then (x1,s) else
      if HD s.input = #"=" then (x1,s) else
      if HD s.input = #">" then (x1,s) else
      if HD s.input = #"?" then (x1,s) else
      if HD s.input = #"@" then (x1,s) else
      if HD s.input = #"\\" then (x1,s) else
      if HD s.input = #"~" then (x1,s) else
      if HD s.input = CHR 94 then (x1,s) else
      if HD s.input = #"|" then (x1,s) else
      if HD s.input = #"*" then (x1,s) else
        let x1 = Number 0 in (x1,s)`

val is_symbol_thm = prove(
  ``(is_symbol_pre s = s.input <> "") /\
    (is_symbol s = (Number (bool2int (isSymbol (HD s.input))), s))``,
  SIMP_TAC std_ss [is_symbol_def,is_symbol_pre_def,LET_DEF,isSymbol_def]
  \\ SRW_TAC [] [bool2int_def] \\ FULL_SIMP_TAC (srw_ss()) []);

(* is_single_char_symbol *)

val (res,is_single_char_sym_def,is_single_char_sym_pre_def) = x64_compile `
  is_single_char_sym (s:zheap_state) =
    let x1 = Number 1 in
      if HD s.input = #"(" then (x1,s) else
      if HD s.input = #")" then (x1,s) else
      if HD s.input = #"[" then (x1,s) else
      if HD s.input = #"]" then (x1,s) else
      if HD s.input = #"{" then (x1,s) else
      if HD s.input = #"}" then (x1,s) else
      if HD s.input = #"," then (x1,s) else
      if HD s.input = #";" then (x1,s) else
        let x1 = Number 0 in (x1,s)`

val is_single_char_sym_thm = prove(
  ``(is_single_char_sym_pre s = s.input <> "") /\
    (is_single_char_sym s =
       (Number (bool2int (is_single_char_symbol (HD s.input))), s))``,
  SIMP_TAC std_ss [is_single_char_sym_def,is_single_char_sym_pre_def,
    LET_DEF,is_single_char_symbol_def]
  \\ SRW_TAC [] [bool2int_def] \\ FULL_SIMP_TAC (srw_ss()) []);

(* read_while IsAlhpaNumPrime *)

val (res,read_anp_def,read_anp_pre_def) = x64_compile `
  read_anp (s:zheap_state,stack) =
    if s.input = "" then (s,stack) else
      let (x1,s) = is_alphanumprime s in
        if getNumber x1 = 0 then (s,stack) else
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_anp (s,stack)`

val read_anp_thm = prove(
  ``!xs s stack.
      (read_anp_pre (s,MAP Chr xs ++ stack) = T) /\
      (read_anp (s,MAP Chr xs ++ stack) =
        let (text,rest) = read_while isAlphaNumPrime s.input xs in
          (s with input := rest, MAP Chr (REVERSE text) ++ stack))``,
  Induct_on `s.input` \\ SIMP_TAC std_ss [Once EQ_SYM_EQ]
  \\ ONCE_REWRITE_TAC [read_anp_def,read_anp_pre_def]
  THEN1 (FULL_SIMP_TAC std_ss [read_while_def,LET_DEF,s_with_input,
      stringTheory.IMPLODE_EXPLODE_I,REVERSE_REVERSE] \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ NTAC 5 STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,is_alphanumprime_thm,LET_DEF,
       getNumber_def,isNumber_def,HD,TL,bool2int_thm,read_while_def,DROP_1_CONS]
  \\ REVERSE (Cases_on `isAlphaNumPrime h`) \\ FULL_SIMP_TAC std_ss []
  THEN1 (FULL_SIMP_TAC std_ss [read_while_def,LET_DEF,s_with_input,
      stringTheory.IMPLODE_EXPLODE_I,REVERSE_REVERSE] \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ FULL_SIMP_TAC std_ss [EVAL ``bool2int T < 0``]
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := v`)
  \\ FULL_SIMP_TAC (srw_ss()) [] \\ STRIP_TAC
  \\ POP_ASSUM (MP_TAC o Q.SPECL [`h::xs`,`stack`])
  \\ FULL_SIMP_TAC (srw_ss()) [Chr_def]);

(* read_while IsSymbol *)

val (res,read_sym_def,read_sym_pre_def) = x64_compile `
  read_sym (s:zheap_state,stack) =
    if s.input = "" then (s,stack) else
      let (x1,s) = is_symbol s in
        if getNumber x1 = 0 then (s,stack) else
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_sym (s,stack)`

val read_sym_thm = prove(
  ``!xs s stack.
      (read_sym_pre (s,MAP Chr xs ++ stack) = T) /\
      (read_sym (s,MAP Chr xs ++ stack) =
        let (text,rest) = read_while isSymbol s.input xs in
          (s with input := rest, MAP Chr (REVERSE text) ++ stack))``,
  Induct_on `s.input` \\ SIMP_TAC std_ss [Once EQ_SYM_EQ]
  \\ ONCE_REWRITE_TAC [read_sym_def,read_sym_pre_def]
  THEN1 (FULL_SIMP_TAC std_ss [read_while_def,LET_DEF,s_with_input,
      stringTheory.IMPLODE_EXPLODE_I,REVERSE_REVERSE] \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ NTAC 5 STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,is_symbol_thm,LET_DEF,
       getNumber_def,isNumber_def,HD,TL,bool2int_thm,read_while_def,DROP_1_CONS]
  \\ REVERSE (Cases_on `isSymbol h`) \\ FULL_SIMP_TAC std_ss []
  THEN1 (FULL_SIMP_TAC std_ss [read_while_def,LET_DEF,s_with_input,
      stringTheory.IMPLODE_EXPLODE_I,REVERSE_REVERSE] \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ FULL_SIMP_TAC std_ss [EVAL ``bool2int T < 0``]
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := v`)
  \\ FULL_SIMP_TAC (srw_ss()) [] \\ STRIP_TAC
  \\ POP_ASSUM (MP_TAC o Q.SPECL [`h::xs`,`stack`])
  \\ FULL_SIMP_TAC (srw_ss()) [Chr_def]);

(* skip_comment *)

val (res,skip_com_def,skip_com_pre_def) = x64_compile `
  skip_com (x1:bc_value,x2:bc_value,s:zheap_state) =
    if s.input = "" then (x1,x2,s)
    else if HD s.input = #"(" then
           let s = s with input := DROP 1 s.input in
             if s.input = "" then (x1,x2,s) else
             if HD s.input <> #"*" then skip_com (x1,x2,s) else
               let x1 = any_add x1 x2 in
               let s = s with input := DROP 1 s.input in
                 skip_com (x1,x2,s)
    else if HD s.input = #"*" then
           let s = s with input := DROP 1 s.input in
             if s.input = "" then (x1,x2,s) else
             if HD s.input <> #")" then skip_com (x1,x2,s) else
               let s = s with input := DROP 1 s.input in
               if getNumber x1 = 0 then
                 let x2 = Number 0 in
                   (x1,x2,s)
               else
                 let x1 = any_sub x1 x2 in
                   skip_com (x1,x2,s)
    else let s = s with input := DROP 1 s.input in
           skip_com (x1,x2,s)`

val skip_com_thm = prove(
  ``!s d. 0 <= d ==>
      ?d'.
        skip_com_pre (Number d,Number 1,s) /\
        (skip_com (Number d,Number 1,s) =
          case skip_comment s.input d of
            NONE => (d',Number 1,s with input := "")
          | SOME rest => (Number 0,Number 0,s with input := rest))``,
  completeInduct_on `LENGTH s.input`
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [] \\ Cases_on `s.input`
  \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ ONCE_REWRITE_TAC [skip_com_def,skip_com_pre_def]
  \\ SIMP_TAC std_ss [skip_comment_def]
  THEN1 (Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ FULL_SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF] \\ Cases_on `t` THEN1
   (FULL_SIMP_TAC (srw_ss()) [LET_DEF,skip_comment_def]
    \\ SRW_TAC [] []
    \\ ONCE_REWRITE_TAC [skip_com_def,skip_com_pre_def]
    \\ SIMP_TAC std_ss [skip_comment_def]
    \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,skip_comment_def])
  \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL,HD,TL,any_add_def,any_sub_def,getNumber_def]
  \\ SIMP_TAC std_ss [Once skip_comment_def]
  \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def]
  \\ Q.MATCH_ASSUM_RENAME_TAC `s.input = STRING x1 (STRING x2 rest)`
  \\ Cases_on `x1 = #"("` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (Cases_on `x2 = #"*"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
     (FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := rest`)
      \\ FULL_SIMP_TAC (srw_ss()) []
      \\ STRIP_TAC \\ POP_ASSUM (MP_TAC o Q.SPEC `(d+1)`)
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
      \\ `0 <= d + 1` by intLib.COOPER_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.EXISTS_TAC `d''` \\ FULL_SIMP_TAC std_ss [])
    THEN1 (FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := x2 :: rest`)
      \\ FULL_SIMP_TAC (srw_ss()) []
      \\ STRIP_TAC \\ POP_ASSUM (MP_TAC o Q.SPEC `d`)))
  \\ Cases_on `x1 = #"*"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (REVERSE (Cases_on `x2 = #")"`) \\ FULL_SIMP_TAC (srw_ss()) []
    THEN1 (FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := x2 :: rest`)
      \\ FULL_SIMP_TAC (srw_ss()) []
      \\ STRIP_TAC \\ POP_ASSUM (MP_TAC o Q.SPEC `d`))
    \\ Cases_on `d = 0` \\ FULL_SIMP_TAC std_ss []
    THEN1 (FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := rest`)
      \\ FULL_SIMP_TAC (srw_ss()) []
      \\ STRIP_TAC \\ POP_ASSUM (MP_TAC o Q.SPEC `(d-1)`)
      \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
      \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
      \\ `0 <= d - 1 /\ ~(d < 0)` by intLib.COOPER_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.EXISTS_TAC `d''` \\ FULL_SIMP_TAC std_ss []))
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPEC `s with input := x2 :: rest`)
  \\ STRIP_TAC \\ POP_ASSUM (MP_TAC o Q.SPEC `d`)
  \\ FULL_SIMP_TAC (srw_ss()) [])

(* read_string *)

val (res,read_str_def,read_str_pre_def) = x64_compile `
  read_str (x2:bc_value,s:zheap_state,stack) =
    if s.input = "" then
      (x2:bc_value,s,stack) (* error *)
    else if HD s.input = #"\"" then
      let s = s with input := DROP 1 s.input in
      let x2 = Number 1 in (x2,s,stack) (* success *)
    else if HD s.input = #"\n" then
      let s = s with input := DROP 1 s.input in
        (x2,s,stack) (* error *)
    else if HD s.input <> #"\\" then
      let x1 = Number (&ORD (HD s.input)) in
      let stack = x1::stack in
      let s = s with input := DROP 1 s.input in
        read_str (x2,s,stack)
    else
      let s = s with input := DROP 1 s.input in
        if s.input = "" then
          (x2:bc_value,s,stack) (* error *)
        else if HD s.input = #"\\" then
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_str (x2,s,stack)
        else if HD s.input = #"\"" then
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_str (x2,s,stack)
        else if HD s.input = #"n" then
          let x1 = Number 10 in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_str (x2,s,stack)
        else if HD s.input = #"t" then
          let x1 = Number 9 in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
            read_str (x2,s,stack)
        else
          (x2:bc_value,s,stack) (* error *)`

val read_str_thm = prove(
  ``!xs s stack.
      ?ts.
        read_str_pre (Number 0,s,MAP Chr (REVERSE xs) ++ stack) /\
        (read_str (Number 0,s,MAP Chr (REVERSE xs) ++ stack) =
           case read_string s.input xs of
           | (StringS text, rest) =>
               (Number 1,s with input := rest, MAP Chr (REVERSE text) ++ stack)
           | (_, rest) =>
               (Number 0,s with input := rest, MAP Chr (REVERSE ts) ++ stack))``,
  completeInduct_on `LENGTH s.input`
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `s.input`
  \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ ONCE_REWRITE_TAC [read_str_def,read_str_pre_def]
  \\ SIMP_TAC std_ss [Once read_string_def]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF]
  THEN1 (Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``)
    \\ Q.EXISTS_TAC `xs` \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Cases_on `h = #"\""` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ Cases_on `h = #"\n"` \\ FULL_SIMP_TAC (srw_ss()) []
  THEN1 (Q.EXISTS_TAC `xs` \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ REVERSE (Cases_on `h = #"\\"`) \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FIRST_X_ASSUM (MP_TAC o Q.SPECL [`s with input := t`,`xs ++ [h]`,`stack`])
    \\ FULL_SIMP_TAC (srw_ss()) [] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [Chr_def,REVERSE_APPEND,rich_listTheory.REVERSE]
    \\ FULL_SIMP_TAC std_ss [SNOC_APPEND,APPEND,MAP,Chr_def]
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC std_ss [])
  \\ Cases_on `t` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1 METIS_TAC []
  \\ Q.MATCH_ASSUM_RENAME_TAC `s.input = STRING #"\\" (STRING c rest)`
  \\ Cases_on `c = #"\\"` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ Cases_on `c = #"\""` \\ FULL_SIMP_TAC (srw_ss()) []
  THEN TRY
   (FIRST_X_ASSUM (MP_TAC o Q.SPECL [`s with input := rest`,`xs ++ [c]`,`stack`])
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [Chr_def,REVERSE_APPEND,rich_listTheory.REVERSE]
    \\ FULL_SIMP_TAC (srw_ss()) [SNOC_APPEND,APPEND,MAP,Chr_def]
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC std_ss [] \\ NO_TAC)
  \\ Cases_on `c = #"n"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FIRST_X_ASSUM (MP_TAC o Q.SPECL [`s with input := rest`,`xs ++ [#"\n"]`,`stack`])
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [Chr_def,REVERSE_APPEND,rich_listTheory.REVERSE]
    \\ FULL_SIMP_TAC (srw_ss()) [SNOC_APPEND,APPEND,MAP,Chr_def]
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC std_ss [])
  \\ Cases_on `c = #"t"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FIRST_X_ASSUM (MP_TAC o Q.SPECL [`s with input := rest`,`xs ++ [#"\t"]`,`stack`])
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
    \\ STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [Chr_def,REVERSE_APPEND,rich_listTheory.REVERSE]
    \\ FULL_SIMP_TAC (srw_ss()) [SNOC_APPEND,APPEND,MAP,Chr_def]
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC std_ss [])
  \\ Q.EXISTS_TAC `xs` \\ FULL_SIMP_TAC std_ss [])

(* read number *)

val (res,read_num_def,read_num_pre_def) = x64_compile `
  read_num (x1:bc_value,x2:bc_value,s:zheap_state) =
    if s.input = "" then (x1,x2,s) else
    let (x1,s) = is_digit s in
    if getNumber x1 = 0 then (x1,x2,s) else
      let x1 = Number 10 in
      let x1 = any_mul x1 x2 in
      let x2 = x1 in
      let x1 = Number (&(ORD (HD s.input) - 48)) in
      let x1 = any_add x1 x2 in
      let x2 = x1 in
      let s = s with input := DROP 1 s.input in
        read_num (x1,x2,s)`

val l2n_n = prove(
  ``!n b. n < b ==> !ls. l2n b (ls ++ [n]) = l2n b ls + b ** (LENGTH ls) * n``,
  NTAC 2 GEN_TAC THEN STRIP_TAC THEN
  Induct THEN EVAL_TAC THEN SRW_TAC[ARITH_ss][ADD1] THEN
  SRW_TAC[ARITH_ss][LEFT_ADD_DISTRIB,GSYM ADD1,EXP])

val toNum_CONS = prove(
  ``isDigit h ==>
    (toNum (STRING h digits) =
     toNum digits + 10 ** STRLEN digits * (ORD h - 48))``,
  Cases_on`h`\\
  REPEAT (
  Cases_on`n`\\ EVAL_TAC \\ Cases_on`n'`\\EVAL_TAC \\
  FULL_SIMP_TAC (srw_ss()++ARITH_ss)[ADD1] ) THEN
  REPEAT (
  (Cases_on`n` ORELSE Cases_on`n'`)\\ EVAL_TAC \\
  FULL_SIMP_TAC (srw_ss()++ARITH_ss)[ADD1] THEN1 (
    Q.PAT_ABBREV_TAC`d = [x:char]` \\
    Q.ISPECL_THEN[`digits`,`d`]MP_TAC REV_REVERSE_LEM \\
    SRW_TAC[][Abbr`d`] \\ EVAL_TAC \\ SRW_TAC[ARITH_ss][l2n_n,GSYM REVERSE_REV] )));

val read_num_thm = prove(
  ``!digits k s x1.
      EVERY isDigit digits /\ ((rest <> []) ==> ~isDigit (HD rest)) ==>
      ?x1'.
        read_num_pre (x1,Number (& k),s with input := digits ++ rest) /\
        (read_num (x1,Number (& k),s with input := digits ++ rest) =
           (x1',Number (& (toNum digits + 10 ** (LENGTH digits) * k)),
            s with input := rest))``,
  Induct
  \\ SIMP_TAC (srw_ss()) [Once read_num_def,Once read_num_pre_def,LET_DEF] THEN1
   (Cases_on `rest` \\ FULL_SIMP_TAC (srw_ss()) [is_digit_thm,getNumber_def,
      bool2int_thm,any_mul_def,any_add_def,any_sub_def,isNumber_def])
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [is_digit_thm,getNumber_def]
  \\ FULL_SIMP_TAC (srw_ss()) [is_digit_thm,getNumber_def,isNumber_def,
      bool2int_thm,any_mul_def,any_add_def,any_sub_def,isDigit_def]
  \\ `(& (ORD h)) - 48 = & (ORD h - 48)` by ALL_TAC
  THEN1 FULL_SIMP_TAC std_ss [integerTheory.INT_SUB]
  \\ FULL_SIMP_TAC std_ss [integerTheory.INT_ADD]
  \\ SEP_I_TAC "read_num" \\ FULL_SIMP_TAC (srw_ss()) [EXP]
  \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,toNum_CONS,isDigit_def]
  \\ FULL_SIMP_TAC std_ss [EVAL ``bool2int T < 0``]
  \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC, AC ADD_ASSOC ADD_COMM]);


val (res,read_single_def,read_single_pre_def) = x64_compile `
  read_single (x2:bc_value,s:zheap_state,stack) =
    if s.input = "" then
      (x2:bc_value,s,stack) (* error *)
    else if HD s.input = #"\"" then
      let s = s with input := DROP 1 s.input in
      (x2,s,stack)
    else if HD s.input = #"\n" then
      let s = s with input := DROP 1 s.input in
        (x2,s,stack) (* error *)
    else if HD s.input <> #"\\" then
      let x1 = Number (&ORD (HD s.input)) in
      let stack = x1::stack in
      let s = s with input := DROP 1 s.input in
      let x2 = Number 6 in
        (x2,s,stack)
    else
      let s = s with input := DROP 1 s.input in
        if s.input = "" then
          (x2:bc_value,s,stack) (* error *)
        else if HD s.input = #"\\" then
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
          let x2 = Number 6 in
            (x2,s,stack)
        else if HD s.input = #"\"" then
          let x1 = Number (&ORD (HD s.input)) in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
          let x2 = Number 6 in
            (x2,s,stack)
        else if HD s.input = #"n" then
          let x1 = Number 10 in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
          let x2 = Number 6 in
            (x2,s,stack)
        else if HD s.input = #"t" then
          let x1 = Number 9 in
          let stack = x1::stack in
          let s = s with input := DROP 1 s.input in
          let x2 = Number 6 in
            (x2,s,stack)
        else
          (x2:bc_value,s,stack) (* error *)`

val (res,read_char_def,read_char_pre_def) = x64_compile `
  read_char (x2:bc_value,s:zheap_state,stack) =
  let x2 = Number 0 in
  let (x2,s,stack) = read_single (x2,s,stack) in
    if getNumber x2 <> 6 then
        (x2,s,stack)
    else 
    if s.input = "" then
      let x2 = Number 0 in
        (x2,s,stack)
    else 
    if HD s.input = #"\"" then
      let s = s with input := DROP 1 s.input in
        (x2,s,stack)
    else
      let x2 = Number 0 in
      let (x2,s,stack) = read_str (x2,s,stack) in
      let x2 = Number 0 in
        (x2,s,stack)`

val read_string_length = prove(``
  a b c d.
  (read_string a b = (StringS c,d)) 
  STRLEN b  STRLEN c``,
  completeInduct_on `STRLEN a`
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `a`
  \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ pop_assum mp_tac
  \\ ONCE_REWRITE_TAC [read_string_def]
  \\TRY (Cases_on`t`) \\ fs[] \\ rpt IF_CASES_TAC \\fs[]
  \\ strip_tac
  \\ fs[AND_IMP_INTRO]
  \\ res_tac \\ fs[] \\ DECIDE_TAC)
 
val read_string_not_single = prove(``
  x y s.
  (x  #"\""  (read_string (STRING x y) s = (StringS s',r)))  
  STRLEN s' > STRLEN s``,
  rw[]
  \\ fs[Once read_string_def] \\pop_assum mp_tac \\rpt  IF_CASES_TAC
  \\ fs[]
  \\ Cases_on`y`\\ fs[] \\ rpt IF_CASES_TAC
  \\ strip_tac\\imp_res_tac read_string_length\\fs[]\\DECIDE_TAC)

local val fs = fsrw_tac[] in
val read_char_thm = prove(
  ``!s stack.
      ?ts.
        read_char_pre (Number 0,s,stack) /\
        (read_char (Number 0,s,stack) =
           case read_string s.input "" of
           | (StringS [ch], rest) =>
               (Number 6,s with input := rest, (Chr ch) :: stack)
           | (_, rest) =>
               (Number 0,s with input := rest, MAP Chr (REVERSE ts) ++ stack))``,
  REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `s.input`
  \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ REWRITE_TAC [read_char_def,read_char_pre_def,read_single_def]
  \\ SIMP_TAC std_ss [Once read_string_def]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF]
  THEN1 (
    FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_str_pre_def,Once read_str_def]
    \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_str_pre_def,Once read_str_def]
    \\ Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ Cases_on `h = #"\""` \\ FULL_SIMP_TAC (srw_ss()) []
  THEN1 (ntac 3 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_str_pre_def,Once read_str_def,LET_THM]))
  \\ Cases_on `h = #"\n"` \\ FULL_SIMP_TAC (srw_ss()) []
  THEN1 (ntac 3 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_str_pre_def,Once read_str_def,LET_THM]))
  \\ Cases_on `h  #"\\"` \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  THEN1 (
    Cases_on`t`
    THEN1
    (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def] \\ qexists_tac`h` \\ simp[])
    \\
    Cases_on`h'= #"\""` \\ fs[]
    THEN1
    (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def])
    \\
    qpat_abbrev_tac `s' = s with input:= A`>>
    Q.SPECL_THEN [`[h]`,`s'`,`stack`] assume_tac read_str_thm >>
    fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
    Cases_on`read_string s'.input (STRING h "")`>>Cases_on`q`>>fs[Abbr`s'`]>>
    TRY( metis_tac[]) >>
    `STRLEN s'' > STRLEN(STRING h "")` by
      (match_mp_tac (GEN_ALL read_string_not_single)>>
      metis_tac[])>>
    Cases_on`s''`>>fs[]>>
    Cases_on`t`>>fs[]>>
    qexists_tac`h''::h'''::t''`>>fs[])
  \\ Cases_on`t` \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  \\ rpt IF_CASES_TAC \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  THEN1
  (Cases_on`t'` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def] \\ qexists_tac`h`\\simp[])
  \\
  Cases_on`h''= #"\""` \\ fs[]
  THEN1
  (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def])
  \\
  (qpat_abbrev_tac `s' = s with input:=A`>>
  Q.SPECL_THEN [`[#"\\"]`,`s'`,`stack`] assume_tac read_str_thm >>
  fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
  Cases_on`read_string s'.input ("\\")`>>Cases_on`q`>>fs[Abbr`s'`]>>
  TRY( metis_tac[]) >>
  `STRLEN s'' > STRLEN("\\")` by
      (match_mp_tac (GEN_ALL read_string_not_single)>>
      metis_tac[])>>
   Cases_on`s''`>>fs[]>>
   Cases_on`t'`>>fs[]>>
   qcase_tac `SUC (SUC (STRLEN tt)) > 1` >>
   qcase_tac `STRING hh1 (STRING hh2 tt)` >>
   qexists_tac`hh1::hh2::tt`>>simp[]))
  THEN1
  (Cases_on`t'` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def] \\ qexists_tac`#"\""`\\simp[])
  \\
  Cases_on`h''= #"\""` \\ fs[]
  THEN1
  (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def])
  \\
  (qpat_abbrev_tac `s' = s with input:=A`>>
  Q.SPECL_THEN [`[#"\""]`,`s'`,`stack`] assume_tac read_str_thm >>
  fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
  Cases_on`read_string s'.input ("\"")`>>Cases_on`q`>>fs[Abbr`s'`]>>
  TRY( metis_tac[]) >>
  `STRLEN s'' > STRLEN("\"")` by
      (match_mp_tac (GEN_ALL read_string_not_single)>>
      metis_tac[])>>
   Cases_on`s''`>>fs[]>>
   Cases_on`t'`>>fs[]>>
   qexists_tac`h'''::h''''::t''`>>fs[]))
  THEN1
  (Cases_on`t'` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def] \\ qexists_tac`#"\n"`\\simp[])
  \\
  Cases_on`h''= #"\""` \\ fs[]
  THEN1
  (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def])
  \\
  (qpat_abbrev_tac `s' = s with input:=A`>>
  Q.SPECL_THEN [`[#"\n"]`,`s'`,`stack`] assume_tac read_str_thm >>
  fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
  Cases_on`read_string s'.input ("\n")`>>Cases_on`q`>>fs[Abbr`s'`]>>
  TRY( metis_tac[]) >>
  `STRLEN s'' > STRLEN("\n")` by
      (match_mp_tac (GEN_ALL read_string_not_single)>>
      metis_tac[])>>
   Cases_on`s''`>>fs[]>>
   Cases_on`t'`>>fs[]>>
   qexists_tac`h'''::h''''::t''`>>fs[]))
  \\
  (Cases_on`t'` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def] \\ qexists_tac`#"\t"`\\simp[])
  \\
  Cases_on`h''= #"\""` \\ fs[]
  THEN1
  (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def])
  \\
  (qpat_abbrev_tac `s' = s with input:=A`>>
  Q.SPECL_THEN [`[#"\t"]`,`s'`,`stack`] assume_tac read_str_thm >>
  fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
  Cases_on`read_string s'.input ("\t")`>>Cases_on`q`>>fs[Abbr`s'`]>>
  TRY( metis_tac[]) >>
  `STRLEN s'' > STRLEN("\t")` by
      (match_mp_tac (GEN_ALL read_string_not_single)>>
      metis_tac[])>>
   Cases_on`s''`>>fs[]>>
   Cases_on`t'`>>fs[]>>
   qexists_tac`h'''::h''''::t''`>>fs[])))
end

(* next symbol *)

val (res,next_symbol_def,next_symbol_pre_def) = x64_compile `
  next_symbol (x1:bc_value,x2:bc_value,s:zheap_state,stack) =
    let stack = x1 :: stack in
    let stack = x2 :: stack in
    let (x1,stack) = (HD stack, TL stack) in
    let (x2,stack) = (HD stack, TL stack) in
    if s.input = "" then
      let x2 = Number 2 in let x1 = x2 in (x1,x2,s,stack)
    else
    let (x1,s) = is_space s in
    if getNumber x1 <> 0 then
      let s = s with input := DROP 1 s.input in
        next_symbol (x1,x2,s:zheap_state,stack)
    else if HD s.input = #"\"" then
      let s = s with input := DROP 1 s.input in
      let x2 = Number 0 in
      let (x2,s,stack) = read_str (x2,s,stack) in
      let x1 = x2 in
        (x1,x2,s,stack)
    else if HD s.input = #"#" then
      let s = s with input := DROP 1 s.input in
      if s.input = "" then
        let x1 = Number 35 in
        let stack = x1 :: stack in
        let (s,stack) = read_sym (s,stack) in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else
      if HD s.input = #"\"" then
        let s = s with input := DROP 1 s.input in
        let x2 = Number 0 in
        let (x2,s,stack) = read_single (x2,s,stack) in
        if getNumber x2 <> 6 then
          let x1 = x2 in
          (x1,x2,s,stack)
        else 
        if s.input = "" then
          let x2 = Number 0 in
          let x1 = x2 in
            (x1,x2,s,stack)
        else 
        if HD s.input = #"\"" then
          let s = s with input := DROP 1 s.input in
          let x1 = x2 in
            (x1,x2,s,stack)
        else
          let x2 = Number 0 in
          let (x2,s,stack) = read_str (x2,s,stack) in
          let x2 = Number 0 in
          let x1 = x2 in
            (x1,x2,s,stack)
      else
        let x1 = Number 35 in
        let stack = x1 :: stack in
        let (s,stack) = read_sym (s,stack) in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
    else
    let (x1,s) = is_digit s in
    if getNumber x1 <> 0 then
      let x1 = Number 0 in
      let x2 = x1 in
      let (x1,x2,s) = read_num (x1,x2,s) in
      let stack = x2::stack in
      let x2 = Number 3 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else if HD s.input = #"'" then
      let (s,stack) = read_anp (s,stack) in
      let x2 = Number 4 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else if HD s.input = #"~" then
      let s = s with input := DROP 1 s.input in
      if s.input = "" then
        let x1 = Number 126 in
        let stack = x1 :: stack in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else
      let (x1,s) = is_digit s in
      if getNumber x1 <> 0 then
        let x1 = Number 0 in
        let x2 = x1 in
        let (x1,x2,s) = read_num (x1,x2,s) in
        let x1 = Number 0 in
        let x1 = any_sub x1 x2 in
        let stack = x1::stack in
        let x2 = Number 3 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else (* store symbol *)
        let x1 = Number 126 in
        let stack = x1 :: stack in
        let (s,stack) = read_sym (s,stack) in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
    else if HD s.input = #"*" then
      let s = s with input := DROP 1 s.input in
      if s.input = "" then
        let x1 = Number 42 in
        let stack = x1 :: stack in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else if HD s.input = #")" then
        let s = s with input := DROP 1 s.input in
        let x2 = Number 0 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else
        let x1 = Number 42 in
        let stack = x1 :: stack in
        let (s,stack) = read_sym (s,stack) in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
    else if HD s.input = #"(" then
      let s = s with input := DROP 1 s.input in
      if s.input = "" then
        let x1 = Number 40 in
        let stack = x1 :: stack in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else if HD s.input = #"*" then
        let s = s with input := DROP 1 s.input in
        let x1 = Number 0 in
        let x2 = Number 1 in
        let (x1,x2,s) = skip_com (x1,x2,s) in
          if getNumber x2 = 0 then next_symbol (x1,x2,s:zheap_state,stack) else
            let x2 = Number 0 in
            let x1 = x2 in
              (x1,x2,s,stack)
      else
        let x1 = Number 40 in
        let stack = x1 :: stack in
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
    else
    let (x1,s) = is_single_char_sym s in
    if getNumber x1 <> 0 then
      let x1 = Number (&ORD (HD s.input)) in
      let stack = x1::stack in
      let s = s with input := DROP 1 s.input in
      let x2 = Number 4 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else
    let (x1,s) = is_symbol s in
    if getNumber x1 <> 0 then
      let (s,stack) = read_sym (s,stack) in
      let x2 = Number 4 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else if HD s.input = #"_" then
      let x1 = Number (&ORD (HD s.input)) in
      let stack = x1::stack in
      let s = s with input := DROP 1 s.input in
      let x2 = Number 4 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else
    let (x1,s) = is_alpha s in
    if getNumber x1 = 0 then
      let s = s with input := DROP 1 s.input in
      let x2 = Number 0 in
      let x1 = x2 in
        (x1,x2,s,stack)
    else
      let (s,stack) = read_anp (s,stack) in
      if s.input = "" then
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else if HD (s.input) <> #"." then
        let x2 = Number 4 in
        let x1 = x2 in
          (x1,x2,s,stack)
      else
        let x1 = Number (&ORD (HD s.input)) in
        let stack = x1::stack in
        let s = s with input := DROP 1 s.input in
        if s.input = "" then
          let x2 = Number 0 in
          let x1 = x2 in
            (x1,x2,s,stack)
        else
        let (x1,s) = is_alpha s in
        if getNumber x1 <> 0 then
          let (s,stack) = read_anp (s,stack) in
          let x2 = Number 5 in
          let x1 = x2 in
            (x1,x2,s,stack)
        else
        let (x1,s) = is_symbol s in
        if getNumber x1 <> 0 then
          let (s,stack) = read_sym (s,stack) in
          let x2 = Number 5 in
          let x1 = x2 in
            (x1,x2,s,stack)
        else
          let s = s with input := DROP 1 s.input in
          let x2 = Number 0 in
          let x1 = x2 in
            (x1,x2,s,stack)`

val read_string_IMP = prove(
  ``!v x. (read_string v x = (res,r)) ==>
          (res = ErrorS) \/ ?s. res = StringS s``,
  HO_MATCH_MP_TAC read_string_ind
  \\ REPEAT STRIP_TAC \\ POP_ASSUM MP_TAC
  \\ ONCE_REWRITE_TAC [read_string_def]
  \\ SRW_TAC [] []
  \\ Cases_on `v`
  \\ FULL_SIMP_TAC (srw_ss()) []
  \\ Cases_on `t`
  \\ FULL_SIMP_TAC (srw_ss()) []
  \\ METIS_TAC [PAIR_EQ]);

val LIST_PREFIX_PROP = prove(
  ``!xs P. ?xs1 xs2.
             EVERY P xs1 /\ (xs2 <> "" ==> ~P (HD xs2)) /\
             (xs = xs1 ++ xs2)``,
  Induct \\ FULL_SIMP_TAC (srw_ss()) []
  \\ REPEAT STRIP_TAC \\ Cases_on `P h` THEN1
   (FIRST_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `P`)
    \\ Q.LIST_EXISTS_TAC [`h::xs1`,`xs2`]
    \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Q.EXISTS_TAC `[]` \\ Q.EXISTS_TAC `h::xs`
  \\ FULL_SIMP_TAC (srw_ss()) []);

val read_while_lemma = prove(
  ``!xs ys P.
      read_while P xs ys =
        let (zs,rest) = read_while P xs [] in (REVERSE ys ++ zs,rest)``,
  Induct THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ SIMP_TAC std_ss [read_while_def] \\ REPEAT STRIP_TAC
  \\ Cases_on `P h` \\ POP_ASSUM MP_TAC \\ SIMP_TAC (srw_ss()) [LET_DEF]
  \\ SIMP_TAC std_ss [stringTheory.IMPLODE_EXPLODE_I]
  \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
  \\ Cases_on `read_while P xs ""` \\ FULL_SIMP_TAC std_ss [LET_DEF]
  \\ SIMP_TAC (srw_ss()) [APPEND_NIL]);

val read_while_APPEND = prove(
  ``!xs res ys.
      EVERY P xs /\ (ys <> "" ==> ~(P (HD ys))) ==>
       (read_while P (xs ++ ys) res = (REVERSE res ++ xs, ys))``,
  Induct THEN1
   (Cases_on `ys` \\ FULL_SIMP_TAC (srw_ss()) []
    \\ ONCE_REWRITE_TAC [read_while_def]
    \\ SIMP_TAC (srw_ss()) [stringTheory.IMPLODE_EXPLODE_I])
  \\ SIMP_TAC std_ss [APPEND] \\ ONCE_REWRITE_TAC [read_while_def]
  \\ FULL_SIMP_TAC (srw_ss()) []);

val LENGTH_skip_comment = prove(
  ``!d rest. (skip_comment xs d = SOME rest) ==> LENGTH rest <= LENGTH xs``,
  completeInduct_on `LENGTH xs` \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [PULL_FORALL] \\ POP_ASSUM MP_TAC
  \\ Cases_on `xs` \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC std_ss [Once skip_comment_def]
  \\ Cases_on `t` \\ FULL_SIMP_TAC std_ss []
  \\ SIMP_TAC std_ss [Once skip_comment_def]
  \\ FULL_SIMP_TAC (srw_ss()) [AND_IMP_INTRO]
  \\ SRW_TAC [] [] \\ RES_TAC
  \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC);

val ORD_EQ_N = prove(
  ``(ORD c = n) <=> (CHR n = c) /\ n < 256``,
  METIS_TAC[char_BIJ, ORD_BOUND, ORD_CHR]);

val next_symbol_thm = prove(
  ``!xs s stack x1 x2.
      ?ts.
       next_symbol_pre (x1,x2,s,stack) /\
       (next_symbol (x1,x2,s,stack) =
        case next_sym s.input of
        | NONE => (Number 2,Number 2, s with input := "", stack)
        | SOME (CharS ch,rest) =>
          (Number 6, Number 6, s with input := rest, (Chr ch) :: stack)
        | SOME (StringS text, rest) =>
          (Number 1,Number 1,s with input := rest, MAP Chr (REVERSE text) ++ stack)
        | SOME (OtherS text, rest) =>
          (Number 4,Number 4,s with input := rest, MAP Chr (REVERSE text) ++ stack)
        | SOME (LongS text, rest) =>
          (Number 5,Number 5,s with input := rest, MAP Chr (REVERSE text) ++ stack)
        | SOME (ErrorS, rest) =>
          (Number 0,Number 0,s with input := rest, MAP Chr (REVERSE ts) ++ stack)
        | SOME (NumberS n, rest) =>
          (Number 3,Number 3,s with input := rest, Number n :: stack))``,
  completeInduct_on `LENGTH s.input` \\ FULL_SIMP_TAC std_ss [PULL_FORALL]
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC)
  \\ Cases_on `s.input`
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
  \\ ONCE_REWRITE_TAC [next_sym_def,next_symbol_def,next_symbol_pre_def]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,HD,TL] THEN1 (Cases_on `s`
    \\ FULL_SIMP_TAC (srw_ss()) (TypeBase.updates_of ``:zheap_state``))
  \\ Q.MATCH_ASSUM_RENAME_TAC `s.input = STRING h v`
  \\ FULL_SIMP_TAC std_ss [is_symbol_thm,is_space_thm,is_alpha_thm,
       is_digit_thm,getNumber_def,is_single_char_sym_thm,HD,TL]
  \\ FULL_SIMP_TAC std_ss [bool2int_thm]
  \\ Cases_on `isSpace h` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FULL_SIMP_TAC std_ss [PULL_FORALL] \\ SEP_I_TAC "next_symbol"
    \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def,EVAL ``bool2int T < 0``]
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Cases_on `h = #"\""` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FULL_SIMP_TAC (srw_ss()) [isDigit_def]
    \\ ASSUME_TAC (read_str_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
    \\ SEP_I_TAC "read_str" \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Cases_on `read_string v ""` \\ FULL_SIMP_TAC (srw_ss()) []
    \\ IMP_RES_TAC read_string_IMP
    \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def] \\ METIS_TAC [])
  \\ Cases_on `h= #"#"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
  (Cases_on`v=""` \\ fs[] THEN1
       (FULL_SIMP_TAC (srw_ss()) [isDigit_def,isNumber_def
         ,is_single_char_symbol_def,isSymbol_def,read_while_def]
       \\ ASSUME_TAC (read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
       \\ SEP_I_TAC "read_sym" \\ POP_ASSUM MP_TAC
       \\ rw[] \\ fs[Chr_def,LET_THM,read_while_def] \\ metis_tac[])
  (*Save*)
  \\ Cases_on`v`\\ fs[] \\ Cases_on`h'= #"\""` \\fs[isDigit_def,read_single_def]
  THEN1
    (Cases_on`t=""` THEN1 ((fs[getNumber_def,isNumber_def,mkCharS_def,Once read_string_def]))
    \\ Cases_on`t` \\ fs[LET_DEF,getNumber_def,isNumber_def] 
    \\ Cases_on`h''= #"\""`
      THEN1 (fs[getNumber_def,isNumber_def,mkCharS_def,Once read_string_def])
    \\ Cases_on`h''= #"\n"` \\ fs[getNumber_def,isNumber_def]
      THEN1 (fs[Once read_string_def,mkCharS_def])
    \\ Cases_on`h'' #"\\"` \\ fs[getNumber_def,isNumber_def]
      THEN1 (
      fs[getNumber_def,isNumber_def,mkCharS_def]
      \\ simp[Once read_string_def]
      \\ Cases_on`t'` \\fs[]
      THEN1
        (fs [getNumber_def,isNumber_def,Once read_string_def,Chr_def]
        \\ fs[Once read_string_def,mkCharS_def]\\ qexists_tac`h''`
        \\ fs[Chr_def])
      \\ Cases_on`h''' = #"\""` \\fs[]
      THEN1
        ntac 2 (fs[Once read_string_def,mkCharS_def,Chr_def])
      \\
      qpat_abbrev_tac `s' = s with input:= A`>>
      Q.SPECL_THEN [`[h'']`,`s'`,`stack`] assume_tac read_str_thm >>
      fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
      Cases_on`read_string s'.input (STRING h'' "")`>>Cases_on`q`>>fs[Abbr`s'`,mkCharS_def]>>
      TRY( metis_tac[]) >>
      `STRLEN s'' > STRLEN(STRING h'' "")` by
        (match_mp_tac (GEN_ALL read_string_not_single)>>
        metis_tac[])>>
      Cases_on`s''`>>fs[]>>
      Cases_on`t'`>>fs[]>>
      qexists_tac`h''''::h'''''::t''`>>fs[])
      \\ Cases_on`t'` \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
      \\ simp[Once read_string_def,mkCharS_def]
      \\ rpt IF_CASES_TAC \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
      THEN1
      (Cases_on`t` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def,ORD_EQ_N])
      \\ Cases_on`h''''= #"\""` \\ fs[]
      THEN1
      (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def])
      \\
      (qpat_abbrev_tac `s' = s with input:=A`>>
      Q.SPECL_THEN [`[#"\\"]`,`s'`,`stack`] assume_tac read_str_thm >>
      fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
      Cases_on`read_string s'.input ("\\")`>>Cases_on`q`>>fs[Abbr`s'`,mkCharS_def]>>
      TRY( metis_tac[]) >>
      `STRLEN s'' > STRLEN("\\")` by
          (match_mp_tac (GEN_ALL read_string_not_single)>>
          metis_tac[])>>
       Cases_on`s''`>>fs[]>>
       Cases_on`t`>>fs[]>>
       qexists_tac`h'''''::h''''''::t''`>>fs[]))
      THEN1
      (Cases_on`t` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def,ORD_EQ_N])
      \\
      Cases_on`h''''= #"\""` \\ fs[]
      THEN1
      (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def])
      \\
      (qpat_abbrev_tac `s' = s with input:=A`>>
      Q.SPECL_THEN [`[#"\""]`,`s'`,`stack`] assume_tac read_str_thm >>
      fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
      Cases_on`read_string s'.input ("\"")`>>Cases_on`q`>>fs[Abbr`s'`,mkCharS_def]>>
      TRY( metis_tac[]) >>
      `STRLEN s'' > STRLEN("\"")` by
          (match_mp_tac (GEN_ALL read_string_not_single)>>
          metis_tac[])>>
       Cases_on`s''`>>fs[]>>
       Cases_on`t`>>fs[]>>
       qexists_tac`h'''''::h''''''::t''`>>fs[]))
      THEN1
      (Cases_on`t` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def,ORD_EQ_N])
      \\
      Cases_on`h''''= #"\""` \\ fs[]
      THEN1
      (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def])
      \\
      (qpat_abbrev_tac `s' = s with input:=A`>>
      Q.SPECL_THEN [`[#"\n"]`,`s'`,`stack`] assume_tac read_str_thm >>
      fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
      Cases_on`read_string s'.input ("\n")`>>Cases_on`q`>>fs[Abbr`s'`,mkCharS_def]>>
      TRY( metis_tac[]) >>
      `STRLEN s'' > STRLEN("\n")` by
          (match_mp_tac (GEN_ALL read_string_not_single)>>
          metis_tac[])>>
       Cases_on`s''`>>fs[]>>
       Cases_on`t`>>fs[]>>
       qexists_tac`h'''''::h''''''::t''`>>fs[]))
      \\
      (Cases_on`t` THEN1 (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def,ORD_EQ_N])
      \\
      Cases_on`h''''= #"\""` \\ fs[]
      THEN1
      (FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,Once read_string_def,Chr_def,mkCharS_def])
      \\
      (qpat_abbrev_tac `s' = s with input:=A`>>
      Q.SPECL_THEN [`[#"\t"]`,`s'`,`stack`] assume_tac read_str_thm >>
      fs[PULL_EXISTS,PULL_FORALL,Chr_def]>>
      Cases_on`read_string s'.input ("\t")`>>Cases_on`q`>>fs[Abbr`s'`,mkCharS_def]>>
      TRY( metis_tac[]) >>
      `STRLEN s'' > STRLEN("\t")` by
          (match_mp_tac (GEN_ALL read_string_not_single)>>
          metis_tac[])>>
       Cases_on`s''`>>fs[]>>
       Cases_on`t`>>fs[]>>
       qexists_tac`h'''''::h''''''::t''`>>fs[])))
   \\
     (FULL_SIMP_TAC (srw_ss()) [isDigit_def,isNumber_def
         ,is_single_char_symbol_def,isSymbol_def]
       \\ ASSUME_TAC (read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
       \\ SEP_I_TAC "read_sym" \\ POP_ASSUM MP_TAC
       \\ ONCE_REWRITE_TAC [read_while_lemma] \\
       BasicProvers.LET_ELIM_TAC \\ fs[Chr_def]))
  \\ Cases_on `isDigit h` \\ FULL_SIMP_TAC std_ss [] THEN1
   (STRIP_ASSUME_TAC (LIST_PREFIX_PROP |> Q.SPECL [`h::v`,`isDigit`])
    \\ FULL_SIMP_TAC std_ss []
    \\ `s = s with input := s.input` by FULL_SIMP_TAC std_ss [s_with_input]
    \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
    \\ FULL_SIMP_TAC std_ss []
    \\ ASSUME_TAC (GEN_ALL read_num_thm)
    \\ SEP_I_TAC "read_num"
    \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [isNumber_def,EVAL ``bool2int T < 0``]
    \\ Cases_on `xs1` \\ FULL_SIMP_TAC (srw_ss()) []
    THEN1 (Cases_on `xs2` \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC (srw_ss()) [read_while_APPEND])
  \\ Cases_on `h = #"'"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (ASM_SIMP_TAC std_ss [read_anp_thm |> Q.SPEC `[]` |> RW [MAP,APPEND]]
    \\ SIMP_TAC std_ss [read_while_def,EVAL ``isAlphaNumPrime #"'"``]
    \\ Cases_on `read_while isAlphaNumPrime v "'"`
    \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,isNumber_def])
  \\ Cases_on `h = #"~"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (Cases_on `v = ""` \\ FULL_SIMP_TAC std_ss []
    THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [] \\ SRW_TAC[][read_while_def] \\ EVAL_TAC)
    \\ Cases_on `isDigit (HD v)` \\ FULL_SIMP_TAC std_ss [] THEN1
     (STRIP_ASSUME_TAC (LIST_PREFIX_PROP |> Q.SPECL [`v`,`isDigit`])
      \\ FULL_SIMP_TAC std_ss []
      \\ ASSUME_TAC (GEN_ALL read_num_thm)
      \\ SEP_I_TAC "read_num"
      \\ POP_ASSUM MP_TAC \\ FULL_SIMP_TAC std_ss [] \\ STRIP_TAC
      \\ FULL_SIMP_TAC std_ss [EVAL ``bool2int T < 0``]
      \\ FULL_SIMP_TAC (srw_ss()) [read_while_APPEND,isNumber_def]
      \\ FULL_SIMP_TAC std_ss [any_sub_def,getNumber_def]
      \\ AP_TERM_TAC \\ intLib.COOPER_TAC)
    \\ SIMP_TAC std_ss [EVAL ``is_single_char_symbol #"~"``]
    \\ SIMP_TAC std_ss [EVAL ``isSymbol #"~"``]
    \\ ASSUME_TAC (read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
    \\ SEP_I_TAC "read_sym" \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,isNumber_def] \\ STRIP_TAC
    \\ Cases_on `read_while isSymbol v ""`
    \\ ONCE_REWRITE_TAC [read_while_lemma]
    \\ FULL_SIMP_TAC std_ss [LET_DEF,EVAL ``REVERSE [x]``]
    \\ SIMP_TAC (srw_ss()) [Chr_def])
  \\ Cases_on `h = #"*"` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (Cases_on `v` \\ FULL_SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [EVAL ``is_single_char_symbol #"*"``]
    \\ SIMP_TAC std_ss [EVAL ``isSymbol #"*"``,isNumber_def]
    THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [] \\ SRW_TAC[][read_while_def] \\ EVAL_TAC)
    \\ Q.MATCH_ASSUM_RENAME_TAC `s.input = STRING #"*" (STRING x xs)`
    \\ Cases_on `x = #")"` \\ FULL_SIMP_TAC std_ss []
    THEN1 (FULL_SIMP_TAC (srw_ss()) [])
    \\ ASSUME_TAC (read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
    \\ SEP_I_TAC "read_sym" \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF] \\ STRIP_TAC
    \\ Cases_on `read_while isSymbol (x::xs) ""`
    \\ ONCE_REWRITE_TAC [read_while_lemma]
    \\ FULL_SIMP_TAC std_ss [LET_DEF,EVAL ``REVERSE [x]``]
    \\ SIMP_TAC (srw_ss()) [Chr_def])
  \\ Cases_on `h = #"("` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (Cases_on `v` \\ FULL_SIMP_TAC (srw_ss()) []
    THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
    \\ Q.MATCH_ASSUM_RENAME_TAC `s.input = STRING #"(" (STRING x xs)`
    \\ REVERSE (Cases_on `x = #"*"`) \\ FULL_SIMP_TAC (srw_ss()) []
    THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
    \\ ASSUME_TAC skip_com_thm
    \\ SEP_I_TAC "skip_com"
    \\ Cases_on `skip_comment xs 0`
    \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
    \\ CONV_TAC (DEPTH_CONV PairRules.PBETA_CONV)
    \\ Q.MATCH_ASSUM_RENAME_TAC `skip_comment xs 0 = SOME rest`
    \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL
         [`s with input := rest`,`stack`,`Number 0`,`Number 0`])
    \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) []
      \\ IMP_RES_TAC LENGTH_skip_comment \\ DECIDE_TAC)
    \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss []
    \\ Q.EXISTS_TAC `ts` \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Cases_on `is_single_char_symbol h`
  \\ FULL_SIMP_TAC (srw_ss()) [Chr_def,isNumber_def,EVAL ``bool2int T < 0``]
  \\ Cases_on `isSymbol h` \\ FULL_SIMP_TAC (srw_ss()) [Chr_def] THEN1
   (ASSUME_TAC (read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF])
    \\ SEP_I_TAC "read_sym" \\ POP_ASSUM MP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,isNumber_def] \\ STRIP_TAC
    \\ ASM_SIMP_TAC std_ss [read_while_def]
    \\ Cases_on `read_while isSymbol v [h]`
    \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Cases_on `h = #"_"` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ SIMP_TAC std_ss [EVAL ``isAlpha #"_"``]
  THEN1 (EVAL_TAC \\ SIMP_TAC std_ss [])
  \\ REVERSE (Cases_on `isAlpha h`) \\ FULL_SIMP_TAC (srw_ss()) []
  \\ SIMP_TAC std_ss [read_anp_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF]]
  \\ FULL_SIMP_TAC std_ss []
  \\ `isAlphaNumPrime h` by
       FULL_SIMP_TAC std_ss [isAlphaNumPrime_def,isAlphaNum_def]
  \\ ASM_SIMP_TAC std_ss [read_while_def]
  \\ Cases_on `(read_while isAlphaNumPrime v (STRING h ""))`
  \\ Cases_on `r` \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,isNumber_def]
  \\ Q.MATCH_ASSUM_RENAME_TAC
      `read_while isAlphaNumPrime v (STRING h "") = (q,STRING h1 rest)`
  \\ REVERSE (Cases_on `h1 = #"."`) THEN1 FULL_SIMP_TAC (srw_ss()) [LET_DEF]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF]
  \\ Cases_on `rest` \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF]
  THEN1 (Q.EXISTS_TAC `q ++ [CHR 46]` \\ FULL_SIMP_TAC (srw_ss()) [Chr_def])
  \\ Cases_on `isAlpha h'` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (`isAlphaNumPrime h'` by
       FULL_SIMP_TAC std_ss [isAlphaNumPrime_def,isAlphaNum_def]
    \\ ASM_SIMP_TAC std_ss [read_while_def,isNumber_def]
    \\ Cases_on `read_while isAlphaNumPrime t (STRING h' "")`
    \\ FULL_SIMP_TAC (srw_ss()) [Chr_def])
  \\ SIMP_TAC std_ss [read_sym_thm |> Q.SPEC `[]` |> RW [MAP,APPEND,REVERSE_DEF]]
  \\ Cases_on `isSymbol h'` \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (ASM_SIMP_TAC std_ss [read_while_def,LET_DEF,isNumber_def]
    \\ Cases_on `(read_while isSymbol t (STRING h' ""))`
    \\ FULL_SIMP_TAC (srw_ss()) [Chr_def])
  THEN1 (Q.EXISTS_TAC `q ++ [CHR 46]` \\ FULL_SIMP_TAC (srw_ss()) [Chr_def]))
  |> SIMP_RULE std_ss [];

(* cons list *)

val (res,cons_list_aux_def,cons_list_aux_pre_def) = x64_compile `
  cons_list_aux (x1,x2:bc_value,stack) =
    let x2 = x1 in
    let (x1,stack) = (HD stack, TL stack) in
      if isBlock x1 then (x1,x2,stack) else
        let x1 = BlockCons (x1,x2) in
          cons_list_aux (x1,x2,stack)`

val (res,cons_list_def,cons_list_pre_def) = x64_compile `
  cons_list (stack) =
    let x1 = BlockNil in
    let x2 = BlockNil in
    let (x1,x2,stack) = cons_list_aux (x1,x2,stack) in
      (x1,x2,stack)`

val cons_list_aux_thm = prove(
  ``!xs ys x2.
      cons_list_aux_pre (BlockList ys,x2,MAP Chr xs ++ BlockNil::stack) /\
      (cons_list_aux (BlockList ys,x2,MAP Chr xs ++ BlockNil::stack) =
         (BlockNil,BlockList (MAP Chr (REVERSE xs) ++ ys),stack))``,
  Induct \\ ONCE_REWRITE_TAC [cons_list_aux_def,cons_list_aux_pre_def]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,EVAL ``isBlock BlockNil``]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,EVAL ``isBlock (Chr c)``]
  \\ SIMP_TAC std_ss [Once (GSYM BlockList_def)]
  \\ ASM_SIMP_TAC std_ss [] \\ SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
  \\ SIMP_TAC std_ss [Once (GSYM BlockList_def)]
  \\ ASM_SIMP_TAC std_ss [] \\ SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
  \\ EVAL_TAC \\ SIMP_TAC std_ss []) |> Q.SPECL [`xs`,`[]`]
  |> SIMP_RULE std_ss [BlockList_def,APPEND_NIL];

val cons_list_thm = prove(
  ``cons_list_pre (MAP Chr xs ++ BlockNil::stack) /\
    (cons_list (MAP Chr xs ++ BlockNil::stack) =
       (BlockNil,BlockList (MAP Chr (REVERSE xs)),stack))``,
  SIMP_TAC std_ss [cons_list_def,cons_list_pre_def,cons_list_aux_thm,LET_DEF]);

(* semi_sym *)

val semi_sym_def = Define `
  (semi_sym (OtherS s) =
    if s = ";" then Number 1 else
    if MEM s ["let";"struct";"sig";"("] then Number 2 else
    if MEM s [")";"end"] then Number 3 else Number 0) /\
  (semi_sym _ = Number 0)`;

val (res,semi_len_def,semi_len_pre_def) = x64_compile `
  semi_len (stack:bc_value list) =
    let x1 = HD stack in
    if isBlock x1 then let x1 = Number 0 in (x1,stack) else
    let x1 = EL 1 stack in
    if isBlock x1 then let x1 = Number 1 in (x1,stack) else
    let x1 = EL 2 stack in
    if isBlock x1 then let x1 = Number 2 in (x1,stack) else
    let x1 = EL 3 stack in
    if isBlock x1 then let x1 = Number 3 in (x1,stack) else
    let x1 = EL 4 stack in
    if isBlock x1 then let x1 = Number 4 in (x1,stack) else
    let x1 = EL 5 stack in
    if isBlock x1 then let x1 = Number 5 in (x1,stack) else
    let x1 = EL 6 stack in
    if isBlock x1 then let x1 = Number 6 in (x1,stack) else
      let x1 = Number 7 in (x1,stack)`

val LIST_CASES = prove(
  ``!xs. (xs = []:string) \/
         (?x1. xs = [x1]) \/
         (?x1 x2. xs = [x1;x2]) \/
         (?x1 x2 x3. xs = [x1;x2;x3]) \/
         (?x1 x2 x3 x4. xs = [x1;x2;x3;x4]) \/
         (?x1 x2 x3 x4 x5. xs = [x1;x2;x3;x4;x5]) \/
         (?x1 x2 x3 x4 x5 x6. xs = [x1;x2;x3;x4;x5;x6]) \/
         (?x1 x2 x3 x4 x5 x6 x7 ts. xs = x1::x2::x3::x4::x5::x6::x7::ts)``,
  Cases \\ FULL_SIMP_TAC (srw_ss()) []
  \\ REPEAT (Cases_on `t` \\ FULL_SIMP_TAC (srw_ss()) []
             \\ Cases_on `t'` \\ FULL_SIMP_TAC (srw_ss()) []));

val APPEND_LEMMA = prove(
  ``(xs ++ ys ++ zs ++ qs = xs ++ (ys ++ zs) ++ qs:'a list) /\
    ([Chr c] = MAP Chr [c]) /\
    (Chr c :: MAP Chr cs = MAP Chr (c::cs))``,
  SIMP_TAC std_ss [APPEND_ASSOC,MAP]);

val semi_len_thm = prove(
  ``semi_len_pre (MAP Chr (REVERSE xs) ++ BlockNil::stack) /\
    (semi_len (MAP Chr (REVERSE xs) ++ BlockNil::stack) =
      (if LENGTH xs < 7 then Number (& (LENGTH xs))
       else Number 7,MAP Chr (REVERSE xs) ++ BlockNil::stack))``,
  SIMP_TAC std_ss [semi_len_def,semi_len_pre_def,LET_DEF]
  \\ Cases_on `xs` \\ FULL_SIMP_TAC (srw_ss()) []
  \\ ASM_SIMP_TAC (srw_ss()) [Chr_def,getNumber_def,isBlock_def,
        BlockNil_def,canCompare_def,isNumber_def,ADD1,APPEND,GSYM ORD_11]
  \\ NTAC 4 (TRY (Cases_on `t`) \\ TRY (Cases_on `t'`)
      \\ ASM_SIMP_TAC (srw_ss()) [Chr_def,getNumber_def,isBlock_def,
           BlockNil_def,canCompare_def,isNumber_def,ADD1,APPEND,GSYM ORD_11]
      THEN1 DECIDE_TAC) THEN1 DECIDE_TAC
  \\ FULL_SIMP_TAC std_ss [GSYM ADD_ASSOC,APPEND_LEMMA,APPEND]
  \\ FULL_SIMP_TAC std_ss [GSYM Chr_def,APPEND_LEMMA]
  \\ (LIST_CASES |> Q.SPEC `REVERSE t` |> STRIP_ASSUME_TAC)
  \\ ASM_SIMP_TAC std_ss [] \\ EVAL_TAC \\ SRW_TAC [] [] \\ DECIDE_TAC);

val (res,semi_symbol_def,semi_symbol_pre_def) = x64_compile `
  semi_symbol (stack:bc_value list) =
    let x3 = Number 0 in
    let (x1,stack) = semi_len stack in
    if getNumber x1 = 0 then (x3,stack) else
    if getNumber x1 = 1 then
      let x1 = HD stack in
        if getNumber x1 = 59 (* ; *) then let x3 = Number 1 in (x3,stack) else
        if getNumber x1 = 40 (* ( *) then let x3 = Number 2 in (x3,stack) else
        if getNumber x1 = 41 (* ) *)then let x3 = Number 3 in (x3,stack) else
          (x3,stack) else
    if getNumber x1 = 2 then (x3,stack) else
    if getNumber x1 = 3 then
      let x1 = HD stack in
      if getNumber x1 = 116 (* t *) then
        let x1 = EL 1 stack in if getNumber x1 <> 101 (* e *) then (x3,stack) else
        let x1 = EL 2 stack in if getNumber x1 <> 108 (* l *) then (x3,stack) else
        let x3 = Number 2 in
          (x3,stack)
      else if getNumber x1 = 103 (* g *) then
        let x1 = EL 1 stack in if getNumber x1 <> 105 (* i *) then (x3,stack) else
        let x1 = EL 2 stack in if getNumber x1 <> 115 (* s *) then (x3,stack) else
        let x3 = Number 2 in
          (x3,stack)
      else if getNumber x1 = 100 (* d *) then
        let x1 = EL 1 stack in if getNumber x1 <> 110 (* n *) then (x3,stack) else
        let x1 = EL 2 stack in if getNumber x1 <> 101 (* e *) then (x3,stack) else
        let x3 = Number 3 in
          (x3,stack)
      else
        (x3,stack)
    else
    if getNumber x1 = 4 then (x3,stack) else
    if getNumber x1 = 5 then (x3,stack) else
    if getNumber x1 = 6 then
      let x1 = HD stack   in if getNumber x1 <> 116 (* t *) then (x3,stack) else
      let x1 = EL 1 stack in if getNumber x1 <>  99 (* c *) then (x3,stack) else
      let x1 = EL 2 stack in if getNumber x1 <> 117 (* u *) then (x3,stack) else
      let x1 = EL 3 stack in if getNumber x1 <> 114 (* r *) then (x3,stack) else
      let x1 = EL 4 stack in if getNumber x1 <> 116 (* t *) then (x3,stack) else
      let x1 = EL 5 stack in if getNumber x1 <> 115 (* s *) then (x3,stack) else
      let x3 = Number 2 in
        (x3,stack)
    else
      (x3,stack)`

val (res,semi_symbol'_def,semi_symbol'_pre_def) = x64_compile `
  semi_symbol' (stack:bc_value list) =
    let (x3,stack) = semi_symbol stack in
    let x1 = x3 in
      (x1,x3,stack)`

val semi_symbol_thm = prove(
  ``semi_symbol_pre (MAP Chr (REVERSE xs) ++ BlockNil::stack) /\
    (semi_symbol (MAP Chr (REVERSE xs) ++ BlockNil::stack) =
      (semi_sym (OtherS xs),MAP Chr (REVERSE xs) ++ BlockNil::stack))``,
  FULL_SIMP_TAC std_ss [semi_symbol_def,semi_symbol_pre_def,LET_DEF,
    semi_sym_def,semi_len_thm]
  \\ (LIST_CASES |> SPEC_ALL |> STRIP_ASSUME_TAC)
  \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  \\ `!k. ~(SUC (SUC (SUC (SUC (SUC (SUC (SUC k)))))) < 7)` by DECIDE_TAC
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC (srw_ss()) [Chr_def,isNumber_def,
      getNumber_def,GSYM ORD_11] \\ TRY DECIDE_TAC
  \\ (LIST_CASES |> Q.SPEC `REVERSE ts` |> STRIP_ASSUME_TAC)
  \\ ASM_SIMP_TAC std_ss [] \\ EVAL_TAC
  \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def]);


(* next symbol -- final package up *)

val (res,next_sym_full_def,next_sym_full_pre_def) = x64_compile `
  next_sym_full (s,stack) =
    let x3 = Number 0 in
    let x1 = BlockNil in
    let x2 = x1 in
    let stack = x1::stack in
    let (x1,x2,s,stack) = next_symbol (x1,x2,s,stack) in
      if getNumber x1 = 2 then
        let (x1,stack) = (HD stack, TL stack) in
        let x2 = Number 0 in
          (x1,x2,x3,s,stack)
      else if getNumber x1 = 6 then
        let (x1,stack) = (HD stack,TL stack) in
        let x1 = BlockCharS x1 in
        let (x2,stack) = (HD stack, TL stack) in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)
      else if getNumber x1 = 1 then
        let (x1,x2,stack) = cons_list stack in
        let x1 = x2 in
        let x1 = BlockStringS x1 in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)
      else if getNumber x1 = 4 then
        let (x1,x3,stack) = semi_symbol' stack in
        let (x1,x2,stack) = cons_list stack in
        let x1 = x2 in
        let x1 = BlockOtherS x1 in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)
      else if getNumber x1 = 5 then
        let (x1,x2,stack) = cons_list stack in
        let x1 = x2 in
        let x1 = BlockLongS x1 in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)
      else if getNumber x1 = 3 then
        let (x1,stack) = (HD stack, TL stack) in
        let x1 = BlockNumberS x1 in
        let (x2,stack) = (HD stack, TL stack) in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)
      else
        let (x1,x2,stack) = cons_list stack in
        let x1 = BlockErrorS in
        let x2 = Number 1 in
          (x1,x2,x3,s,stack)`

val next_sym_full_thm = prove(
  ``next_sym_full_pre (s,stack) /\
    (next_sym_full (s,stack) =
     case next_sym s.input of
     | NONE => (BlockNil, Number 0, Number 0, s with input := "", stack)
     | SOME (t,rest) => (BlockSym t, Number 1, semi_sym t,
                         s with input := rest, stack))``,
  SIMP_TAC std_ss [next_sym_full_def,next_sym_full_pre_def,LET_DEF]
  \\ ASSUME_TAC next_symbol_thm
  \\ SEP_I_TAC "next_symbol" \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `next_sym s.input` \\ FULL_SIMP_TAC std_ss [] THEN1 EVAL_TAC
  \\ Cases_on `x` \\ FULL_SIMP_TAC std_ss []
  \\ Cases_on `q` \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def]
  \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def,BlockSym_def,
       cons_list_thm,semi_symbol_thm,semi_symbol'_def,semi_symbol'_pre_def]
  \\ FULL_SIMP_TAC std_ss [semi_sym_def,LET_DEF,MEM,cons_list_thm]
  \\ FULL_SIMP_TAC (srw_ss()) []);

(* lex_until *)

val (res,lex_until_def,lex_until_pre_def) = x64_compile `
  lex_until (x1,x2,x3,x4:bc_value,s,stack) =
    let (x1,x2,x3,x4) = ID (x1,x2,x3,x4) in
    let (x1,x2,x3,s,stack) = next_sym_full (s,stack) in
      if getNumber x2 = 0 then (* next_sym returned NONE *)
        (x1,x2,x3,x4,s,stack)
      else
        let stack = x1 :: stack in
          if getNumber x3 = 0 then (* nothing of interest *)
            lex_until (x1,x2,x3,x4,s,stack)
          else if getNumber x3 = 2 then (* some form of open paren *)
            let x1 = x4 in
            let x2 = Number 1 in
            let x1 = any_add x1 x2 in
            let x4 = x1 in
              lex_until (x1,x2,x3,x4,s,stack)
          else if getNumber x3 = 3 then (* some form of close paren *)
            if getNumber x4 = 0 then
              lex_until (x1,x2,x3,x4,s,stack)
            else
              let x1 = x4 in
              let x2 = Number 1 in
              let x1 = any_sub x1 x2 in
              let x4 = x1 in
                lex_until (x1,x2,x3,x4,s,stack)
          else (* must be a semicolon *)
            if getNumber x4 = 0 then
              let x2 = Number 1 in
                (x1,x2,x3,x4,s,stack)
            else
              lex_until (x1,x2,x3,x4,s,stack)`

val isNumber_semi_sym = prove(
  ``!q. isNumber (semi_sym q)``,
  Cases \\ EVAL_TAC \\ SRW_TAC [] [] \\ EVAL_TAC);

val getNumber_semi_sym = prove(
  ``(getNumber (semi_sym s) = k) <=> (semi_sym s = Number k)``,
  ASSUME_TAC (Q.SPEC `s` isNumber_semi_sym)
  \\ Cases_on `semi_sym s`
  \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def,getNumber_def]);

val lex_until_thm = prove(
  ``!acc d xs s x1 x2 x3 stack. (xs = s.input) ==>
      ?y1 y2 y3 fs.
        lex_until_pre (x1,x2,x3,Number (& d),s,MAP BlockSym acc ++ stack) /\
        (lex_until (x1,x2,x3,Number (& d),s,MAP BlockSym acc ++ stack) =
          case lex_aux_alt acc d s.input of
          | NONE => (y1,Number 0,y2,y3,s with input := "",MAP BlockSym fs ++ stack)
          | SOME (ts,rest) => (y1,Number 1,y2,y3,s with input := rest,
                               MAP BlockSym (REVERSE ts) ++ stack))``,
  HO_MATCH_MP_TAC lex_aux_alt_ind \\ REPEAT STRIP_TAC
  \\ ONCE_REWRITE_TAC [lex_until_def,lex_until_pre_def]
  \\ FULL_SIMP_TAC std_ss [LET_DEF,ID_def]
  \\ ASM_SIMP_TAC std_ss [next_sym_full_thm,Once lex_aux_alt_def,LET_DEF]
  \\ Cases_on `next_sym s.input`
  \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def,isNumber_semi_sym]
  THEN1 (Q.EXISTS_TAC `acc` \\ FULL_SIMP_TAC std_ss [])
  \\ Cases_on `x` \\ FULL_SIMP_TAC (srw_ss()) [getNumber_def,isNumber_def]
  \\ REVERSE (Cases_on `?tt. q = OtherS tt`) THEN1
   (FULL_SIMP_TAC std_ss []
    \\ `getNumber (semi_sym q) = 0` by ALL_TAC THEN1
      (Cases_on `q` \\ EVAL_TAC \\ FULL_SIMP_TAC (srw_ss()) [])
    \\ FULL_SIMP_TAC std_ss [isNumber_semi_sym]
    \\ SEP_I_TAC "lex_until" \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`y1`,`y2`,`y3`,`fs`]
    \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ FULL_SIMP_TAC (srw_ss()) []
  \\ `((tt = ";") <=> (semi_sym (OtherS tt) = Number 1)) /\
      ((tt = "let") \/ (tt = "struct") \/ (tt = "sig") \/ (tt = "(")
       <=> (semi_sym (OtherS tt) = Number 2)) /\
      ((tt = ")") \/ (tt = "end") <=> (semi_sym (OtherS tt) = Number 3))` by ALL_TAC
  THEN1 (REPEAT STRIP_TAC \\ SIMP_TAC std_ss [semi_sym_def] \\ SRW_TAC [] [])
  \\ FULL_SIMP_TAC (srw_ss()) [getNumber_semi_sym]
  \\ Cases_on `tt = ";"` THEN1
    (FULL_SIMP_TAC (srw_ss()) [semi_sym_def,getNumber_def,isNumber_def]
     \\ Cases_on `d = 0` \\ FULL_SIMP_TAC (srw_ss()) []
     \\ SEP_I_TAC "lex_until" \\ FULL_SIMP_TAC (srw_ss()) []
     \\ Q.LIST_EXISTS_TAC [`y1`,`y2`,`y3`,`fs`]
     \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ FULL_SIMP_TAC std_ss []
  \\ NTAC 3 (POP_ASSUM (K ALL_TAC))
  \\ Cases_on `semi_sym (OtherS tt) = Number 0`
  \\ FULL_SIMP_TAC (srw_ss()) [isNumber_def] THEN1
   (POP_ASSUM MP_TAC
    \\ SIMP_TAC std_ss [semi_sym_def]
    \\ SRW_TAC [] []
    \\ FULL_SIMP_TAC std_ss []
    \\ SEP_I_TAC "lex_until" \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`y1`,`y2`,`y3`,`fs`]
    \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ Cases_on `semi_sym (OtherS tt) = Number 2`
  \\ FULL_SIMP_TAC (srw_ss()) [] THEN1
   (FULL_SIMP_TAC std_ss [any_add_def,getNumber_def,integerTheory.INT_ADD]
    \\ SEP_I_TAC "lex_until" \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`y1`,`y2`,`y3`,`fs`]
    \\ FULL_SIMP_TAC (srw_ss()) [])
  \\ `semi_sym (OtherS tt) = Number 3` by ALL_TAC THEN1
   (SRW_TAC [] [semi_sym_def,MEM] \\ FULL_SIMP_TAC (srw_ss()) [semi_sym_def,MEM])
  \\ FULL_SIMP_TAC (srw_ss()) [PULL_FORALL]
  \\ Cases_on `d = 0` \\ FULL_SIMP_TAC std_ss [] THEN1
   (SEP_I_TAC "lex_until" \\ POP_ASSUM MP_TAC \\ MATCH_MP_TAC IMP_IMP
    THEN1 (SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
      \\ FULL_SIMP_TAC (srw_ss()) [semi_sym_def]))
  \\ FULL_SIMP_TAC std_ss [any_sub_def,getNumber_def,
       integerTheory.INT_SUB,DECIDE ``n <> 0 ==> 1 <= n:num``]
  \\ SEP_I_TAC "lex_until" \\ POP_ASSUM MP_TAC \\ MATCH_MP_TAC IMP_IMP
  THEN1 (SIMP_TAC (srw_ss()) [] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [semi_sym_def]));

(* cons_list_alt *)

val (res,cons_list_alt_aux_def,cons_list_alt_aux_pre_def) = x64_compile `
  cons_list_alt_aux (x1,x2:bc_value,stack) =
    let x2 = x1 in
    let (x1,stack) = (HD stack, TL stack) in
      if ~isBlock x1 then (x1,x2,stack) else
        let x1 = BlockCons (x1,x2) in
          cons_list_alt_aux (x1,x2,stack)`

val (res,cons_list_alt_def,cons_list_alt_pre_def) = x64_compile `
  cons_list_alt (stack) =
    let x1 = BlockNil in
    let x2 = BlockNil in
    let (x1,x2,stack) = cons_list_alt_aux (x1,x2,stack) in
      (x1,x2,stack)`

val isBlock_BkockSym = prove(
  ``!s. isBlock (BlockSym s)``,
  Cases \\ EVAL_TAC);

val cons_list_alt_aux_thm = prove(
  ``!xs ys x2.
      cons_list_alt_aux_pre (BlockList ys,x2,MAP BlockSym xs ++ Number n::stack) /\
      (cons_list_alt_aux (BlockList ys,x2,MAP BlockSym xs ++ Number n::stack) =
         (Number n,BlockList (MAP BlockSym (REVERSE xs) ++ ys),stack))``,
  Induct \\ ONCE_REWRITE_TAC [cons_list_alt_aux_def,cons_list_alt_aux_pre_def]
  \\ FULL_SIMP_TAC (srw_ss()) [LET_DEF,isBlock_BkockSym,isBlock_def,canCompare_def]
  \\ SIMP_TAC std_ss [Once (GSYM BlockList_def)]
  \\ ASM_SIMP_TAC std_ss [] \\ SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
  \\ SIMP_TAC std_ss [Once (GSYM BlockList_def)]
  \\ ASM_SIMP_TAC std_ss [] \\ SIMP_TAC std_ss [APPEND,GSYM APPEND_ASSOC]
  \\ Cases \\ EVAL_TAC \\ SIMP_TAC std_ss []) |> Q.SPECL [`xs`,`[]`]
  |> SIMP_RULE std_ss [BlockList_def,APPEND_NIL];

val cons_list_alt_thm = prove(
  ``cons_list_alt_pre (MAP BlockSym xs ++ Number n::stack) /\
    (cons_list_alt (MAP BlockSym xs ++ Number n::stack) =
       (Number n,BlockList (MAP BlockSym (REVERSE xs)),stack))``,
  SIMP_TAC std_ss [cons_list_alt_def,cons_list_alt_pre_def,
    cons_list_alt_aux_thm,LET_DEF]);

(* lex_until_semi *)

val (lex_until_semi_res,lex_until_semi_def,lex_until_semi_pre_def) = x64_compile `
  lex_until_semi (x1,x3,s,stack) =
    let stack = x1 :: stack in
    let stack = x3 :: stack in
    let x1 = Number 0 in
    let stack = x1 :: stack in
    let x2 = x1 in
    let x3 = x1 in
    let x4 = x1 in
    let (x1,x2,x3,x4,s,stack) = lex_until (x1,x2,x3,x4,s,stack) in
    let x4 = x2 in
    let (x1,x2,stack) = cons_list_alt stack in
    let (x3,stack) = (HD stack,TL stack) in
    let (x1,stack) = (HD stack,TL stack) in
      if getNumber x4 = 0 then
        let x2 = x4 in (x1,x2,x3,x4,s,stack)
      else
        (x1,x2,x3,x4,s,stack)`

val lex_until_semi_thm = prove(
  ``lex_until_semi_pre (x1,x3,s,stack) /\
    (lex_until_semi (x1,x3,s,stack) =
      case lex_until_top_semicolon_alt s.input of
      | NONE => (x1,Number 0,x3,Number 0,s with input := "",stack)
      | SOME (ts,rest) => (x1,BlockList (MAP BlockSym ts),x3,Number 1,
                           s with input := rest,stack))``,
  SIMP_TAC std_ss [lex_until_semi_def,lex_until_semi_pre_def,LET_DEF]
  \\ ASSUME_TAC (lex_until_thm |> Q.SPECL [`[]`,`0`])
  \\ FULL_SIMP_TAC std_ss [MAP,APPEND]
  \\ SEP_I_TAC "lex_until" \\ FULL_SIMP_TAC std_ss []
  \\ REPEAT (POP_ASSUM (K ALL_TAC))
  \\ SIMP_TAC std_ss [lex_until_top_semicolon_alt_def]
  \\ Cases_on `lex_aux_alt [] 0 s.input`
  \\ FULL_SIMP_TAC (srw_ss()) [cons_list_alt_thm,getNumber_def,isNumber_def]
  \\ Cases_on `x`
  \\ FULL_SIMP_TAC (srw_ss()) [cons_list_alt_thm,getNumber_def,isNumber_def]);

val lex_until_semi_res_def = Define `
  lex_until_semi_res input =
      case lex_until_top_semicolon_alt input of
      | NONE => Number 0
      | SOME (ts,rest) => BlockList (MAP BlockSym ts)`

val lex_until_semi_test_def = Define `
  lex_until_semi_test input =
      case lex_until_top_semicolon_alt input of
      | NONE => Number 0
      | SOME (ts,rest) => Number 1`

val lex_until_semi_state_def = Define `
  lex_until_semi_state input =
    case lex_until_top_semicolon_alt input of
      | NONE => ""
      | SOME (ts,rest) => rest`;

val lex_until_semi_thm = prove(
  ``lex_until_semi_pre (x1,x3,s,stack) /\
    (lex_until_semi (x1,x3,s,stack) =
       (x1,lex_until_semi_res s.input,x3,
           lex_until_semi_test s.input,
           s with input := lex_until_semi_state s.input,stack))``,
  SIMP_TAC std_ss [lex_until_semi_thm,lex_until_semi_res_def,
    lex_until_semi_test_def,lex_until_semi_state_def]
  \\ Cases_on `lex_until_top_semicolon_alt s.input`
  \\ SIMP_TAC (srw_ss()) [] \\ Cases_on `x` \\ SIMP_TAC (srw_ss()) []);

val zHEAP_LEX = let
  val th = lex_until_semi_res |> SIMP_RULE std_ss [lex_until_semi_thm,LET_DEF,SEP_CLAUSES]
  val th = SPEC_COMPOSE_RULE [zHEAP_CALL_LEX_WITH_STOP_ADDR,th,zHEAP_JMP_STOP_ADDR]
  val th = th |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
  val name = "lex"
  val ptr = ``cs.lex_ptr``
  val th = abbreviate_code name ptr th
  val th = SPEC_COMPOSE_RULE [th,zHEAP_ZERO_STOP_ADDR]
  val th = th |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
  in th end;


(* set cs pointers *)

val full_code_abbrevs_def = Define `
  full_code_abbrevs cs =
     bignum_code cs.bignum_ptr UNION alloc_code cs.alloc_ptr UNION
     equal_code cs.equal_ptr UNION print_code cs.print_ptr UNION
     error_code cs.error_ptr UNION lex_code cs.lex_ptr UNION
     install_and_run_code cs.install_and_run_ptr`;

fun zHEAP_SET_CS i update = let
  val call_th = x64_call_imm
  val pop_th = x64_pop_r15
  val store_th = spec ("mov [r9+"^(int_to_string i)^"], r15")
  val th = SPEC_COMPOSE_RULE [call_th,pop_th,store_th]
  val th = th |> Q.INST [`rip`|->`p`] |> RW [HD,TL,NOT_CONS_NIL,SEP_CLAUSES]
  val th = th |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val target = ``~zS * zPC p * zVALS cs vals *
      cond (heap_inv (cs,x1,x2,x3,x4,refs,stack,s,NONE) vals)``
  val (th,goal) = expand_pre th target
  val lemma = prove(goal, SIMP_TAC (std_ss++star_ss) [zVALS_def,SEP_IMP_REFL])
  val th = MP th lemma
  val th = th |> DISCH_ALL |> DISCH T
              |> PURE_REWRITE_RULE [AND_IMP_INTRO]
  val pc = get_pc th
  val th = MATCH_MP SPEC_WEAKEN_LEMMA th
  val th = th |> Q.SPEC `zHEAP (^update (p+6w),
                                x1,x2,x3,x4,refs,stack,s,NONE) * ~zS *^pc`
  val goal = th |> concl |> dest_imp |> fst
(*
gg goal
*)
  val lemma = prove(goal,
    SIMP_TAC std_ss [LET_DEF,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [zHEAP_def,SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
    \\ STRIP_TAC \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [heap_inv_def,LENGTH_MAP,LENGTH_APPEND]
      \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1]
      \\ SEP_R_TAC \\ FULL_SIMP_TAC std_ss []
      \\ Q.PAT_ASSUM `heap_vars_ok vs` MP_TAC
      \\ FULL_SIMP_TAC std_ss [heap_vars_ok_def] \\ blastLib.BBLAST_TAC)
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `vals with <| reg15 := p + 6w ; memory :=
          (vals.reg9 + n2w ^(numSyntax.term_of_int i) =+ p + 0x6w) vals.memory |>`
    \\ SIMP_TAC (std_ss++sep_cond_ss) [zVALS_def,cond_STAR]
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM (K ALL_TAC)
    \\ FULL_SIMP_TAC std_ss [heap_inv_def] \\ ASM_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`vs`,`r1`,`r2`,`r3`,`r4`,`roots`,`heap`,`a`,`sp`]
    \\ FULL_SIMP_TAC std_ss [MAP,APPEND,HD,TL]
    \\ FULL_SIMP_TAC std_ss [x64_store_def,one_list_def,word_arith_lemma1,
         STAR_ASSOC] \\ FULL_SIMP_TAC (srw_ss()) [SEP_CLAUSES]
    \\ Q.ABBREV_TAC `m = vals.memory`
    \\ Q.ABBREV_TAC `dm = vals.memory_domain`
    \\ SEP_W_TAC)
  val th = MP th lemma
  val th = Q.GEN `vals` th |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val (th,goal) = SPEC_STRENGTHEN_RULE th
    ``zHEAP (cs, x1, x2, x3, x4, refs, stack, s, NONE) * ~zS * zPC p``
  val lemma = prove(goal,
    SIMP_TAC (std_ss++star_ss) [zHEAP_def,SEP_IMP_REFL,SEP_CLAUSES])
  val th = MP th lemma
  in GSYM th end;

val SET_CS_ERROR   = zHEAP_SET_CS  40 ``\w. cs with error_ptr := w``;
val SET_CS_ALLOC   = zHEAP_SET_CS  48 ``\w. cs with alloc_ptr := w``;
val SET_CS_BIGNUM  = zHEAP_SET_CS  56 ``\w. cs with bignum_ptr := w``;
val SET_CS_EQUAL   = zHEAP_SET_CS  64 ``\w. cs with equal_ptr := w``;
val SET_CS_PRINT   = zHEAP_SET_CS  72 ``\w. cs with print_ptr := w``;
val SET_CS_LEX     = zHEAP_SET_CS 120 ``\w. cs with lex_ptr := w``;
val SET_CS_INSTALL = zHEAP_SET_CS 128 ``\w. cs with install_and_run_ptr := w``;

fun guess_length name = let
  fun dest_code_pair tm = let
    val (x,y) = dest_pair tm
    val i = wordsSyntax.dest_word_add x |> snd |> rand |> numSyntax.int_of_term
    val l = listSyntax.dest_list y |> fst |> length
    in i + l end handle HOL_ERR _ => 0
  val list_max = foldl (fn (x,y) => if x <= y then y else x) 0
  in fetch "-" name |> concl |> find_terms pairSyntax.is_pair
                    |> map dest_code_pair |> list_max |> numSyntax.term_of_int end

val zHEAP_INIT = let
  fun set_cs (th,name) =
    th |> Q.INST [`imm32`|->`n2w ^(guess_length (name ^ "_code_def"))`]
       |> SIMP_RULE (srw_ss()) [IMM32_def]
  val th = map set_cs
           [(SET_CS_ERROR,"error"),
            (SET_CS_ALLOC,"alloc"),
            (SET_CS_BIGNUM,"bignum"),
            (SET_CS_EQUAL,"equal"),
            (SET_CS_PRINT,"print"),
            (SET_CS_LEX,"lex"),
            (SET_CS_INSTALL,"install_and_run")] |> SPEC_COMPOSE_RULE
  val th = SPEC_COMPOSE_RULE [zHEAP_SETUP,th]
  val l = th |> concl |> rand |> find_term (can (match_term ``zPC p``))
             |> rand |> rand |> rand |> numSyntax.int_of_term
  val th = if l mod 2 = 0 then th else SPEC_COMPOSE_RULE [th,zHEAP_NOP]
  val full_cs =
    th |> concl |> rand |> find_term (can (match_term ``zHEAP (x,yyy)``))
       |> rand |> rator |> rand
  val full_cs_def = Define `full_cs init p = ^full_cs` ;
  val th = th |> RW [GSYM full_cs_def]
  in th end

val zHEAP_ABBREVS = prove(
  ``SPEC X64_MODEL
      (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * zPC p)
      (full_code_abbrevs cs)
      (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) * zPC p)``,
  SIMP_TAC std_ss [SPEC_REFL]);

val all_code_abbrevs =
  map (fetch "-") ["error_code_def", "alloc_code_def", "lex_code_def",
    "install_and_run_code_def", "bignum_code_def", "print_code_def",
    "equal_code_def"] |> LIST_CONJ


(* --- bytecode simulation --- *)

(* cb = code base, sb = stack base,ev *)

val bc_adjust_def = tDefine "bc_adjust" `
  (bc_adjust (cb,sb,ev) (CodePtr p) =
     CodePtr ((w2n (cb:word64) DIV 2) + p)) /\
  (bc_adjust (cb,sb,ev) (StackPtr i) =
     StackPtr ((w2n ((sb:word64) - n2w (8 * i)) DIV 2))) /\
  (bc_adjust (cb,sb,ev) (Number n) = Number n) /\
  (bc_adjust (cb,sb,ev) (RefPtr r) =
     RefPtr (if ev then 2 * (r + 1) else 2 * (r + 1) + 1)) /\
  (bc_adjust (cb,sb,ev) (Block tag data) =
     Block tag (MAP (bc_adjust (cb,sb,ev)) data))`
  (WF_REL_TAC `measure (bc_value_size o SND)`
   \\ Induct_on `data` \\ FULL_SIMP_TAC (srw_ss()) [DISJ_IMP,bc_value_size_def]
   \\ REPEAT STRIP_TAC \\ RES_TAC \\ TRY (POP_ASSUM (MP_TAC o Q.SPEC `tag`))
   \\ DECIDE_TAC) |> CONV_RULE (DEPTH_CONV ETA_CONV);

val ref_adjust_def = Define `
  ref_adjust (cb,sb,ev) (refs1:num |-> ref_value) =
    let adj = (\n. if ev then 2 * (n + 1) else 2 * (n + 1) + 1) in
      FUN_FMAP (\n. case refs1 ' (n DIV 2 - 1) of
                    | ValueArray vs => ValueArray (MAP (bc_adjust (cb,sb,ev)) vs)
                    | x => x)
               (IMAGE adj (FDOM refs1))`;

val ref_globals_list_def = Define `
  (ref_globals_list x 0 = []) /\
  (ref_globals_list [] (SUC n) = Number 0 :: ref_globals_list [] n) /\
  (ref_globals_list (NONE::xs) (SUC n) = Number 0 :: ref_globals_list xs n) /\
  (ref_globals_list (SOME x::xs) (SUC n) = x :: ref_globals_list xs n)`;

val OPT_MAP_def = Define `
  (OPT_MAP f [] = []) /\
  (OPT_MAP f (NONE::xs) = NONE :: OPT_MAP f xs) /\
  (OPT_MAP f (SOME x::xs) = SOME (f x) :: OPT_MAP f xs)`;

val ref_globals_def = Define `
  ref_globals (cb,sb,ev) globals =
    FEMPTY |+ (if ev then 0 else (1:num),
      ValueArray (ref_globals_list (OPT_MAP (bc_adjust (cb,sb,ev)) globals) globals_count))`;

val ref_addr_def = Define `
  ref_addr ev x = Block 0 [if ev then RefPtr 0 else RefPtr 1; x]`;

val zBC_HEAP_def = Define `
  zBC_HEAP bs (x,cs,stack,s,out) (cb,sb,ev,f2) =
    SEP_EXISTS x2 x3.
      let ss = MAP (bc_adjust (cb,sb,ev)) bs.stack ++ (Number 0) :: stack in
        zHEAP (cs,HD ss,x2,x3,ref_addr ev x,
               FUNION (ref_adjust (cb,sb,ev) bs.refs)
                      (FUNION (ref_globals (cb,sb,ev) bs.globals) f2),TL ss,
               s with <| output := (if s.local.printing_on = 0w then out
                                    else out ++ bs.output) ;
                         handler := bs.handler + SUC (LENGTH stack) |>,NONE)`;

val zBC_HEAP_1_def = Define `
  zBC_HEAP_1 bs y (x,cs,stack,s,out) (cb,sb,ev,f2) =
    SEP_EXISTS x2 x3.
      zHEAP (cs,y,x2,x3,ref_addr ev x,
             FUNION (ref_adjust (cb,sb,ev) bs.refs)
                    (FUNION (ref_globals (cb,sb,ev) bs.globals) f2),
             MAP (bc_adjust (cb,sb,ev)) bs.stack ++ (Number 0) :: stack,
             s with <| output := (if s.local.printing_on = 0w then out
                                  else out ++ bs.output) ;
                       handler := bs.handler + SUC (LENGTH stack) |>,NONE)`;

val th = zBC_Jump_1

fun prepare th = let
  val th = if can (find_term (fn tm => tm = ``zS``)) (concl th)
           then th else SPEC_FRAME_RULE th ``~zS``
  val th = th
    |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND,SPEC_1_MOVE_COND]
    |> UNDISCH_ALL
    |> CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zPC``))
    |> CONV_RULE (PRE_CONV (MOVE_OUT_CONV ``zS``))
    |> CONV_RULE ((RATOR_CONV o PRE_CONV) (MOVE_OUT_CONV ``zPC``))
    |> CONV_RULE ((RATOR_CONV o PRE_CONV) (MOVE_OUT_CONV ``zS``))
  val (_,pre,_,_) = th |> concl |> dest_spec
                    handle HOL_ERR _ => th |> concl |> dest_spec_1
  val tm = ``(zHEAP
     (cs,HD (MAP (bc_adjust (cb,sb,ev)) s1.stack ++ Number 0::stack),x2,
      x3,ref_addr ev x,
      FUNION (ref_adjust (cb,sb,ev) s1.refs)
        (FUNION (ref_globals (cb,sb,ev) s1.globals) f2),
      TL (MAP (bc_adjust (cb,sb,ev)) s1.stack ++ Number 0::stack),
      s with <| output := if s.local.printing_on = 0x0w then out
          else STRCAT out s1.output ; handler := h |>,NONE) *
     zPC (cb + n2w (2 * s1.pc)) * ~zS)``
  val i = fst (match_term pre tm)
  val th = INST i th
  in th end

val SPEC_IMP_SPEC_1_err = prove(
  ``SPEC m p c w ==> SPEC_1 m p c q w``,
  fs [SPEC_EQ_TEMPORAL,SPEC_1_def]
  \\ PairCases_on `m` \\ fs [TEMPORAL_def,T_OR_F_def,T_IMPLIES_def]
  \\ METIS_TAC []);

val IMP_small_offset = prove(
  ``(n < 268435456 ==>
     SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)) ==>
    SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), small_offset n xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC \\ SIMP_TAC std_ss [small_offset_def]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC (srw_ss()) []
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Error) |> SPEC_ALL
                |> DISCH_ALL |> SIMP_RULE (srw_ss()) [AND_IMP_INTRO]
                |> Q.INST [`base`|->`cb`])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]);

val IMP_small_offset6 = prove(
  ``(n < 268435456 ==>
     SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)) ==>
    SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), small_offset6 n xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC \\ SIMP_TAC std_ss [small_offset6_def]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC (srw_ss()) []
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Error6) |> SPEC_ALL
                |> DISCH_ALL |> SIMP_RULE (srw_ss()) [AND_IMP_INTRO]
                |> Q.INST [`base`|->`cb`])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]);

val IMP_small_offset12 = prove(
  ``(n < 268435456 ==>
     SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)) ==>
    SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), small_offset12 n xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC \\ SIMP_TAC std_ss [small_offset12_def]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC (srw_ss()) []
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Error12) |> SPEC_ALL
                |> DISCH_ALL |> SIMP_RULE (srw_ss()) [AND_IMP_INTRO]
                |> Q.INST [`base`|->`cb`])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]);

val IMP_small_offset16 = prove(
  ``(n < 268435456 ==>
     SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)) ==>
    SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), small_offset16 n xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC \\ SIMP_TAC std_ss [small_offset16_def]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC (srw_ss()) []
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Error16) |> SPEC_ALL
                |> DISCH_ALL |> SIMP_RULE (srw_ss()) [AND_IMP_INTRO]
                |> Q.INST [`base`|->`cb`])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]);

val IMP_globals_count = prove(
  ``(n < globals_count ==>
     SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc), xs) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)) ==>
    SPEC_1 X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
      zPC (cb + n2w (2 * s1.pc)) * ~zS)
     ((cb + n2w (2 * s1.pc),
      if n < globals_count then xs else ^err) INSERT code_abbrevs cs)
     (post)
     (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC \\ SIMP_TAC std_ss [small_offset16_def]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC std_ss []
  \\ MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC \\ SIMP_TAC (srw_ss()) []
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Error) |> SPEC_ALL
                |> DISCH_ALL |> SIMP_RULE (srw_ss()) [AND_IMP_INTRO]
                |> Q.INST [`base`|->`cb`])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]);

val EXISTS_NOT_FDOM_NUM = prove(
  ``!f. ?m:num. ~(m IN FDOM f)``,
  METIS_TAC [IN_INFINITE_NOT_FINITE,FDOM_FINITE,INFINITE_NUM_UNIV]);

val ODD_EVEN_SIMP_LEMMA = prove(
  ``!n. ~ODD (2 * n) /\ ~EVEN (2 * n + 1)``,
  ONCE_REWRITE_TAC [MULT_COMM]
  \\ SIMP_TAC (srw_ss()) [EVEN_MOD2,ODD_EVEN,MOD_MULT,
       MOD_MULT |> Q.SPECL [`n`,`0`] |> RW [ADD_0]]);

val ODD_EVEN_SIMP = prove(
  ``!n. ~ODD (2 * n) /\ ~EVEN (2 * n + 1) /\
        ~ODD (2 * n + 2) /\ ~EVEN (2 * n + 3)``,
  fs [ODD_EVEN_SIMP_LEMMA,ODD_EVEN_SIMP_LEMMA |> Q.SPEC `n+1`
         |> SIMP_RULE std_ss [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]]);

val bc_fetch_ignore_stack = prove(
  ``bc_fetch (s with stack := ss) = bc_fetch s``,
  SIMP_TAC (srw_ss()) [bc_fetch_def]);

fun ANY_ERROR_TAC error_th =
  MATCH_MP_TAC SPEC_IMP_SPEC_1_err
  \\ SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
  \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
  \\ REPEAT STRIP_TAC
  \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare error_th) |> SPEC_ALL
                |> DISCH_ALL |> RW [AND_IMP_INTRO])
  \\ FULL_SIMP_TAC (srw_ss()) [SEP_IMP_def,SEP_DISJ_def,SEP_EXISTS_THM]
  \\ SRW_TAC [] [] \\ FULL_SIMP_TAC (srw_ss()) [bc_fetch_ignore_stack]

val ERROR_TAC =
  TRY (ANY_ERROR_TAC zBC_Error \\ NO_TAC) \\
  TRY (ANY_ERROR_TAC zBC_Error6 \\ NO_TAC) \\
  TRY (ANY_ERROR_TAC zBC_Error12 \\ NO_TAC) \\
  TRY (ANY_ERROR_TAC zBC_Error16 \\ NO_TAC) \\
  NO_TAC

val output_simp = prove(
  ``((bump_pc s1).output = s1.output) /\
    ((s with stack := xxx).output = s.output) /\
    ((s with pc := new_pc).output = s.output)``,
  Cases_on `bc_fetch s1` \\ ASM_SIMP_TAC (srw_ss()) [bump_pc_def]);

val EVERY2_CONS = prove(
  ``EVERY2 P (x::xs) ys <=>
    ?y ys'. P x y /\ EVERY2 P xs ys' /\ (ys = y::ys')``,
  Cases_on `ys` \\ FULL_SIMP_TAC (srw_ss()) [LIST_REL_def]);

val reachable_refs_CodePtr = prove(
  ``(reachable_refs (x1::x2::x3::x4::CodePtr x::stack) refs n =
     reachable_refs (x1::x2::x3::x4::stack) refs n) /\
    (reachable_refs (CodePtr x::x2::x3::x4::stack) refs n =
     reachable_refs (x2::x3::x4::stack) refs n)``,
  SIMP_TAC std_ss [reachable_refs_def,MEM]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC std_ss [] \\ TRY (Q.PAT_ASSUM `x' = xxxx` ASSUME_TAC)
  \\ FULL_SIMP_TAC std_ss [get_refs_def,MEM] \\ METIS_TAC []);

val zHEAP_CodePtr = prove(
  ``(zHEAP (cs,x1,x2,x3,x4,refs,CodePtr n::stack,s,space) =
     zHEAP (cs,x1,x2,x3,x4,refs,CodePtr (w2n ((n2w n):63 word))::stack,s,space)) /\
    (zHEAP (cs,CodePtr n,x2,x3,x4,refs,stack,s,space) =
     zHEAP (cs,CodePtr (w2n ((n2w n):63 word)),x2,x3,x4,refs,stack,s,space))``,
  SIMP_TAC std_ss [zHEAP_def,heap_inv_def,abs_ml_inv_def,
    APPEND,bc_stack_ref_inv_def,LIST_REL_def,EVERY2_CONS,PULL_EXISTS]
  \\ SIMP_TAC std_ss [bc_value_inv_def,n2w_w2n,reachable_refs_CodePtr]);

val MOD64_DIV2_MOD63 = prove(
  ``(n MOD dimword (:64) DIV 2) MOD dimword (:63) =
    (n DIV 2) MOD dimword (:63)``,
  `dimword (:64) = dimword (:63) * 2` by EVAL_TAC
  \\ FULL_SIMP_TAC std_ss [DIV_MOD_MOD_DIV,ZERO_LT_dimword]
  \\ `0 < dimword (:63) * 2` by EVAL_TAC
  \\ FULL_SIMP_TAC std_ss [AC MULT_COMM MULT_ASSOC,MOD_MOD]);

val HD_CONS_TL = prove(
  ``!xs. ~(xs = []) ==> (HD xs :: TL xs = xs)``,
  Cases \\ SRW_TAC [] []);

val word_sub_intro = prove(
  ``(-w + v = v - w) /\ (v + -w = v - w:'a word)``,
  SIMP_TAC std_ss [word_sub_def,AC WORD_ADD_COMM WORD_ADD_ASSOC]);

val SPEC_CONSEQ = prove(
  ``SPEC m p c q ==>
    !p1 q1. SEP_IMP p1 p /\ SEP_IMP q q1 ==> SPEC m p1 c q1``,
  METIS_TAC [SPEC_WEAKEN,SPEC_STRENGTHEN]);

val bc_equal_sym = prove(
  ``(!x1 x2. bc_equal x1 x2 = bc_equal x2 x1) /\
    (!xs1 xs2. bc_equal_list xs1 xs2 = bc_equal_list xs2 xs1)``,
  HO_MATCH_MP_TAC bytecodeTerminationTheory.bc_equal_ind
  \\ REPEAT ( STRIP_TAC THEN1 ( GEN_TAC \\ Cases \\ SRW_TAC[][bc_equal_def] ))
  \\ NTAC 8 ( STRIP_TAC THEN1 ( SRW_TAC[][bc_equal_def,EQ_IMP_THM] ) )
  \\ STRIP_TAC THEN1 (
    SRW_TAC[][] \\
    SRW_TAC[][bc_equal_def] \\
    REV_FULL_SIMP_TAC std_ss [] )
  \\ STRIP_TAC THEN1 ( SRW_TAC[][bc_equal_def,EQ_IMP_THM] )
  \\ STRIP_TAC THEN1 (
    SRW_TAC[][bc_equal_def] \\
    Cases_on`bc_equal x1 x2` \\ FULL_SIMP_TAC (srw_ss())[] \\
    Cases_on`bc_equal x2 x1` \\ FULL_SIMP_TAC (srw_ss())[] \\
    BasicProvers.CASE_TAC \\ FULL_SIMP_TAC (srw_ss())[] )
  \\ STRIP_TAC THEN1 ( GEN_TAC \\ Cases \\ SRW_TAC[][bc_equal_def] )
  \\ SRW_TAC[][bc_equal_def]) |> CONJUNCT1;

val bc_equal_adjust = prove(
  ``(!x1 x2.
      bc_equal x1 x2 <> Eq_type_error ==>
      (bc_equal (bc_adjust (cb,sb,ev) x2) (bc_adjust (cb,sb,ev) x1) =
       bc_equal x2 x1)) /\
    (!x1 x2.
      bc_equal_list x1 x2 <> Eq_type_error ==>
      (bc_equal_list (MAP (bc_adjust (cb,sb,ev)) x2) (MAP (bc_adjust (cb,sb,ev)) x1) =
       bc_equal_list x2 x1))``,
  HO_MATCH_MP_TAC bytecodeTerminationTheory.bc_equal_ind
  \\ REPEAT (STRIP_TAC THEN1 ( GEN_TAC \\ Cases \\ SRW_TAC[][bc_equal_def,bc_adjust_def]))
  \\ NTAC 3 ( STRIP_TAC THEN1 ( SRW_TAC[ARITH_ss][bc_equal_def,bc_adjust_def] ) )
  \\ STRIP_TAC THEN1 (
    SRW_TAC[][bc_adjust_def] \\
    FULL_SIMP_TAC (srw_ss()) [bc_equal_def] \\
    SRW_TAC[][] \\
    REV_FULL_SIMP_TAC (srw_ss()) [] )
  \\ STRIP_TAC THEN1 ( SRW_TAC[ARITH_ss][bc_equal_def,bc_adjust_def] )
  \\ STRIP_TAC THEN1 (
    SRW_TAC[][bc_adjust_def] \\
    FULL_SIMP_TAC (srw_ss()) [bc_equal_def] \\
    Cases_on`bc_equal x1 x2` \\ FULL_SIMP_TAC (srw_ss())[] \\
    Cases_on`bc_equal x2 x1` \\ FULL_SIMP_TAC (srw_ss())[] \\
    ASSUME_TAC (SPEC_ALL bc_equal_sym) \\
    REV_FULL_SIMP_TAC (srw_ss())[] \\
    SRW_TAC[][] \\ FULL_SIMP_TAC (srw_ss())[] )
  \\ STRIP_TAC THEN1 ( SRW_TAC[ARITH_ss][bc_equal_def,bc_adjust_def] )
  \\ STRIP_TAC THEN1 ( SRW_TAC[ARITH_ss][bc_equal_def,bc_adjust_def] )) |> CONJUNCT1;

val DROP_MAP_APPEND = prove(
  ``DROP (LENGTH xs) (MAP f xs ++ ys) = ys``,
  METIS_TAC [rich_listTheory.DROP_LENGTH_APPEND,LENGTH_MAP]);

val LESS_EQ_LENGTH_ALT = prove(
  ``!n xs. n <= LENGTH xs ==> ?ys1 ys2. (xs = ys1 ++ ys2) /\ (LENGTH ys2 = n)``,
  Induct_on `xs` \\ Cases_on `n` \\ FULL_SIMP_TAC (srw_ss()) [LENGTH_NIL]
  \\ REPEAT STRIP_TAC \\ RES_TAC \\ FULL_SIMP_TAC std_ss []
  \\ `(ys1 = []) \/ ?x l. ys1 = SNOC x l` by METIS_TAC [SNOC_CASES]
  THEN1 (Q.EXISTS_TAC `[]` \\ FULL_SIMP_TAC (srw_ss()) [APPEND])
  \\ FULL_SIMP_TAC std_ss [SNOC_APPEND,GSYM APPEND_ASSOC,APPEND]
  \\ Q.EXISTS_TAC `h::l` \\ FULL_SIMP_TAC std_ss []
  \\ Q.EXISTS_TAC `x::ys2` \\ FULL_SIMP_TAC (srw_ss()) []);

val LENGTH_TL_APPEND = prove(
  ``!xs. LENGTH (TL (xs ++ y::ys)) = LENGTH xs + LENGTH ys``,
  Cases \\ SRW_TAC [] [ADD1] \\ DECIDE_TAC);

val HD_TL = prove(
  ``!xs y ys. HD (xs ++ y::ys) :: TL (xs ++ y::ys) = xs ++ y::ys``,
  Cases \\ SRW_TAC [] []);

val LoadRev_LEMMA = prove(
  ``n < LENGTH xs ==>
    (EL (n + (LENGTH stack + 1)) (REVERSE ((MAP f xs) ++ Number 0::stack)) =
     f (EL n (REVERSE xs)))``,
  SRW_TAC [] [REVERSE_APPEND,rich_listTheory.EL_APPEND2] \\ POP_ASSUM MP_TAC
  \\ Q.SPEC_TAC (`n`,`n`) \\ Q.SPEC_TAC (`xs`,`xs`) \\ recInduct SNOC_INDUCT
  \\ FULL_SIMP_TAC std_ss [LENGTH,LENGTH_SNOC]
  \\ REPEAT STRIP_TAC \\ SRW_TAC [] [MAP_SNOC,REVERSE_SNOC]
  \\ Cases_on `n` \\ FULL_SIMP_TAC (srw_ss()) []);

val bvs_to_chars_bc_adjust = prove(
  ``!ys xs. bvs_to_chars (MAP (bc_adjust (cb,sb,ev)) ys) xs =
            bvs_to_chars ys xs``,
  Induct \\ EVAL_TAC \\ SIMP_TAC std_ss [] \\ Cases
  \\ EVAL_TAC \\ FULL_SIMP_TAC std_ss []);

val only_chars_bc_adjust = prove(
  ``!data. only_chars data ==>
           (MAP (bc_adjust (cb,sb,ev)) data = data)``,
  Induct \\ EVAL_TAC \\ Cases \\ EVAL_TAC
  \\ ASM_SIMP_TAC std_ss [only_chars_def,is_char_def]);

val bvs_to_chars_bc_adjust = prove(
  ``!l acc.
      bvs_to_chars (MAP (bc_adjust (cb,sb,ev)) l) acc =
      bvs_to_chars l acc``,
  Induct \\ FULL_SIMP_TAC std_ss [MAP,bc_adjust_def,bvs_to_chars_def]
  \\ Cases \\ FULL_SIMP_TAC std_ss [MAP,bc_adjust_def,bvs_to_chars_def]);

val bv_to_string_bc_adjust = prove(
  ``!v. bv_to_string (bc_adjust (cb,sb,ev) v) = bv_to_string v``,
  Cases \\ FULL_SIMP_TAC std_ss [bc_adjust_def,bv_to_string_def]
  \\ SRW_TAC [] [bvs_to_chars_bc_adjust]);

val TAKE_DROP_MAP_APPEND = prove(
  ``(TAKE (LENGTH xs) (MAP f xs ++ ys) = MAP f xs) /\
    (DROP (LENGTH xs) (MAP f xs ++ ys) = ys)``,
  METIS_TAC [rich_listTheory.TAKE_LENGTH_APPEND,LENGTH_MAP,
     rich_listTheory.DROP_LENGTH_APPEND]);

val ref_lemma = prove(
  ``(if ev then 2 * (ptr + 1) else (2 * (ptr + 1) + 1)) DIV 2 = ptr + 1``,
  SRW_TAC [] [DIV_EQ_X] \\ DECIDE_TAC);

val ref_lemma2 = prove(
  ``((if ev then 2 * (n' + 1) else 2 * (n' + 1) + 1) =
     (if ev then 2 * (ptr + 1) else 2 * (ptr + 1) + 1)) <=> (n' = ptr:num)``,
  Cases_on `ev` \\ DECIDE_TAC);

val ref_globals_list_alloc = prove(
  ``!n l k. ref_globals_list (l ++ REPLICATE k NONE) n = ref_globals_list l n``,
  Induct \\ fs [ref_globals_list_def] \\ Cases
  \\ fs [ref_globals_list_def,rich_listTheory.REPLICATE]
  THEN1 (Cases_on `k` \\ fs [ref_globals_list_def,rich_listTheory.REPLICATE]
         \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `[]`) \\ fs [])
  \\ Cases_on `h` \\ fs [ref_globals_list_def,rich_listTheory.REPLICATE]);

val OPT_MAP_APPEND = prove(
  ``!xs ys f. OPT_MAP f (xs ++ ys) = OPT_MAP f xs ++ OPT_MAP f ys``,
  Induct \\ fs [OPT_MAP_def] \\ Cases \\ fs [OPT_MAP_def]);

val OPT_MAP_NONE = prove(
  ``!n f. OPT_MAP f (REPLICATE n NONE) = REPLICATE n NONE``,
  Induct \\ fs [OPT_MAP_def,rich_listTheory.REPLICATE]);

val ref_globals_alloc = prove(
  ``ref_globals (cb,sb,ev) (l ++ REPLICATE n NONE) = ref_globals (cb,sb,ev) l``,
  fs [ref_globals_def,ref_globals_list_alloc,OPT_MAP_APPEND,OPT_MAP_NONE]);

val ref_globals_lemma = prove(
  ``~(getRefPtr (if ev then RefPtr 0 else RefPtr 1) IN
      FDOM (ref_adjust (cb,sb,ev) s1.refs)) /\
    getRefPtr (if ev then RefPtr 0 else RefPtr 1) IN
       FDOM (ref_globals (cb,sb,ev) xs)``,
  Cases_on `ev` \\ fs [getRefPtr_def,ref_adjust_def,LET_DEF,ref_globals_def]
  \\ REPEAT STRIP_TAC \\ CCONTR_TAC \\ fs [] \\ DECIDE_TAC);

val LENGTH_ref_globals_list = prove(
  ``!n xs. LENGTH (ref_globals_list xs n) = n``,
  Induct \\ Cases_on `xs` \\ fs [ref_globals_list_def]
  \\ Cases_on `h` \\ fs [ref_globals_list_def]);

val ODD_NOT_ZERO_ETC = prove(
  ``(ODD n ==> (n <> 0)) /\ (EVEN n ==> (n <> 1)) /\
    (x IN FDOM (ref_adjust (cb,sb,ev) s1.refs) ==> x <> 0 /\ x <> 1)``,
  REPEAT STRIP_TAC \\ fs [] \\ fs []
  \\ fs [ref_adjust_def,LET_DEF] \\ Cases_on `ev` \\ fs [] \\ DECIDE_TAC);

val LUPDATE_ref_globals_list = prove(
  ``!xs k n.
      n < LENGTH xs ==>
      (LUPDATE (f x') n (ref_globals_list (OPT_MAP f xs) k) =
       ref_globals_list (OPT_MAP f (LUPDATE (SOME x') n xs)) k)``,
  Induct \\ Cases_on `k` \\ fs [ref_globals_list_def,LUPDATE_def,OPT_MAP_def]
  \\ Cases_on `n'` \\ fs [ref_globals_list_def,LUPDATE_def,OPT_MAP_def]
  \\ Cases \\ fs [ref_globals_list_def,EL,OPT_MAP_def,LUPDATE_def]);

val EL_ref_globals_list = prove(
  ``!xs n k v. (EL n xs = SOME v) /\ n < k /\ n < LENGTH xs ==>
               (EL n (ref_globals_list (OPT_MAP f xs) k) = f v)``,
  Induct \\ Cases_on `k` \\ fs [ref_globals_list_def,EL,OPT_MAP_def]
  \\ Cases \\ Cases_on `n'` \\ fs [ref_globals_list_def,EL,OPT_MAP_def]);

val SPEC_1_WEAKEN_ALT = prove(
  ``SPEC_1 x p c q SEP_F ==> !r. SEP_IMP q r ==> SPEC_1 x p c r err``,
  STRIP_TAC \\ MATCH_MP_TAC SPEC_1_WEAKEN
  \\ MATCH_MP_TAC SPEC_1_ERR_INTRO \\ fs []);

val SPEC_1_zBC_HEAP_THM = prove(
  ``EVEN (w2n cb) /\ (cs.stack_trunk - n2w (8 * SUC (LENGTH stack)) = sb) ==>
    !s1 s2.
      bc_next s1 s2 ==> (s1.inst_length = x64_inst_length) /\
      (!r. r IN FDOM f2 ==> if ev then ODD r else EVEN r) ==>
      SPEC_1 X64_MODEL
         (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
          zPC (cb + n2w (2 * s1.pc)) * ~zS)
        ((cb + n2w (2 * s1.pc),x64 (2 * s1.pc) (THE (bc_fetch s1)))
         INSERT code_abbrevs cs)
        (zBC_HEAP s2 (x,cs,stack,s,out) (cb,sb,ev,f2) *
         zPC (cb + n2w (2 * s2.pc)) * ~zS)
        (zHEAP_ERROR cs)``,
  STRIP_TAC \\ HO_MATCH_MP_TAC bc_next_ind \\ REPEAT STRIP_TAC
  \\ TRY (Cases_on `b:bc_stack_op`)
  \\ TRY (Cases_on `l:loc`)
  \\ TRY (Q.PAT_ASSUM `bc_stack_op xxx s1.stack ys` MP_TAC)
  \\ ONCE_REWRITE_TAC [bc_stack_op_cases]
  \\ FULL_SIMP_TAC std_ss [bc_inst_distinct,bc_inst_11,
       bc_stack_op_distinct,bc_stack_op_11,LET_DEF]
  \\ REPEAT STRIP_TAC
  \\ Q.PAT_ASSUM `bc_fetch s1 = SOME xx` MP_TAC
  \\ SIMP_TAC std_ss [x64_def,LET_DEF] \\ REPEAT STRIP_TAC
  \\ NTAC 3 (TRY (MATCH_MP_TAC IMP_small_offset \\ REPEAT STRIP_TAC
                  \\ TRY (SRW_TAC [] [output_simp] \\ NO_TAC)))
  \\ NTAC 3 (TRY (MATCH_MP_TAC IMP_small_offset6 \\ REPEAT STRIP_TAC
                  \\ TRY (SRW_TAC [] [output_simp] \\ NO_TAC)))
  \\ NTAC 3 (TRY (MATCH_MP_TAC IMP_small_offset12 \\ REPEAT STRIP_TAC
                  \\ TRY (SRW_TAC [] [output_simp] \\ NO_TAC)))
  \\ NTAC 3 (TRY (MATCH_MP_TAC IMP_small_offset16 \\ REPEAT STRIP_TAC
                  \\ TRY (SRW_TAC [] [output_simp] \\ NO_TAC)))
  \\ NTAC 3 (TRY (MATCH_MP_TAC IMP_globals_count \\ REPEAT STRIP_TAC
                  \\ TRY (SRW_TAC [] [output_simp] \\ NO_TAC)))
  THEN1 (* Pop *)
   (SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN
                       (prepare zBC_Pop |> spec_to_spec_1) |> SPEC_ALL
                  |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Pops *)
   (SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN (prepare zBC_Pops |> spec_to_spec_1)
         |> Q.INST [`k`|->`n`] |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    THEN1 DECIDE_TAC
    \\ Q.PAT_ASSUM `n = xxx` ASSUME_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1,
         small_offset_def,LET_DEF,GSYM ADD_ASSOC,IMM32_def]
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ `DROP (LENGTH ys')
             (MAP (bc_adjust (cb,sb,ev)) ys' ++
              MAP (bc_adjust (cb,sb,ev)) xs ++ Number 0::stack) =
        MAP (bc_adjust (cb,sb,ev)) xs ++ Number 0::stack` by ALL_TAC
    THEN1 (METIS_TAC [rich_listTheory.DROP_LENGTH_APPEND,LENGTH_MAP,APPEND_ASSOC])
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* PushInt *)
   (Cases_on `i < 0` \\ FULL_SIMP_TAC std_ss [] THEN1 ERROR_TAC
    \\ SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_PushInt |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,HD_CONS_TL]
    \\ STRIP_TAC THEN1 intLib.COOPER_TAC
    \\ `&Num i = i` by intLib.COOPER_TAC
    \\ FULL_SIMP_TAC std_ss [bc_adjust_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_length_def,x64_def,
        small_offset_def,IMM32_def,LENGTH,GSYM ADD_ASSOC,LET_DEF]
    \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,SEP_DISJ_def]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* Cons *)
   (REVERSE (Cases_on `n < 4096`) \\ FULL_SIMP_TAC std_ss [] THEN1 ERROR_TAC
    \\ SIMP_TAC std_ss [LET_DEF]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = Number (&LENGTH ts)::(ts ++ xs)`
    \\ SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare (zBC_Cons |> RW [ASSUME ``Number (&l) = x1``])
           |> spec_to_spec_1
           |> Q.INST [`l`|->`LENGTH (ts:bc_value list)`]
           |> DISCH ``n < 4096:num`` |> SIMP_RULE std_ss [SEP_CLAUSES] |> UNDISCH
           |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
           |> DISCH_ALL |> RW [AND_IMP_INTRO]
           |> MATCH_MP_TAC)
    \\ ASM_SIMP_TAC std_ss [MAP,bc_adjust_def,HD,TL,APPEND]
    \\ STRIP_TAC THEN1 (fs [LENGTH_APPEND] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,TAKE_DROP_MAP_APPEND]
    \\ fs [bc_adjust_def,rich_listTheory.MAP_REVERSE]
    \\ fs [x64_inst_length_def,x64_length_def,x64_def,LET_DEF]
    \\ fs [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1]
    \\ FULL_SIMP_TAC std_ss [GSYM APPEND_ASSOC,TAKE_DROP_MAP_APPEND]
    \\ fs [SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`] \\ fs []
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Load *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Load
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,HD_CONS_TL]
    \\ STRIP_TAC THEN1
     (Cases_on `s1.stack`
      \\ FULL_SIMP_TAC std_ss [LENGTH,MAP,TL,APPEND,LENGTH_APPEND,LENGTH_MAP]
      \\ DECIDE_TAC)
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_length_def,x64_def,
        small_offset_def,IMM32_def,LENGTH,GSYM ADD_ASSOC]
    \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ IMP_RES_TAC LESS_LENGTH
    \\ POP_ASSUM (ASSUME_TAC o GSYM)
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,EL_LENGTH,APPEND,GSYM APPEND_ASSOC,
         EL_LENGTH |> Q.SPEC `MAP f xs` |> RW [LENGTH_MAP]]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,SEP_DISJ_def] \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* Store *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Store
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,HD_CONS_TL]
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [GSYM LENGTH_NIL,LENGTH_LUPDATE]
      \\ FULL_SIMP_TAC (srw_ss()) [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [MAP,MAP_APPEND,EL_LENGTH,APPEND,GSYM APPEND_ASSOC,
         LUPDATE_LENGTH |> Q.SPEC `MAP f xs` |> RW [LENGTH_MAP]]
    \\ Q.PAT_ASSUM `n = LENGTH ys'` ASSUME_TAC \\ FULL_SIMP_TAC std_ss []
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_length_def,x64_def,
        small_offset_def,IMM32_def,LENGTH,GSYM ADD_ASSOC]
    \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,SEP_DISJ_def] \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* LengthBlock *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_LengthBlock
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH] \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [bc_tag_eq_pre_def,isNumber_def,LET_DEF,LENGTH_MAP,
        isBlock_def,getNumber_def,small_int_def,getTag_def,getContent_def]
      \\ intLib.COOPER_TAC)
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC,bc_adjust_def,
         MAP,getTag_def])
  THEN1 (* El *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_El
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def,getNumber_def]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = Number(&k)::Block tag ts::xs`
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH] \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [bc_tag_eq_pre_def,isNumber_def,LET_DEF,LENGTH_MAP,
        isBlock_def,getNumber_def,small_int_def,getTag_def,getContent_def]
      \\ intLib.COOPER_TAC)
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`Block tag (MAP (bc_adjust (cb,sb,ev)) ts)`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC,bc_adjust_def,
         MAP,getTag_def])
  THEN1 (* TagEq *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_TagEq
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = Block tag ts::xs`
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH] \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [bc_tag_eq_pre_def,isNumber_def,LET_DEF,
        isBlock_def,getNumber_def,small_int_def,getTag_def]
      \\ intLib.COOPER_TAC)
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`Number (&n)`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC,bc_adjust_def,
         MAP,getTag_def])
  THEN1 (* IsBlock *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_IsBlock
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = y::xs`
    \\ SIMP_TAC std_ss [EVAL ``x64_inst_length (Stack IsBlock)``,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1]
    \\ STRIP_TAC
    THEN1 (Cases_on `y` \\ FULL_SIMP_TAC (srw_ss()) [] \\ EVAL_TAC)
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC]
    \\ Cases_on `y` \\ FULL_SIMP_TAC (srw_ss()) [isBlock_def,bc_adjust_def])
  THEN1 (* Equal *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Equal
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = x2::x1::xs`
    \\ FULL_SIMP_TAC std_ss [bc_equal_adjust]
    \\ (bc_equal_sym |> GSYM |> SPEC_ALL |> ASSUME_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [EVEN_w2n] \\ Q.PAT_ASSUM `~cb ' 0` MP_TAC
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w] \\ blastLib.BBLAST_TAC)
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ `bc_adjust (cb,sb,ev) (bc_equality_result_to_val (bc_equal x1 x2)) =
        bc_equality_result_to_val (bc_equal x1 x2)` by ALL_TAC THEN1
         (Cases_on `bc_equal x1 x2` \\ EVAL_TAC) \\ FULL_SIMP_TAC std_ss []
    \\ Q.LIST_EXISTS_TAC [`bc_adjust (cb,sb,ev) x1`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [EVAL ``x64_inst_length (Stack Equal)``,
         LEFT_ADD_DISTRIB,word_arith_lemma1])
  THEN1 (* Add *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Add
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [AC integerTheory.INT_ADD_ASSOC
         integerTheory.INT_ADD_COMM]
    \\ Q.LIST_EXISTS_TAC [`Number m`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Sub *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Sub
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [AC integerTheory.INT_ADD_ASSOC
         integerTheory.INT_ADD_COMM]
    \\ Q.LIST_EXISTS_TAC [`Number n`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Mult *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Mul
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [AC integerTheory.INT_MUL_ASSOC
         integerTheory.INT_MUL_COMM]
    \\ Q.LIST_EXISTS_TAC [`Number m`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Div *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Div
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`Number n`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Mod *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Mod
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`Number n`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Less *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Less
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH,getNumber_def]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,
         SEP_DISJ_def,bc_adjust_def] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) []
    \\ Q.LIST_EXISTS_TAC [`Number n`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Jump Lab *) ERROR_TAC
  THEN1 (* Jump Addr *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN_ALT (prepare zBC_Jump_1) |> SPEC_ALL
                     |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ FULL_SIMP_TAC std_ss [bc_find_loc_def,GSYM word_add_n2w]
    \\ SIMP_TAC std_ss [sw2sw_lemma]
    \\ `cb + n2w (2 * s1.pc) +
         (0x6w + sw2sw (n2w (2 * n) - n2w (2 * s1.pc) - 0x6w:word32)) =
        cb + n2w (2 * n)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [WORD_EQ_ADD_LCANCEL,GSYM WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,word_add_n2w,GSYM WORD_SUB_PLUS]
      \\ `(2 * s1.pc + 6) < 4294967296 /\ (2 * n) < 4294967296` by DECIDE_TAC
      \\ `n2w (2 * s1.pc + 6) = (w2w:word32->word64) (n2w (2 * s1.pc + 6))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ `n2w (2 * n) = (w2w:word32->word64) (n2w (2 * n))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ FULL_SIMP_TAC std_ss []
      \\ MATCH_MP_TAC w2w_ADD_sw2sw_SUB
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO,w2n_n2w]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC) \\ SIMP_TAC (srw_ss()) []
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* JumpIf -- Lab *) ERROR_TAC
  THEN1 (* JumpIf -- Addr *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN_ALT (prepare zBC_JumpIf_1) |> SPEC_ALL
                     |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ FULL_SIMP_TAC std_ss [bc_find_loc_def,GSYM word_add_n2w]
    \\ STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()) [] \\ EVAL_TAC)
    \\ `bc_fetch (s1 with stack := xs) = bc_fetch s1` by ALL_TAC
    THEN1 (FULL_SIMP_TAC (srw_ss()) [bc_fetch_def] \\ METIS_TAC [])
    \\ FULL_SIMP_TAC std_ss [MAP,HD,TL,APPEND,sw2sw_lemma]
    \\ `cb + n2w (2 * s1.pc) +
         (6w + (0x6w + sw2sw (n2w (2 * n) - n2w (2 * s1.pc) - 0xCw:word32))) =
        cb + n2w (2 * n)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [WORD_EQ_ADD_LCANCEL,GSYM WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,word_add_n2w,GSYM WORD_SUB_PLUS]
      \\ SIMP_TAC std_ss [GSYM ADD_ASSOC]
      \\ `(2 * s1.pc + 12) < 4294967296 /\ (2 * n) < 4294967296` by DECIDE_TAC
      \\ `n2w (2 * s1.pc + 12) = (w2w:word32->word64) (n2w (2 * s1.pc + 12))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ `n2w (2 * n) = (w2w:word32->word64) (n2w (2 * n))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ FULL_SIMP_TAC std_ss []
      \\ MATCH_MP_TAC w2w_ADD_sw2sw_SUB
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO,w2n_n2w]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ Cases_on `b` \\ FULL_SIMP_TAC (srw_ss()) [bc_adjust_def]
    \\ POP_ASSUM (K ALL_TAC)
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ Q.PAT_ASSUM `n' = n` ASSUME_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1,
         small_offset12_def,LET_DEF,GSYM ADD_ASSOC])
  THEN1 (* Call -- Lab *) ERROR_TAC
  THEN1 (* Call -- Addr *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN_ALT (prepare zBC_Call_1) |> SPEC_ALL
                     |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ FULL_SIMP_TAC std_ss [bc_find_loc_def,GSYM word_add_n2w]
    \\ SIMP_TAC std_ss [sw2sw_lemma]
    \\ `cb + n2w (2 * s1.pc) +
         0x6w + sw2sw (n2w (2 * n) - n2w (2 * s1.pc) - 0x6w:word32) =
        cb + n2w (2 * n)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [WORD_EQ_ADD_LCANCEL,GSYM WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,word_add_n2w,GSYM WORD_SUB_PLUS]
      \\ `(2 * s1.pc + 6) < 4294967296 /\ (2 * n) < 4294967296` by DECIDE_TAC
      \\ `n2w (2 * s1.pc + 6) = (w2w:word32->word64) (n2w (2 * s1.pc + 6))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ `n2w (2 * n) = (w2w:word32->word64) (n2w (2 * n))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ FULL_SIMP_TAC std_ss []
      \\ MATCH_MP_TAC w2w_ADD_sw2sw_SUB
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO,w2n_n2w]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC) \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (srw_ss()) [HD,TL,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC std_ss [bc_adjust_def,getCodePtr_def,isCodePtr_def]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w,EVEN_LEMMA]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    THEN1 (FULL_SIMP_TAC std_ss [EVEN_w2n] \\ Q.PAT_ASSUM `~cb ' 0` MP_TAC
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w]
    \\ `x64_inst_length (Call (Addr n)) = 2` by ALL_TAC THEN1
     (Q.PAT_ASSUM `n' = n` ASSUME_TAC \\ EVAL_TAC
      \\ FULL_SIMP_TAC std_ss [LENGTH])
    \\ FULL_SIMP_TAC std_ss [GSYM ADD_ASSOC]
    \\ POP_ASSUM (K ALL_TAC)
    \\ `w2n cb DIV 2 + (s1.pc + 3) =
        (w2n cb + 2 * (s1.pc + 3)) DIV 2` by ALL_TAC THEN1
     (ONCE_REWRITE_TAC [ADD_COMM] \\ ONCE_REWRITE_TAC [MULT_COMM]
      \\ SIMP_TAC std_ss [ADD_DIV_ADD_DIV])
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `bbb s'` MP_TAC
    \\ ONCE_REWRITE_TAC [zHEAP_CodePtr]
    \\ SIMP_TAC std_ss [GSYM word_add_n2w]
    \\ Cases_on `cb` \\ FULL_SIMP_TAC std_ss [w2n_n2w,word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [MOD64_DIV2_MOD63]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* CallPtr *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_CallPtr_1
         |> MATCH_MP SPEC_1_WEAKEN_ALT |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [HD,TL,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC std_ss [bc_adjust_def,getCodePtr_def,isCodePtr_def]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w,EVEN_LEMMA]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    THEN1 (FULL_SIMP_TAC std_ss [EVEN_w2n] \\ Q.PAT_ASSUM `~cb ' 0` MP_TAC
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`CodePtr (w2n cb DIV 2 + ptr)`,`x3`]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w]
    \\ FULL_SIMP_TAC std_ss [EVAL ``x64_inst_length CallPtr``]
    \\ FULL_SIMP_TAC std_ss [GSYM ADD_ASSOC]
    \\ POP_ASSUM MP_TAC
    \\ `w2n cb DIV 2 + (s1.pc + 4) =
        (w2n cb + 2 * (s1.pc + 4)) DIV 2` by ALL_TAC THEN1
     (ONCE_REWRITE_TAC [ADD_COMM] \\ ONCE_REWRITE_TAC [MULT_COMM]
      \\ SIMP_TAC std_ss [ADD_DIV_ADD_DIV])
    \\ FULL_SIMP_TAC std_ss []
    \\ ONCE_REWRITE_TAC [zHEAP_CodePtr]
    \\ SIMP_TAC std_ss [GSYM word_add_n2w]
    \\ Cases_on `cb` \\ FULL_SIMP_TAC std_ss [w2n_n2w,word_add_n2w]
    \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB,ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [MOD64_DIV2_MOD63]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* PushPtr -- Lab *) ERROR_TAC
  THEN1 (* PushPtr -- Addr *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN (prepare zBC_PushPtr |>
         spec_to_spec_1) |> SPEC_ALL
                     |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ FULL_SIMP_TAC std_ss [bc_find_loc_def,GSYM word_add_n2w]
    \\ SIMP_TAC std_ss [sw2sw_lemma]
    \\ `cb + n2w (2 * s1.pc) +
         0x8w + sw2sw (n2w (2 * n) - n2w (2 * s1.pc) - 0x8w:word32) =
        cb + n2w (2 * n)` by ALL_TAC THEN1
     (SIMP_TAC std_ss [WORD_EQ_ADD_LCANCEL,GSYM WORD_ADD_ASSOC]
      \\ SIMP_TAC std_ss [WORD_ADD_ASSOC,word_add_n2w,GSYM WORD_SUB_PLUS]
      \\ `(2 * s1.pc + 8) < 4294967296 /\ (2 * n) < 4294967296` by DECIDE_TAC
      \\ `n2w (2 * s1.pc + 8) = (w2w:word32->word64) (n2w (2 * s1.pc + 8))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ `n2w (2 * n) = (w2w:word32->word64) (n2w (2 * n))` by
            FULL_SIMP_TAC (srw_ss()) [w2w_def,w2n_n2w]
      \\ FULL_SIMP_TAC std_ss []
      \\ MATCH_MP_TAC w2w_ADD_sw2sw_SUB
      \\ FULL_SIMP_TAC (srw_ss()) [WORD_LO,w2n_n2w]
      \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss [] \\ POP_ASSUM (K ALL_TAC) \\ SIMP_TAC (srw_ss()) []
    \\ FULL_SIMP_TAC (srw_ss()) [HD,TL,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC std_ss [bc_adjust_def,getCodePtr_def,isCodePtr_def]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w,EVEN_LEMMA]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    THEN1 (FULL_SIMP_TAC std_ss [EVEN_w2n] \\ Q.PAT_ASSUM `~cb ' 0` MP_TAC
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC std_ss [LEFT_ADD_DISTRIB,GSYM word_add_n2w]
    \\ Q.PAT_ASSUM `n' = n` ASSUME_TAC \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [x64_inst_length_def,x64_length_def,x64_def,
         small_offset16_def,LET_DEF,LENGTH,IMM32_def,word_arith_lemma1]
    \\ Q.PAT_ABBREV_TAC `pat = tt ++ Number 0::stack`
    \\ `HD pat :: TL pat = pat` by ALL_TAC THEN1
     (Cases_on `pat` \\ UNABBREV_ALL_TAC \\ FULL_SIMP_TAC (srw_ss()) []
      \\ Cases_on `s1.stack` \\ FULL_SIMP_TAC (srw_ss()) [MAP])
    \\ FULL_SIMP_TAC std_ss []
    \\ NTAC 3 (POP_ASSUM (K ALL_TAC))
    \\ `w2n cb DIV 2 + n =
        (w2n cb + 2 * n) DIV 2` by ALL_TAC THEN1
     (ONCE_REWRITE_TAC [ADD_COMM] \\ ONCE_REWRITE_TAC [MULT_COMM]
      \\ SIMP_TAC std_ss [ADD_DIV_ADD_DIV])
    \\ FULL_SIMP_TAC std_ss []
    \\ Q.PAT_ASSUM `bbb s'` MP_TAC
    \\ ONCE_REWRITE_TAC [zHEAP_CodePtr]
    \\ SIMP_TAC std_ss [GSYM word_add_n2w]
    \\ Cases_on `cb` \\ FULL_SIMP_TAC std_ss [w2n_n2w,word_add_n2w]
    \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB,ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [MOD64_DIV2_MOD63]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Return *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_1_WEAKEN_ALT (prepare zBC_Return_1) |> SPEC_ALL
                     |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ FULL_SIMP_TAC std_ss [HD,TL,isCodePtr_def,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ SIMP_TAC std_ss [bc_adjust_def,isCodePtr_def,getCodePtr_def]
    \\ `zPC (n2w (2 * (w2n cb DIV 2 + n))) = zPC (cb + n2w (2 * n))` by ALL_TAC THEN1
     (AP_TERM_TAC \\ SIMP_TAC std_ss [LEFT_ADD_DISTRIB]
      \\ IMP_RES_TAC EVEN_LEMMA
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,n2w_w2n])
    \\ FULL_SIMP_TAC std_ss []
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM]
    \\ REPEAT STRIP_TAC \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* PushExc *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_PushExc
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ ASM_SIMP_TAC (srw_ss()) [bc_adjust_def]
    \\ SIMP_TAC std_ss [reintro_word_sub]
    \\ `SUC (LENGTH (TL
         (MAP (bc_adjust (cb,sb,ev)) s1.stack ++
        Number 0::stack))) = LENGTH s1.stack + SUC (LENGTH stack)` by ALL_TAC
    THEN1 (Cases_on `s1.stack` \\ SRW_TAC [] [] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [GSYM ADD_ASSOC]
    \\ SIMP_TAC (srw_ss()) [HD_CONS_TL] \\ SIMP_TAC std_ss [reintro_word_sub]
    \\ `-n2w (8 * s1.handler + 8 * SUC (LENGTH stack)) +
            cs.stack_trunk = sb + -n2w (8 * s1.handler)` by ALL_TAC THEN1
     (Q.PAT_ASSUM `bbb = sb` (ASSUME_TAC o GSYM)
      \\ FULL_SIMP_TAC std_ss []
      \\ FULL_SIMP_TAC std_ss [GSYM word_add_n2w,word_sub_intro]
      \\ FULL_SIMP_TAC std_ss [WORD_SUB_PLUS] \\ SRW_TAC [] [])
    \\ FULL_SIMP_TAC std_ss []
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC std_ss [reintro_word_sub]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* PopExc *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (zBC_PopExc
         |> DISCH ``l1 ++ StackPtr (w2n (cs.stack_trunk -
                      n2w (8 * sp)) DIV 2)::l2 = xss``
         |> SIMP_RULE std_ss [] |> prepare
         |> spec_to_spec_1
         |> Q.INST [`l1`|->`MAP (bc_adjust (cb,sb,ev)) l1`,
                    `l2`|->`MAP (bc_adjust (cb,sb,ev)) l2 ++ Number 0::stack`,
                    `x1`|->`bc_adjust (cb,sb,ev) x'`,
                    `sp`|->`sp + SUC (LENGTH (stack:bc_value list))`]
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ STRIP_TAC THEN1
     (ASM_SIMP_TAC std_ss [MAP,APPEND,HD,TL,MAP_APPEND,APPEND_11,
        GSYM APPEND_ASSOC,CONS_11]
      \\ STRIP_TAC THEN1 (FULL_SIMP_TAC (srw_ss()) [])
      \\ Q.PAT_ASSUM `xx = sb` (ASSUME_TAC o GSYM)
      \\ ASM_SIMP_TAC std_ss [bc_adjust_def]
      \\ FULL_SIMP_TAC std_ss [word_arith_lemma1,LEFT_ADD_DISTRIB]
      \\ FULL_SIMP_TAC std_ss [MULT_CLAUSES,AC ADD_COMM ADD_ASSOC])
    \\ FULL_SIMP_TAC (srw_ss()) [MAP,MAP_APPEND,HD,TL,APPEND]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [GSYM ADD_ASSOC]
    \\ FULL_SIMP_TAC std_ss [reintro_word_sub]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC std_ss [reintro_word_sub]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [])
  THEN1 (* Ref *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Ref
         |> spec_to_spec_1
         |> Q.INST [`ptr`|->`if ev then 2 * (ptr+1) else 2 * (ptr+1) + 1`,`l`|->`n`]
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,isCodePtr_def,APPEND,NOT_CONS_NIL]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [bc_adjust_def]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ FULL_SIMP_TAC std_ss [GSYM ADD_ASSOC]
    \\ REPEAT STRIP_TAC THEN1
     (FULL_SIMP_TAC (srw_ss()) [ref_adjust_def,LET_DEF]
      \\ `n' = ptr` by (Cases_on `ev` \\ FULL_SIMP_TAC std_ss [] \\ DECIDE_TAC)
      \\ FULL_SIMP_TAC std_ss []
      \\ `?x. (\x. x NOTIN FDOM s1.refs) x` by ALL_TAC
      THEN1 (FULL_SIMP_TAC std_ss [EXISTS_NOT_FDOM_NUM])
      \\ IMP_RES_TAC whileTheory.LEAST_INTRO
      \\ FULL_SIMP_TAC std_ss []
      \\ METIS_TAC [])
    THEN1 (Cases_on `ev` \\ fs [ref_globals_def] \\ DECIDE_TAC)
    THEN1 (RES_TAC \\ Cases_on `ev` \\ FULL_SIMP_TAC (srw_ss()) [ODD_EVEN_SIMP])
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`bc_adjust (cb,sb,ev) v`,`x3`]
    \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(b1 = b2) ==> (b1 ==> b2)``)
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
    \\ simp[ref_adjust_def,GSYM fmap_EQ,FDOM_FUPDATE,FUN_EQ_THM,FUNION_DEF]
    \\ REPEAT STRIP_TAC \\ fs [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]
    THEN1 METIS_TAC[]
    \\ simp[FUN_FMAP_DEF]
    \\ fs [FUN_FMAP_DEF,FDOM_FINITE,IMAGE_FINITE,FUNION_DEF,ref_lemma2,ref_lemma,
           FAPPLY_FUPDATE_THM]
    \\ fs [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]
    \\ Cases_on `x = if ev then 2 * ptr + 2 else 2 * ptr + 3` \\ fs []
    THEN1 (fs [ref_lemma,ref_lemma2,MAP_REPLICATE,ref_lemma
            |> SIMP_RULE std_ss [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]])
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(x2 = y2) /\ (b1 ==> (x1 = y1)) ==>
         ((if b1 then x1 else x2) = (if b1 then y1 else y2))``)
    \\ REPEAT STRIP_TAC \\ TRY (SRW_TAC [] [] \\ NO_TAC)
    \\ fs [ref_lemma,ref_lemma2,MAP_REPLICATE,ref_lemma
            |> SIMP_RULE std_ss [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]]
    \\ `n' <> ptr` by ALL_TAC \\ fs []
    \\ REPEAT STRIP_TAC \\ fs [])
  THEN1 (* RefByte *) ERROR_TAC
  THEN1 (* Deref *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Deref
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,isNumber_def,getNumber_def]
    \\ Q.PAT_ABBREV_TAC`v:ref_value = a ' b`
    \\ `v = ValueArray (MAP (bc_adjust (cb,sb,ev)) vs)` by
     (simp[Abbr`v`,ref_adjust_def,FUN_FMAP_DEF,FUNION_DEF] >>
      reverse IF_CASES_TAC >- (fs[FLOOKUP_DEF] >> METIS_TAC[]) >>
      fs[FLOOKUP_DEF] >> qmatch_assum_rename_tac`z IN FDOM s1.refs` >>
      `z = ptr` by (Cases_on`ev`>>fsrw_tac[ARITH_ss][]) >>
      BasicProvers.VAR_EQ_TAC >>
      Q.PAT_ABBREV_TAC `z = X DIV 2` >>
      `z = ptr + 1` by ALL_TAC THEN1
       (UNABBREV_ALL_TAC \\ SRW_TAC [] []
        \\ fs [DIV_EQ_X] \\ DECIDE_TAC)
      \\ fs [])
    \\ Q.UNABBREV_TAC`v` \\ POP_ASSUM SUBST1_TAC
    \\ SIMP_TAC std_ss [isValueArray_def,getValueArray_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH] \\ STRIP_TAC THEN1 simp[]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`RefPtr (if ev then 2 * (ptr+1) else 2 * (ptr+1) + 1)`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC,bc_adjust_def,
         MAP,getTag_def] \\ fs [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC])
  THEN1 (* DerefByte *) ERROR_TAC
  THEN1 (* Update *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Update
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def,isNumber_def,getNumber_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ Q.PAT_ABBREV_TAC`v:ref_value = a ' b`
    \\ `v = ValueArray (MAP (bc_adjust (cb,sb,ev)) vs)` by
     (simp[Abbr`v`,ref_adjust_def,FUN_FMAP_DEF,FUNION_DEF] >>
      reverse IF_CASES_TAC >- (fs[FLOOKUP_DEF] >> METIS_TAC[]) >>
      fs[FLOOKUP_DEF] >> qmatch_assum_rename_tac`z IN FDOM s1.refs` >>
      `z = ptr` by (Cases_on`ev`>>fsrw_tac[ARITH_ss][]) >>
      BasicProvers.VAR_EQ_TAC >>
      Q.PAT_ABBREV_TAC `z = X DIV 2` >>
      `z = ptr + 1` by ALL_TAC THEN1
       (UNABBREV_ALL_TAC \\ SRW_TAC [] []
        \\ fs [DIV_EQ_X] \\ DECIDE_TAC)
      \\ fs [])
    \\ Q.UNABBREV_TAC`v` \\ POP_ASSUM SUBST1_TAC
    \\ SIMP_TAC std_ss [isValueArray_def,getValueArray_def]
    \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
         LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
         LENGTH] \\ STRIP_TAC THEN1 simp[]
    \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`Number (&n)`,
         `RefPtr (if ev then 2 * (ptr+1) else 2 * (ptr+1) + 1)`]
    \\ `FUNION (ref_adjust (cb,sb,ev)
           (s1.refs |+ (ptr,ValueArray (LUPDATE x' n vs))))
               (FUNION (ref_globals (cb,sb,ev) s1.globals) f2) =
        FUNION (ref_adjust (cb,sb,ev) s1.refs)
          (FUNION (ref_globals (cb,sb,ev) s1.globals) f2) |+
           (if ev then 2 * (ptr+1) else 2 * (ptr+1) + 1,
            ValueArray (LUPDATE (bc_adjust (cb,sb,ev) x') n
                       (MAP (bc_adjust (cb,sb,ev)) vs)))` by ALL_TAC
    \\ TRY (FULL_SIMP_TAC (std_ss++star_ss) [LEFT_ADD_DISTRIB,GSYM ADD_ASSOC]
            \\ NO_TAC)
    \\ simp[ref_adjust_def,GSYM fmap_EQ,FDOM_FUPDATE,FUN_EQ_THM,FUNION_DEF] >>
    conj_tac >- METIS_TAC[] >>
    simp[FUN_FMAP_DEF] >>
    gen_tac >>
    reverse IF_CASES_TAC >- (
      simp[FAPPLY_FUPDATE_THM,FUNION_DEF] >>
      rw[] >> fs[] >> rw[] >> fs[] >>
      METIS_TAC[]) >>
    fs[ref_lemma]
    \\ fs [LUPDATE_MAP]
    \\ simp[FAPPLY_FUPDATE_THM,ref_lemma,ref_lemma2]
    \\ Cases_on `n' = ptr` \\ fs [LUPDATE_MAP]
    \\ fs [FUN_FMAP_DEF,FDOM_FINITE,IMAGE_FINITE,FUNION_DEF,ref_lemma2,ref_lemma])
  THEN1 (* UpdateByte *) ERROR_TAC
  THEN1 (* Length *)
    (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
     \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
     \\ REPEAT STRIP_TAC
     \\ (prepare zBC_Length
          |> spec_to_spec_1
          |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
          |> DISCH_ALL |> RW [AND_IMP_INTRO]
          |> MATCH_MP_TAC)
     \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
          isRefPtr_def,getRefPtr_def,isNumber_def,getNumber_def]
     \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
     \\ Q.PAT_ABBREV_TAC`v:ref_value = a ' b`
    \\ `v = ValueArray (MAP (bc_adjust (cb,sb,ev)) vs)` by
     (simp[Abbr`v`,ref_adjust_def,FUN_FMAP_DEF,FUNION_DEF] >>
      reverse IF_CASES_TAC >- (fs[FLOOKUP_DEF] >> METIS_TAC[]) >>
      fs[FLOOKUP_DEF] >> qmatch_assum_rename_tac`z IN FDOM s1.refs` >>
      `z = ptr` by (Cases_on`ev`>>fsrw_tac[ARITH_ss][]) >>
      BasicProvers.VAR_EQ_TAC >>
      Q.PAT_ABBREV_TAC `z = X DIV 2` >>
      `z = ptr + 1` by ALL_TAC THEN1
       (UNABBREV_ALL_TAC \\ SRW_TAC [] []
        \\ fs [DIV_EQ_X] \\ DECIDE_TAC)
      \\ fs [])
     \\ Q.UNABBREV_TAC`v` \\ POP_ASSUM SUBST1_TAC
     \\ SIMP_TAC std_ss [isValueArray_def,getValueArray_def]
     \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
          LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
          LENGTH]
     \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
     \\ REPEAT STRIP_TAC
     \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
     \\ simp[bc_adjust_def]
     \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
     \\ simp[SEP_DISJ_def]
     \\ FULL_SIMP_TAC (std_ss++star_ss++ARITH_ss)[ADD1])
  THEN1 (* LengthByte *)
    (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
     \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
     \\ REPEAT STRIP_TAC
     \\ (prepare zBC_LengthByte
          |> spec_to_spec_1
          |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
          |> DISCH_ALL |> RW [AND_IMP_INTRO]
          |> MATCH_MP_TAC)
     \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
          isRefPtr_def,getRefPtr_def,isNumber_def,getNumber_def]
     \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
     \\ Q.PAT_ABBREV_TAC`v:ref_value = a ' b`
     \\ `v = ByteArray vs`  by
     (simp[Abbr`v`,ref_adjust_def,FUN_FMAP_DEF,FUNION_DEF] >>
      reverse IF_CASES_TAC >- (fs[FLOOKUP_DEF] >> METIS_TAC[]) >>
      fs[FLOOKUP_DEF] >> qmatch_assum_rename_tac`z IN FDOM s1.refs` >>
      `z = ptr` by (Cases_on`ev`>>fsrw_tac[ARITH_ss][]) >>
      BasicProvers.VAR_EQ_TAC >>
      Q.PAT_ABBREV_TAC `z = X DIV 2` >>
      `z = ptr + 1` by ALL_TAC THEN1
       (UNABBREV_ALL_TAC \\ SRW_TAC [] []
        \\ fs [DIV_EQ_X] \\ DECIDE_TAC)
      \\ fs [])
     \\ Q.UNABBREV_TAC`v` \\ POP_ASSUM SUBST1_TAC
     \\ SIMP_TAC std_ss [isByteArray_def,getByteArray_def]
     \\ ASM_SIMP_TAC std_ss [x64_inst_length_def,x64_def,small_offset_def,
          LEFT_ADD_DISTRIB,GSYM ADD_ASSOC,word_arith_lemma1,x64_length_def,
          LENGTH]
     \\ ASM_SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM,getContent_def,EL_MAP]
     \\ REPEAT STRIP_TAC
     \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
     \\ simp[bc_adjust_def]
     \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
     \\ simp[SEP_DISJ_def]
     \\ FULL_SIMP_TAC (std_ss++star_ss++ARITH_ss)[ADD1])
  THEN1 (* Galloc *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Tick
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def,ref_globals_alloc]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* Gupdate *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Gupdate
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def,ref_addr_def,getContent_def,
         ref_globals_lemma]
    \\ Q.PAT_ABBREV_TAC`v:ref_value = a ' b`
    \\ `v = ValueArray (ref_globals_list (OPT_MAP (bc_adjust (cb,sb,ev))
          s1.globals) globals_count)` by
     (UNABBREV_ALL_TAC \\ fs [FUNION_DEF,ref_globals_lemma]
      \\ Cases_on `ev` \\ fs [ref_globals_def,getRefPtr_def])
    \\ fs [getValueArray_def,isBlock_def,isValueArray_def,LENGTH_ref_globals_list]
    \\ STRIP_TAC
    THEN1 (SRW_TAC [] [isRefPtr_def] \\ fs [globals_count_def] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`Number (&n)`,`if ev then RefPtr 0 else RefPtr 1`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC]
    \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(b1 = b2) ==> (b1 ==> b2)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
    \\ fs [GSYM fmap_EQ_THM] \\ REPEAT STRIP_TAC THEN1
     (Cases_on `ev` \\ fs [ref_globals_def,ref_adjust_def,LET_DEF,getRefPtr_def]
      \\ fs [EXTENSION] \\ REPEAT STRIP_TAC \\ fs [] \\ EQ_TAC \\ REPEAT STRIP_TAC
      \\ fs [] \\ METIS_TAC [])
    \\ fs [FUNION_DEF,FAPPLY_FUPDATE_THM,ref_lemma,ref_globals_lemma]
    \\ Cases_on `ev`
    \\ fs [ref_globals_def,FAPPLY_FUPDATE_THM,getRefPtr_def,
           GSYM LUPDATE_ref_globals_list]
    \\ RES_TAC \\ IMP_RES_TAC ODD_NOT_ZERO_ETC \\ fs []
    \\ SRW_TAC [] [] \\ RES_TAC \\ IMP_RES_TAC ODD_NOT_ZERO_ETC \\ fs [])
  THEN1 (* Gread *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Gread
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def,ref_addr_def,getContent_def,
         ref_globals_lemma]
    \\ Q.PAT_ABBREV_TAC`vv:ref_value = a ' b`
    \\ `vv = ValueArray (ref_globals_list (OPT_MAP (bc_adjust (cb,sb,ev))
          s1.globals) globals_count)` by
     (UNABBREV_ALL_TAC \\ fs [FUNION_DEF,ref_globals_lemma]
      \\ Cases_on `ev` \\ fs [ref_globals_def,getRefPtr_def])
    \\ fs [getValueArray_def,isBlock_def,isValueArray_def,LENGTH_ref_globals_list]
    \\ STRIP_TAC
    THEN1 (SRW_TAC [] [isRefPtr_def] \\ fs [globals_count_def] \\ DECIDE_TAC)
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`if ev then RefPtr 0 else RefPtr 1`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC]
    \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(b1 = b2) ==> (b1 ==> b2)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) \\ fs [HD_CONS_TL]
    \\ fs [EL_ref_globals_list])
  THEN1 (* Tick *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Tick
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* Print *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_Print
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def,bv_to_string_bc_adjust]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w]
    \\ Q.MATCH_ASSUM_RENAME_TAC `s1.stack = y::xs`
    \\ STRIP_TAC THEN1
     (FULL_SIMP_TAC std_ss [EVEN_w2n] \\ Q.PAT_ASSUM `~cb ' 0` MP_TAC
      \\ SIMP_TAC std_ss [GSYM word_mul_n2w] \\ blastLib.BBLAST_TAC)
    \\ FULL_SIMP_TAC std_ss []
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ Cases_on `s.local.printing_on = 0x0w`
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    THEN1 (Q.LIST_EXISTS_TAC [`Number 0`,`x3`]
      \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
    \\ Q.LIST_EXISTS_TAC [`Number 0`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC])
  THEN1 (* PrintWord8 *) ERROR_TAC
  THEN1 (* PrintC *)
   (SIMP_TAC std_ss [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_1_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ (prepare zBC_PrintC
         |> spec_to_spec_1
         |> MATCH_MP SPEC_1_WEAKEN |> SPEC_ALL
         |> DISCH_ALL |> RW [AND_IMP_INTRO]
         |> MATCH_MP_TAC)
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ `(CHR (ORD c MOD 256)) = c` by ALL_TAC
    THEN1 (FULL_SIMP_TAC std_ss [ORD_BOUND,CHR_ORD])
    \\ FULL_SIMP_TAC (srw_ss()) [SNOC_APPEND,bump_pc_def]
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,LET_DEF,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ Cases_on `s.local.printing_on = 0x0w`
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) [GSYM ADD_ASSOC]));

val zBC_HEAP_THM = prove(
  ``EVEN (w2n cb) /\ (cs.stack_trunk - n2w (8 * SUC (LENGTH stack)) = sb) ==>
    !s1 s2.
      bc_next s1 s2 ==> (s1.inst_length = x64_inst_length) /\
      (!r. r IN FDOM f2 ==> if ev then ODD r else EVEN r) ==>
      SPEC X64_MODEL
         (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
          zPC (cb + n2w (2 * s1.pc)) * ~zS)
        ((cb + n2w (2 * s1.pc),x64 (2 * s1.pc) (THE (bc_fetch s1)))
         INSERT code_abbrevs cs)
        (zBC_HEAP s2 (x,cs,stack,s,out) (cb,sb,ev,f2) *
         zPC (cb + n2w (2 * s2.pc)) * ~zS \/
         zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC
  \\ MP_TAC (SPEC_1_zBC_HEAP_THM |> MP_CANON |> SPEC_ALL)
  \\ fs [] \\ REPEAT STRIP_TAC  \\ IMP_RES_TAC SPEC_1_IMP_SPEC);

val zBC_HEAP_Stop = prove(
  ``(bc_fetch s1 = SOME (Stop b)) ==>
    SPEC X64_MODEL
       (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
        zPC (cb + n2w (2 * s1.pc)) * ~zS)
      ((cb + n2w (2 * s1.pc),x64 (2 * s1.pc) (THE (bc_fetch s1)))
       INSERT code_abbrevs cs)
      (zBC_HEAP (s1 with stack := bool_to_val b::s1.stack)
         (x,cs,stack,s,out) (cb,sb,ev,f2) *
       zPC s.local.stop_addr * ~zS \/ zHEAP_ERROR cs)``,
  Cases_on `b` \\ fs [x64_def]
  THEN1 (* Stop T *)
   (SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Stop_T) |> SPEC_ALL
                  |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,HD_CONS_TL])
  THEN1 (* Stop F *)
   (SIMP_TAC (srw_ss()) [x64_def,bump_pc_def,zBC_HEAP_def,LET_DEF,MAP_APPEND,MAP]
    \\ SIMP_TAC std_ss [APPEND,HD,TL,SEP_CLAUSES,GSYM SPEC_PRE_EXISTS]
    \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC (MATCH_MP SPEC_WEAKEN (prepare zBC_Stop_F) |> SPEC_ALL
                  |> DISCH_ALL |> RW [AND_IMP_INTRO])
    \\ ASM_SIMP_TAC (srw_ss()) []
    \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC std_ss [APPEND,TL,HD,x64_length_def,x64_def,
         LENGTH,x64_inst_length_def,LEFT_ADD_DISTRIB,word_arith_lemma1]
    \\ SIMP_TAC std_ss [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ FULL_SIMP_TAC (srw_ss()) [SEP_DISJ_def]
    \\ Q.LIST_EXISTS_TAC [`x2`,`x3`]
    \\ FULL_SIMP_TAC (std_ss++star_ss) []
    \\ FULL_SIMP_TAC std_ss [HD,TL,bc_adjust_def,MAP,APPEND,
         isRefPtr_def,getRefPtr_def]
    \\ FULL_SIMP_TAC (srw_ss()) [word_mul_n2w,HD_CONS_TL]));

(* SPEC_1 theorem *)

val TEMPORAL_APPEND_CODE = prove(
  ``TEMPORAL X64_MODEL ((w,xs ++ ys) INSERT s) t <=>
    TEMPORAL X64_MODEL ((w,xs) INSERT (w + n2w (LENGTH xs),ys) INSERT s) t``,
  fs [TEMPORAL_def,X64_MODEL_def,GSYM CODE_POOL_INSERT_INSERT]);

val CODE_POOL_LEMMA = prove(
  ``!c c' i. ?r. CODE_POOL i (c UNION c') = CODE_POOL i c * r``,
  REPEAT STRIP_TAC \\ REWRITE_TAC [CODE_POOL_def,IMAGE_UNION,BIGUNION_UNION,STAR_def]
  \\ Q.EXISTS_TAC `\s. s = BIGUNION (IMAGE i c') DIFF BIGUNION (IMAGE i c)`
  \\ ONCE_REWRITE_TAC [FUN_EQ_THM] \\ SIMP_TAC std_ss []
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ FULL_SIMP_TAC bool_ss [SPLIT_def,EXTENSION,IN_BIGUNION,IN_DIFF,
       IN_UNION,DISJOINT_DEF,IN_INTER,NOT_IN_EMPTY] \\ METIS_TAC []);

val TEMPORAL_EXTEND_CODE = prove(
  ``TEMPORAL m c phi ==> !c1. TEMPORAL m (c UNION c1) phi``,
  PairCases_on `m` \\ fs [TEMPORAL_def] \\ REPEAT STRIP_TAC
  \\ `?r1. CODE_POOL m2 (c UNION c1) = CODE_POOL m2 c * r1` by
        METIS_TAC [CODE_POOL_LEMMA]
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`seq'`,`r1 * r`])
  \\ fs [STAR_ASSOC]);

val TEMPORAL_SUBSET_CODE = prove(
  ``TEMPORAL m c p /\ c SUBSET c1 ==> TEMPORAL m c1 p``,
  REPEAT STRIP_TAC
  \\ `c1 = c UNION c1` by (fs [SUBSET_DEF,EXTENSION] \\ METIS_TAC [])
  \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [th])
  \\ MATCH_MP_TAC (MP_CANON TEMPORAL_EXTEND_CODE)
  \\ fs []);

val zBC_HEAP_1 = prove(
  ``EVEN (w2n cb) /\ (cs.stack_trunk - n2w (8 * SUC (LENGTH stack)) = sb) ==>
    !s1 s2.
      bc_next s1 s2 ==> (s1.inst_length = x64_inst_length) /\
      (!r. r IN FDOM f2 ==> if ev then ODD r else EVEN r) ==>
      SPEC_1 X64_MODEL
         (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
          zPC (cb + n2w (2 * s1.pc)) * ~zS)
        ((cb,x64_code 0 s1.code)
         INSERT code_abbrevs cs)
        (zBC_HEAP s2 (x,cs,stack,s,out) (cb,sb,ev,f2) *
         zPC (cb + n2w (2 * s2.pc)) * ~zS) (zHEAP_ERROR cs)``,
  REPEAT STRIP_TAC
  \\ (MP_CANON SPEC_1_zBC_HEAP_THM
      |> SPEC_ALL |> RW [GSYM AND_IMP_INTRO]
      |> UNDISCH_ALL |> ASSUME_TAC)
  \\ `?i. bc_fetch s1 = SOME i` by fs [bc_next_cases]
  \\ fs [bc_fetch_def] \\ rfs []
  \\ IMP_RES_TAC x64_code_EQ_x64 \\ fs []
  \\ fs [TEMPORAL_APPEND_CODE,SPEC_1_def]
  \\ IMP_RES_TAC TEMPORAL_SUBSET_CODE
  \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SUBSET_DEF])
  |> SIMP_RULE std_ss [PULL_FORALL] |> SPEC_ALL
  |> SIMP_RULE std_ss [AND_IMP_INTRO,GSYM PULL_FORALL,GSYM CONJ_ASSOC]

val zBC_HEAP_N = prove(
  ``!n s1 s2.
      NRC bc_next n s1 s2 ==> EVEN (w2n cb) /\
      (cs.stack_trunk - n2w (8 * SUC (LENGTH stack)) = sb) /\
      (s1.inst_length = x64_inst_length) /\
      (!r. r IN FDOM f2 ==> if ev then ODD r else EVEN r) ==>
      SPEC_N n X64_MODEL
        (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) *
         zPC (cb + n2w (2 * s1.pc)) * ~zS)
        ((cb,x64_code 0 s1.code) INSERT code_abbrevs cs)
        (zBC_HEAP s2 (x,cs,stack,s,out) (cb,sb,ev,f2) *
         zPC (cb + n2w (2 * s2.pc)) * ~zS) (zHEAP_ERROR cs)``,
  Induct >- (
    rw[NRC,SPEC_N_def,N_NEXT_def] >>
    MATCH_ACCEPT_TAC TEMPORAL_IMP_T_OR_F_EVENTUALLY ) >>
  rw[NRC] >>
  qmatch_assum_rename_tac`bc_next s1 sb` >>
  first_x_assum(qspecl_then[`sb`,`s2`]mp_tac) >>
  MATCH_MP_TAC IMP_IMP >>
  conj_tac >- rw[] >>
  MATCH_MP_TAC IMP_IMP >>
  conj_tac >- (
    rw[] >>
    imp_res_tac NRC_RTC >>
    imp_res_tac RTC_bc_next_preserves >>
    imp_res_tac bc_next_preserves_inst_length >>
    PROVE_TAC[] ) >>
  strip_tac >>
  HO_MATCH_MP_TAC SPEC_N_1_IMP_SUC >>
  qmatch_assum_abbrev_tac`SPEC_N n model pre code post err` >>
  qexists_tac`pre` >>
  conj_tac >- (
    METIS_TAC[bc_next_preserves_code] ) >>
  UNABBREV_ALL_TAC >>
  MATCH_MP_TAC zBC_HEAP_1 >>
  rw[])

val PULL_EXISTS_IMP =
  METIS_PROVE [] ``(((?x. P x) ==> Q) <=> (!x. P x ==> Q)) /\
                   (((?x. P x) \/ Q) <=> (?x. P x \/ Q))``

val SPEC_N_APPEND_CODE = prove(
  ``SPEC_N k X64_MODEL p ((w,xs) INSERT c) q err ==>
    !ys. SPEC_N k X64_MODEL p ((w,xs++ys) INSERT c) q err``,
  fs [SPEC_N_def,TEMPORAL_APPEND_CODE] \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC TEMPORAL_SUBSET_CODE
  \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SUBSET_DEF,IN_INSERT]);

val fun2set_EMPTY = prove(
  ``(fun2set (f,df) = ) = (df = EMPTY)``,
  fs [fun2set_def,EXTENSION]);

val zCODE_HEAP_AUX_NIL = prove(
  ``zCODE_HEAP_AUX T a [] = emp``,
  fs [FUN_EQ_THM,zCODE_HEAP_AUX_def,SEP_ARRAY_def,SEP_CLAUSES,
      SEP_EXISTS_THM]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,emp_def,fun2set_EMPTY]
  \\ fs [zCODE_SET_def,zCODE_def,CODE_POOL_def]);

val IMP_INTRO = METIS_PROVE [] ``(~b \/ c) <=> (b ==> c)``
val IMP2_INTRO = METIS_PROVE [] ``(c \/ ~b) <=> (b ==> c)``

val emp_fun2set = prove(
  ``emp (fun2set (f,df)) = (df = EMPTY)``,
  fs [emp_def,fun2set_def,EXTENSION]);

val one_lemma =
  set_sepTheory.one_fun2set
  |> Q.SPECL [`a`,`x`,`emp`] |> GEN_ALL
  |> SIMP_RULE std_ss [emp_fun2set,SEP_CLAUSES]

val zCODE_HEAP_AUX_MEM = prove(
  ``zCODE_HEAP_AUX b a ys s /\ LENGTH ys <> 0 ==> ?x1 x2. zMem a x1 x2 IN s``,
  Cases_on `b` \\ fs [zCODE_HEAP_AUX_def,SEP_EXISTS_THM]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
  \\ REPEAT STRIP_TAC \\ Cases_on `ys`
  \\ fs [SEP_ARRAY_def,one_lemma,set_sepTheory.one_fun2set]
  \\ fs [zCODE_def,zCODE_SET_def,CODE_POOL_def,PULL_EXISTS,
         X64_INSTR_def,zBYTE_MEMORY_Z_def,zBYTE_MEMORY_ANY_def,
         SEP_EXISTS_THM,SEP_EQ_def,zBYTE_MEMORY_ANY_SET_def]);

val x64_2set_IN_IMP = prove(
  ``zMem a x1 x2 IN x64_2set s ==>
    zMem a y1 y2 IN x64_2set s ==>
    ((x1,x2) = (y1,y2))``,
  PairCases_on `s` \\ fs [x64_2set_def,x64_2set'_def]);

val zCODE_HEAP_AUX_TWICE = prove(
  ``(p *
     zCODE_HEAP_AUX b cs.code_heap_ptr xs *
     zCODE_HEAP_AUX T cs.code_heap_ptr ys) (x64_2set s) ==>
    (LENGTH xs = 0) \/ (LENGTH ys = 0)``,
  CCONTR_TAC \\ fs []
  \\ Q.PAT_ASSUM `ff ((x64_2set s))` MP_TAC
  \\ fs [] \\ fs [STAR_def]
  \\ REPEAT STRIP_TAC
  \\ fs [IMP_INTRO,IMP2_INTRO] \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC zCODE_HEAP_AUX_MEM
  \\ fs [SPLIT_def]
  \\ `zMem cs.code_heap_ptr x1 x2 IN x64_2set s /\
      zMem cs.code_heap_ptr x1' x2' IN x64_2set s` by
       (fs [EXTENSION] \\ METIS_TAC [])
  \\ IMP_RES_TAC x64_2set_IN_IMP \\ fs []
  \\ SRW_TAC [] []
  \\ fs [DISJOINT_DEF,EXTENSION]
  \\ METIS_TAC []);

val set_lemma = prove(
  ``{(a',[f a']) | a' = a} = {(a,[f a])}``,
  fs [EXTENSION]);

val CODE_POOL_X64_INSTR_SING_LEMMA = prove(
  ``CODE_POOL X64_INSTR {(a',[f a']) | a' = a} =
    \s. s = {zMem a (SOME (f a,X64_INSTR_PERM T)) T}``,
  fs [Once FUN_EQ_THM,set_lemma] \\ fs [X64_INSTR_def,CODE_POOL_def]);

val SPLIT_SING = prove(
  ``(SPLIT x ({y},s) <=> (x = y INSERT s) /\ ~(y IN s)) /\
    (SPLIT x (s,{y}) <=> (x = y INSERT s) /\ ~(y IN s))``,
  fs [SPLIT_def,EXTENSION] \\ METIS_TAC []);

val sing_set = prove(
  ``(!x'. x' IN s <=> (x' = y)) <=> (s = {y})``,
  fs [EXTENSION]);

val zCODE_HEAP_AUX_T_UNROLL = prove(
  ``!frame f2 u.
      (frame * zCODE_HEAP_AUX T a (h::code) * f2) (x64_2set u) <=>
      (frame * zCODE_HEAP_AUX T a [h] * zCODE_HEAP_AUX T (a + 0x1w) code *
        f2) (x64_2set u)``,
  REPEAT STRIP_TAC
  \\ ONCE_REWRITE_TAC [STAR_COMM] \\ fs [STAR_ASSOC]
  \\ Q.SPEC_TAC (`f2 * frame`,`ff`) \\ REPEAT STRIP_TAC
  \\ fs [zCODE_HEAP_AUX_def,SEP_CLAUSES,SEP_EXISTS_THM,FUN_EQ_THM]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
  \\ fs [SEP_ARRAY_def,SEP_CLAUSES,set_sepTheory.one_fun2set,one_lemma]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ STRIP_TAC THEN1
   (Q.LIST_EXISTS_TAC [`{a}`,`f`,`df DELETE a`,`f`] \\ fs []
    \\ fs [zCODE_def,zCODE_SET_def]
    \\ fs [STAR_def,CODE_POOL_X64_INSTR_SING_LEMMA,SPLIT_SING,PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`v DELETE zMem a (SOME (h,X64_INSTR_PERM T)) T`,`u'`]
    \\ `zMem a (SOME (h,X64_INSTR_PERM T)) T IN v` by
      fs [STAR_def,CODE_POOL_def,SPLIT_SING,PULL_EXISTS,X64_INSTR_def]
    \\ `zMem a (SOME (h,X64_INSTR_PERM T)) T IN x64_2set u` by
          (fs [SPLIT_def,EXTENSION,DISJOINT_DEF] \\ METIS_TAC [])
    \\ fs [] \\ REPEAT STRIP_TAC
    THEN1 (fs [SPLIT_def,EXTENSION,DISJOINT_DEF] \\ METIS_TAC [])
    THEN1 (fs [SPLIT_def,EXTENSION,DISJOINT_DEF] \\ METIS_TAC [])
    \\ fs [CODE_POOL_def,PULL_EXISTS,X64_INSTR_def,EXTENSION]
    \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
    THEN1 (METIS_TAC [])
    \\ Q.LIST_EXISTS_TAC [`s`,`a'`] \\ fs [])
  \\ Q.LIST_EXISTS_TAC [`a INSERT df'`,`(a =+ f a) f'`] \\ fs []
  \\ fs [APPLY_UPDATE_THM]
  \\ `~(a IN df')` by ALL_TAC THEN1
   (REPEAT STRIP_TAC \\ fs [GSYM STAR_ASSOC]
    \\ fs [zCODE_HEAP_AUX_def,SEP_CLAUSES,SEP_EXISTS_THM,
           STAR_def,zCODE_def,CODE_POOL_def,zCODE_SET_def,PULL_EXISTS]
    \\ fs [SPLIT_def,PULL_EXISTS]
    \\ RES_TAC
    \\ fs [X64_INSTR_def]
    \\ fs [EXTENSION,PULL_EXISTS,X64_INSTR_def]
    \\ `!x. x IN v ==> x IN x64_2set u` by METIS_TAC []
    \\ fs [sing_set]
    \\ POP_ASSUM MP_TAC
    \\ Q.PAT_ASSUM `!x. bbb = x IN v` (fn th => PURE_REWRITE_TAC [GSYM th])
    \\ REPEAT STRIP_TAC
    \\ fs [METIS_PROVE [] ``(!x. P x \/ Q x ==> D x) <=>
             (!x. P x ==> D x) /\ (!x. Q x ==> D x)``]
    \\ fs [PULL_EXISTS] \\ RES_TAC
    \\ IMP_RES_TAC x64_2set_IN_IMP \\ fs [])
  \\ `(fun2set ((a =+ h) f',(a INSERT df') DELETE a)) =
      (fun2set (f',df'))` by ALL_TAC THEN1
   (fs [fun2set_def,EXTENSION,APPLY_UPDATE_THM]
    \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
    \\ fs [] \\ METIS_TAC [])
  \\ fs []
  \\ fs [STAR_def,CODE_POOL_def,zCODE_def,SPLIT_def,zCODE_SET_def,PULL_EXISTS]
  \\ SRW_TAC [] []
  \\ fs [Once EXTENSION]
  \\ fs [STAR_def,CODE_POOL_def,zCODE_def,SPLIT_def,zCODE_SET_def,PULL_EXISTS]
  \\ `df = {a}` by (fs [EXTENSION] \\ METIS_TAC [])
  \\ fs [APPLY_UPDATE_THM]
  \\ Q.EXISTS_TAC `u'` \\ fs []
  \\ REPEAT STRIP_TAC \\ fs [] \\ METIS_TAC []);

val CODE_POOL_INSERT_NIL = prove(
  ``CODE_POOL X64_INSTR ((a,[]) INSERT s) = CODE_POOL X64_INSTR s``,
  fs [FUN_EQ_THM] \\ fs [CODE_POOL_def,PULL_EXISTS,X64_INSTR_def]);

val CODE_POOL_INSERT_SPLIT = prove(
  ``(pp * zCODE_HEAP_AUX T a [h] * CODE_POOL X64_INSTR s) ss ==>
    (CODE_POOL X64_INSTR ((a,[h]) INSERT s) =
     zCODE_HEAP_AUX T a [h] * CODE_POOL X64_INSTR s)``,
  fs [FUN_EQ_THM] \\ fs [STAR_def] \\ REPEAT STRIP_TAC
  \\ fs [zCODE_HEAP_AUX_def,SEP_CLAUSES,SEP_EXISTS_THM]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
  \\ fs [CODE_POOL_def,PULL_EXISTS]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ STRIP_TAC THEN1
   (fs [SEP_ARRAY_def,SEP_CLAUSES,one_lemma,X64_INSTR_def]
    \\ Q.EXISTS_TAC `{zMem a (SOME (h,X64_INSTR_PERM T)) T}`
    \\ Q.LIST_EXISTS_TAC [`{a}`,`f`]
    \\ fs [SPLIT_SING]
    \\ fs [INSERT_UNION_EQ,IMP_INTRO]
    \\ REPEAT STRIP_TAC
    \\ fs [zCODE_def,CODE_POOL_def,zCODE_SET_def,set_lemma,X64_INSTR_def]
    \\ `df = {a}` by (fs [EXTENSION] \\ METIS_TAC [])
    \\ SRW_TAC [] [] \\ fs []
    \\ SRW_TAC [] [] \\ fs []
    \\ fs [SPLIT_def,PULL_EXISTS]
    \\ RES_TAC
    \\ SRW_TAC [] []
    \\ fs [set_lemma]
    \\ fs [DISJOINT_DEF,EXTENSION,X64_INSTR_def])
  \\ fs [SPLIT_def] \\ SRW_TAC [] []
  \\ fs [SEP_ARRAY_def,SEP_CLAUSES,one_lemma]
  \\ SRW_TAC [] []
  \\ `df' = {a}` by (fs [EXTENSION] \\ METIS_TAC [])
  \\ SRW_TAC [] [] \\ fs [PULL_EXISTS]
  \\ fs [zCODE_def,CODE_POOL_def,zCODE_SET_def,set_lemma]);

val CODE_POOL_SPLIT = prove(
  ``!u t s frame code a pp.
     (pp * zCODE_HEAP_AUX T a code * CODE_POOL X64_INSTR s) (x64_2set t) ==>
     ((frame * CODE_POOL X64_INSTR ((a,code) INSERT s)) (x64_2set u) <=>
      (frame * zCODE_HEAP_AUX T a code * CODE_POOL X64_INSTR s) (x64_2set u))``,
  Induct_on `code` \\ fs [zCODE_HEAP_AUX_NIL,SEP_CLAUSES,CODE_POOL_INSERT_NIL]
  \\ REPEAT STRIP_TAC
  \\ `!frame f2 u.
       (frame * zCODE_HEAP_AUX T a (h::code) * f2) (x64_2set u) =
       (frame * zCODE_HEAP_AUX T a [h] * zCODE_HEAP_AUX T (a+1w) code *
             f2) (x64_2set u)` by METIS_TAC [zCODE_HEAP_AUX_T_UNROLL]
  \\ `CODE_POOL X64_INSTR ((a,h::code) INSERT s) =
      zCODE_HEAP_AUX T a [h] *
      CODE_POOL X64_INSTR ((a+1w,code) INSERT s)` by ALL_TAC THEN1
   (ONCE_REWRITE_TAC [CODE_POOL_INSERT_INSERT |> GSYM |> Q.INST [`xs`|->`[x]`]
          |> RW [APPEND]] \\ fs []
    \\ fs [STAR_ASSOC] \\ RES_TAC
    \\ POP_ASSUM (ASSUME_TAC o GSYM)
    \\ fs [GSYM STAR_ASSOC] \\ fs []
    \\ MATCH_MP_TAC (GEN_ALL CODE_POOL_INSERT_SPLIT)
    \\ fs [STAR_ASSOC]
    \\ METIS_TAC [])
  \\ fs [STAR_ASSOC]
  \\ RES_TAC \\ fs [STAR_ASSOC]
  \\ FIRST_X_ASSUM MATCH_MP_TAC
  \\ METIS_TAC []);

val SPEC_N_zBC_HEAP_MOVE_CODE = prove(
  ``SPEC_N n X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s with code_mode := NONE,out) (cb,sb,ev,f2) *
      zPC p * zS)
     ((cb,code) INSERT code_abbrevs cs)
     (zBC_HEAP s2 (x,cs,stack,s with code_mode := NONE,out) (cb,sb,ev,f2) *
      zPC q * zS)
     (zHEAP_ERROR cs) ==>
    (s.code = code) /\ (s.code_mode = SOME T) /\ (cb = cs.code_heap_ptr) ==>
    SPEC_N n X64_MODEL
     (zBC_HEAP s1 (x,cs,stack,s,out) (cb,sb,ev,f2) * zPC p * zS)
     (code_abbrevs cs)
     (zBC_HEAP s2 (x,cs,stack,s,out) (cb,sb,ev,f2) * zPC q * zS)
     (zHEAP_ERROR cs)``,
  Q.SPEC_TAC (`cb`,`cb`) \\ SIMP_TAC std_ss []
  \\ STRIP_TAC
  \\ IMP_RES_TAC SPEC_N_APPEND_CODE
  \\ POP_ASSUM MP_TAC \\ POP_ASSUM (K ALL_TAC)
  \\ fs [zBC_HEAP_def]
  \\ Q.ABBREV_TAC `s1ss = MAP (bc_adjust (cs.code_heap_ptr,sb,ev)) s1.stack ++
                          Number 0::stack`
  \\ Q.ABBREV_TAC `s2ss = MAP (bc_adjust (cs.code_heap_ptr,sb,ev)) s2.stack ++
                          Number 0::stack`
  \\ fs [LET_DEF,SEP_CLAUSES,zHEAP_def,SPEC_N_def,X64_MODEL_def,TEMPORAL_def]
  \\ fs [T_IMPLIES_def,NOW_def,SEP_EXISTS_THM,SEP_REFINE_def,SEP_CLAUSES,
         PULL_EXISTS,PULL_EXISTS_IMP,PULL_FORALL]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR,T_OR_F_def,
       N_NEXT_THM,EVENTUALLY_def,NOW_def,SEP_EXISTS_THM,SEP_CLAUSES]
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 (METIS_TAC [])
  \\ fs [AND_IMP_INTRO]
  \\ `(vals.code_option = SOME T) /\
      (vals.code_list = code)` by fs [heap_inv_def,code_heap_inv_def]
  \\ `zVALS cs vals = zVALS cs (vals with code_option := NONE) *
      zOPTION_CODE_HEAP (SOME T) cs.code_heap_length
       cs.code_heap_ptr vals.code_list` by
    fs [zVALS_def,zOPTION_CODE_HEAP_def,SEP_CLAUSES,AC STAR_COMM STAR_ASSOC]
  \\ fs [zOPTION_CODE_HEAP_def,zCODE_HEAP_def,SEP_EXISTS_THM,SEP_CLAUSES]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR] \\ rfs []
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`ys`,`state`,`seq'`,`r`,`s'`,`x2`,`x3`,
       `vals with code_option := NONE`])
  \\ FULL_SIMP_TAC std_ss [AC STAR_ASSOC STAR_COMM] \\ fs [STAR_ASSOC]
  \\ `!t frame.
        (frame * CODE_POOL X64_INSTR ((cs.code_heap_ptr,code ++ ys)
           INSERT code_abbrevs cs)) (x64_2set t) =
        (frame * zCODE_HEAP_AUX T cs.code_heap_ptr (code ++ ys) *
            CODE_POOL X64_INSTR (code_abbrevs cs)) (x64_2set t)` by ALL_TAC THEN1
   (REPEAT STRIP_TAC
    \\ MATCH_MP_TAC CODE_POOL_SPLIT
    \\ Q.EXISTS_TAC `s'`
    \\ Q.EXISTS_TAC `zVALS cs (vals with code_option := NONE) *
         zPC p * zS * r` \\ fs [AC STAR_ASSOC STAR_COMM])
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1
   (fs [AC STAR_COMM STAR_ASSOC] \\ DISJ1_TAC
    \\ fs [heap_inv_def] \\ fs [code_heap_inv_def] \\ METIS_TAC [])
  \\ REPEAT STRIP_TAC
  \\ TRY (DISJ2_TAC \\ Q.LIST_EXISTS_TAC [`k`,`ARB`] \\ fs [] \\ NO_TAC)
  \\ rfs [AC STAR_COMM STAR_ASSOC] THEN1
   (DISJ1_TAC \\ Q.LIST_EXISTS_TAC [`k`,`s''`] \\ fs []
    \\ DISJ1_TAC \\ fs [PULL_EXISTS]
    \\ Q.LIST_EXISTS_TAC [`x2'`,`x3'`,`vals' with code_option := SOME T`]
    \\ `(vals'.code_option = NONE) /\
        (vals'.code_list = code)` by
          fs [heap_inv_def] \\ fs [code_heap_inv_def]
    \\ `zVALS cs (vals' with code_option := SOME T) =
        zVALS cs vals' *
        zOPTION_CODE_HEAP (SOME T) cs.code_heap_length
         cs.code_heap_ptr vals'.code_list` by
      fs [zVALS_def,zOPTION_CODE_HEAP_def,SEP_CLAUSES,AC STAR_COMM STAR_ASSOC]
    \\ fs [zOPTION_CODE_HEAP_def]
    \\ STRIP_TAC THEN1
     (fs [heap_inv_def] \\ fs [code_heap_inv_def] \\ METIS_TAC [])
    \\ fs [zCODE_HEAP_def,SEP_EXISTS_THM,SEP_CLAUSES]
    \\ Q.EXISTS_TAC `ys` \\ fs [AC STAR_COMM STAR_ASSOC,SEP_CLAUSES])
  THEN1 (METIS_TAC [])
  \\ DISJ2_TAC \\ Q.LIST_EXISTS_TAC [`k`,`s''`] \\ fs []
  \\ fs [zHEAP_ERROR_def,zHEAP_OUTPUT_def,SEP_CLAUSES,SEP_EXISTS_THM]
  \\ DISJ1_TAC
  \\ Cases_on `vals'.code_option = NONE` \\ fs []
  THEN1
   (Q.LIST_EXISTS_TAC [`output`,
       `vals' with <| code_option := SOME T ;
                      code_list := code |> `]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ fs [zVALS_def,zOPTION_CODE_HEAP_def,zCODE_HEAP_def,SEP_CLAUSES,
         SEP_EXISTS_THM]
    \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ Q.EXISTS_TAC `ys` \\ rfs [AC STAR_ASSOC STAR_COMM])
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
  \\ Cases_on `cs.code_heap_length = 0` THEN1
   (fs [LENGTH_NIL] \\ rfs []
    \\ Q.LIST_EXISTS_TAC [`output`,`vals'`]
    \\ fs [zCODE_HEAP_AUX_NIL,AC STAR_COMM STAR_ASSOC,SEP_CLAUSES])
  \\ `F` by ALL_TAC \\ fs []
  \\ fs [zVALS_def]
  \\ Cases_on `vals'.code_option` \\ fs []
  \\ Q.PAT_ASSUM `xxx (x64_2set s'')` MP_TAC \\ fs []
  \\ CONV_TAC ((RAND_CONV o RATOR_CONV)
       (MOVE_OUT_CONV ``zOPTION_CODE_HEAP (SOME x') cs.code_heap_length
                        cs.code_heap_ptr`` THENC
        MOVE_OUT_CONV ``zCODE_HEAP_AUX T cs.code_heap_ptr``))
  \\ Cases_on `x'` \\ fs [zOPTION_CODE_HEAP_def,SEP_CLAUSES,zCODE_HEAP_def]
  \\ fs [SEP_CLAUSES,SEP_EXISTS_THM]
  \\ FULL_SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
  \\ REPEAT STRIP_TAC \\ fs [IMP_INTRO] \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC zCODE_HEAP_AUX_TWICE
  \\ fs [] \\ DECIDE_TAC);

val zBC_HEAP_N_ALT =
  zBC_HEAP_N |> RW [AND_IMP_INTRO] |> SPEC_ALL |> UNDISCH_ALL
    |> Q.INST [`s`|->`s with code_mode := NONE`]
    |> MATCH_MP SPEC_N_zBC_HEAP_MOVE_CODE
    |> DISCH_ALL |> RW [AND_IMP_INTRO,GSYM CONJ_ASSOC]

val SPEC_N_Stop =
  MATCH_MP SPEC_IMP_SPEC_N (UNDISCH zBC_HEAP_Stop)

val zBYTECODE_DIVERGED_def = Define `
  zBYTECODE_DIVERGED output (cs,cb) =
    ALWAYS
     (EVENTUALLY
       (NOW (SEP_EXISTS bs x stack s sb ev f2.
               zBC_HEAP bs (x,cs,stack,s,output) (cb,sb,ev,f2) *
               zPC (cb + n2w (2 * bs.pc)) * ~zS)))`;

val EVENTUALLY_EVENTUALLY = prove(
  ``EVENTUALLY (EVENTUALLY p) = EVENTUALLY p``,
  SIMP_TAC std_ss [FUN_EQ_THM,EVENTUALLY_def]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  THEN1 (Q.EXISTS_TAC `k' + k` \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC])
  \\ Q.LIST_EXISTS_TAC [`k`,`0`] \\ FULL_SIMP_TAC std_ss [AC ADD_COMM ADD_ASSOC]);

val TEMPORAL_WEAKEN_LEMMA = prove(
  ``TEMPORAL X64_MODEL code
      (T_IMPLIES p (T_DISJ (N_NEXT n (EVENTUALLY (NOW q1))) q2)) /\
    (!r1 r2 t2. SEP_REFINE (q1 * r1 * r2) X64_ICACHE x64_2set t2 ==>
                SEP_REFINE (q3 * r1 * r2) X64_ICACHE x64_2set t2) ==>
    TEMPORAL X64_MODEL code
      (T_IMPLIES p (T_DISJ (N_NEXT n (EVENTUALLY (NOW q3))) q2))``,
  REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [X64_MODEL_def]
  \\ FULL_SIMP_TAC std_ss [TEMPORAL_def,LET_DEF,PULL_FORALL,T_DISJ_def,
       AND_IMP_INTRO,T_IMPLIES_def,ALWAYS_def,EVENTUALLY_def,SEP_IMP_def,
       N_NEXT_THM,NOW_def,SPEC_N_def,T_OR_F_def]
  \\ REPEAT STRIP_TAC \\ RES_TAC \\ METIS_TAC [])
  |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]

val SPEC_N_WEAKEN = prove(
  ``(!r1 r2 t2.
      SEP_REFINE (q1 * r1 * r2) X64_ICACHE x64_2set t2 ==>
      SEP_REFINE (q3 * r1 * r2) X64_ICACHE x64_2set t2) /\
    SPEC_N n X64_MODEL p code q1 q2 ==>
    SPEC_N n X64_MODEL p code q3 q2``,
  REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [X64_MODEL_def]
  \\ FULL_SIMP_TAC std_ss [TEMPORAL_def,LET_DEF,PULL_FORALL,T_DISJ_def,
       AND_IMP_INTRO,T_IMPLIES_def,ALWAYS_def,EVENTUALLY_def,SEP_IMP_def,
       N_NEXT_THM,NOW_def,SPEC_N_def,T_OR_F_def]
  \\ REPEAT STRIP_TAC \\ RES_TAC \\ METIS_TAC []);

val FORALL_TEMPORAL_N_NEXT_IMP_ALWAYS = prove(
  ``(!n. TEMPORAL model code (T_IMPLIES p (T_DISJ (N_NEXT n q) r))) ==>
    TEMPORAL model code (T_IMPLIES p (T_DISJ (ALWAYS q) r))``,
  REPEAT STRIP_TAC
  \\ `?x1 x2 x3 x4 x5. model = (x1,x2,x3,x4,x5)` by METIS_TAC [PAIR]
  \\ FULL_SIMP_TAC std_ss [TEMPORAL_def,LET_DEF,PULL_FORALL,T_DISJ_def,
       AND_IMP_INTRO,T_IMPLIES_def,ALWAYS_def,EVENTUALLY_def]
  \\ REPEAT STRIP_TAC \\ RES_TAC
  \\ Cases_on `r (\p state. SEP_REFINE (p * CODE_POOL x3 code * r')
                    x4 x1 state \/ x5 state) seq'` \\ FULL_SIMP_TAC std_ss []
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [N_NEXT_THM]);

val bc_diverges_def = Define `
  bc_diverges s = !n. ?s2. NRC bc_next n s s2`;

val zBC_HEAP_DIVERGES = let
  val lemma =
    SPEC_N_WEAKEN
    |> Q.INST [`q1`|->`zBC_HEAP bs (x,cs,stack,s,output) (cb,sb,ev,f2) *
                       zPC (cb + n2w (2 * bs.pc)) * ~zS`]
    |> Q.INST [`q3`|->`SEP_EXISTS bs x stack s sb ev f2.
                         zBC_HEAP bs (x,cs,stack,s,output) (cb,sb,ev,f2) *
                         zPC (cb + n2w (2 * bs.pc)) * ~zS`]
    |> RW [GSYM AND_IMP_INTRO]
  val lemma2 = prove(lemma |> concl |> dest_imp |> fst,
    fs [SEP_REFINE_def,SEP_CLAUSES,SEP_EXISTS_THM] \\ METIS_TAC []);
  val lemma3 = MP lemma lemma2
  val lemma4 = prove(
    ``(!n s2. NRC bc_next n s1 s2 ==> P n s1) ==>
      ((!n. ?s2. NRC bc_next n s1 s2) ==> !n. P n s1)``,
    METIS_TAC []);
  in
  zBC_HEAP_N
  |> SPEC_ALL
  |> UNDISCH_ALL
  |> MATCH_MP lemma3
  |> DISCH ``NRC bc_next n s1 s2``
  |> Q.GENL [`s2`,`n`]
  |> HO_MATCH_MP lemma4
  |> RW [GSYM bc_diverges_def]
  |> UNDISCH_ALL
  |> RW [SPEC_N_def,T_OR_F_thm]
  |> MATCH_MP FORALL_TEMPORAL_N_NEXT_IMP_ALWAYS
  |> RW [GSYM zBYTECODE_DIVERGED_def]
  end

val zBC_HEAP_DIVERGES_ALT = let
  val lemma =
    SPEC_N_WEAKEN
    |> Q.INST [`q1`|->`zBC_HEAP bs (x,cs,stack,s,output) (cb,sb,ev,f2) *
                       zPC (cb + n2w (2 * bs.pc)) * ~zS`]
    |> Q.INST [`q3`|->`SEP_EXISTS bs x stack s sb ev f2.
                         zBC_HEAP bs (x,cs,stack,s,output) (cb,sb,ev,f2) *
                         zPC (cb + n2w (2 * bs.pc)) * ~zS`]
    |> RW [GSYM AND_IMP_INTRO]
  val lemma2 = prove(lemma |> concl |> dest_imp |> fst,
    fs [SEP_REFINE_def,SEP_CLAUSES,SEP_EXISTS_THM] \\ METIS_TAC []);
  val lemma3 = MP lemma lemma2
  val lemma4 = prove(
    ``(!n s2. NRC bc_next n s1 s2 ==> P n s1) ==>
      ((!n. ?s2. NRC bc_next n s1 s2) ==> !n. P n s1)``,
    METIS_TAC []);
  in
  zBC_HEAP_N_ALT
  |> SPEC_ALL |> DISCH_ALL |> RW [GSYM AND_IMP_INTRO]
  |> UNDISCH_ALL
  |> MATCH_MP lemma3
  |> DISCH ``NRC bc_next n s1 s2``
  |> Q.GENL [`s2`,`n`]
  |> HO_MATCH_MP lemma4
  |> RW [GSYM bc_diverges_def]
  |> UNDISCH_ALL
  |> RW [SPEC_N_def,T_OR_F_thm]
  |> MATCH_MP FORALL_TEMPORAL_N_NEXT_IMP_ALWAYS
  |> RW [GSYM zBYTECODE_DIVERGED_def]
  end

val TEMPORAL_PRE_EXISTS = prove(
  ``TEMPORAL X64_MODEL c (T_IMPLIES (NOW (SEP_EXISTS x. p x)) q) <=>
    !x. TEMPORAL X64_MODEL c (T_IMPLIES (NOW (p x)) q)``,
  fs [TEMPORAL_def,LET_DEF,T_IMPLIES_def,NOW_def,SEP_CLAUSES,
         SEP_REFINE_def,X64_MODEL_def,SEP_EXISTS_THM,PULL_EXISTS,AND_IMP_INTRO]
  \\ METIS_TAC []);

val TEMPORAL_MOVE_COND = prove(
  ``(b ==> TEMPORAL X64_MODEL c (T_IMPLIES (NOW p)
        ((T_DISJ (zBYTECODE_DIVERGED out (cs,cb))
           (EVENTUALLY (NOW (zHEAP_ERROR cs))))))) <=>
    TEMPORAL X64_MODEL c (T_IMPLIES (NOW (p * cond b))
        ((T_DISJ (zBYTECODE_DIVERGED out (cs,cb))
           (EVENTUALLY (NOW (zHEAP_ERROR cs))))))``,
  Cases_on `b`
  \\ fs [TEMPORAL_def,LET_DEF,T_IMPLIES_def,NOW_def,SEP_CLAUSES,
         SEP_REFINE_def,X64_MODEL_def,SEP_EXISTS_THM,PULL_EXISTS,AND_IMP_INTRO]
  \\ fs [SEP_F_def]
  \\ fs [T_DISJ_def,EVENTUALLY_def,zBYTECODE_DIVERGED_def,ALWAYS_def,NOW_def]
  \\ METIS_TAC []);

val zHEAP_WILL_DIVERGE_def = Define `
  zHEAP_WILL_DIVERGE out cs cb =
    (SEP_EXISTS f2 s x s1.
     zBC_HEAP s1 (x,cs,[],s,out) (cb,cs.stack_trunk - 0x8w,F,f2) *
     zPC (cb + n2w (2 * s1.pc)) * ~zS *
     cond
       ((s.code_mode = SOME T) /\
        (s.code = x64_code 0 s1.code) /\
        (s1.inst_length = x64_inst_length) /\ bc_diverges s1 /\
        EVEN (w2n cb) /\ (!r. r IN FDOM f2 ==> EVEN r) /\
        (s1.stack = [])))`

val zBC_HEAP_BC_DIV =
  zBC_HEAP_DIVERGES_ALT
  |> DISCH ``(s1:bc_state).stack = []``
  |> DISCH_ALL |> Q.INST [`stack`|->`[]`,`ev`|->`F`]
  |> GEN_ALL
  |> SIMP_RULE std_ss [LENGTH,AND_IMP_INTRO,GSYM CONJ_ASSOC]
  |> SPEC_ALL
  |> SIMP_RULE std_ss [LET_DEF,MAP,HD,TL,APPEND,
        SEP_CLAUSES,LENGTH,TEMPORAL_MOVE_COND]
  |> Q.GENL [`s1`,`x`,`s`,`f2`]
  |> SIMP_RULE std_ss [GSYM TEMPORAL_PRE_EXISTS,GSYM zHEAP_WILL_DIVERGE_def]

val full_s_def = Define `
  full_s init = first_s init with
    <|handler := 1;
      local := (first_s init).local with printing_on := 0x1w|>`;

val init_bc_state_def = Define `
  init_bc_state s =
    s with <| globals := [];
              stack := [];
              handler := 0;
              refs := FEMPTY;
              output := "" |>`

val ref_adjust_FEMPTY = prove(
  ``ref_adjust (p,x,ev) FEMPTY = FEMPTY``,
  SIMP_TAC (srw_ss()) [ref_adjust_def,LET_DEF]);

val zHEAP_SET_STOP_TO_TERMINATE = let
  val (_,_,code1,_) = zHEAP_TERMINATE |> Q.INST [`p`|->`p+6w`]
    |> SIMP_RULE (srw_ss()) [] |> concl |> dest_spec
  val (_,_,code2,_) = zHEAP_SET_STOP_ADDR
    |> SIMP_RULE (srw_ss()) [] |> concl |> dest_spec
in
  zHEAP_SET_STOP_ADDR
  |> MATCH_MP SPEC_SUBSET_CODE
  |> SPEC ``^code1 UNION ^code2``
  |> SIMP_RULE (srw_ss()) [INSERT_SUBSET,INSERT_UNION_EQ]
  |> Q.INST [`imm32`|->`15w`]
  |> SIMP_RULE (srw_ss()) [IMM32_def]
  |> SORT_CODE
end

val full_s_with_stop_def = Define `
  full_s_with_stop init stop_addr =
    full_s init with
         local := (full_s init).local with stop_addr := stop_addr`;

val set_ref_addr = let
  val th1 =
    SPEC_COMPOSE_RULE [zHEAP_Num1_globals_count,zHEAP_Num2_0,
      zHEAP_NEW_REF,zHEAP_MOVE_13]
     |> Q.INST [`l`|->`globals_count`,`ptr`|->`0`]
     |> SIMP_RULE std_ss []
  val th2 =
    SPEC_COMPOSE_RULE [zHEAP_Num1_globals_count,zHEAP_Num2_0,
      zHEAP_NEW_REF,zHEAP_MOVE_12]
     |> Q.INST [`l`|->`globals_count`,`ptr`|->`1`]
     |> SIMP_RULE std_ss []
  val th =
    SPEC_COMPOSE_RULE [th1,th2,zHEAP_MOVE_31,BlockConsPair12,
      zHEAP_Num3_0,zHEAP_MOVE_32,zHEAP_SWAP_14]
    |> RW [GSYM ref_addr_def |> Q.SPEC `T` |> RW []]
  in th end

val ref_globals_list_NIL = prove(
  ``!n. ref_globals_list [] n = REPLICATE n (Number 0)``,
  Induct \\ fs [ref_globals_list_def,rich_listTheory.REPLICATE]);

val zBC_HEAP_INIT = let
  val th0 = SPEC_COMPOSE_RULE [zHEAP_INIT,zHEAP_ABBREVS,zHEAP_PUSH1,
              zHEAP_SET_PRINTING_ON,zWRITE_HANDLER,zHEAP_POP1,
              zHEAP_SET_STOP_TO_TERMINATE,set_ref_addr]
            |> SIMP_RULE std_ss [LENGTH,HD,TL,NOT_CONS_NIL,
                 SEP_CLAUSES,GSYM full_s_def,
                 GSYM full_s_with_stop_def]
  val tm = find_term (can (match_term ``full_s_with_stop xx yy``)) (concl th0)
  val pc = get_pc th0
  val (th,goal) = SPEC_WEAKEN_RULE th0
    ``(zBC_HEAP (init_bc_state i) (RefPtr 1,full_cs init p,[],^tm,"")
              (cb,cs.stack_trunk - 0x8w,T,FEMPTY |+
                (1,ValueArray (REPLICATE globals_count (Number 0)))) * ^pc * ~zS) \/
      zHEAP_ERROR (full_cs init p)``
(*
  gg goal
*)
  val lemma = prove(goal,
    fs [zBC_HEAP_def,SEP_CLAUSES,init_bc_state_def,LET_DEF,HD,TL,ref_adjust_FEMPTY]
    \\ fs [SEP_IMP_def,SEP_EXISTS_THM] \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`Number 0`,`Number 0`] \\ fs []
    \\ `^tm with <|output := ""; handler := 1|> = ^tm` by ALL_TAC
    THEN1 EVAL_TAC \\ fs [AC STAR_ASSOC STAR_COMM]
    \\ fs [ref_globals_def,OPT_MAP_def,ref_globals_list_NIL]
    \\ POP_ASSUM (K ALL_TAC)
    \\ POP_ASSUM MP_TAC
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(x1=x2)==>(x1==>x2)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
    \\ fs [GSYM fmap_EQ_THM]
    \\ REPEAT STRIP_TAC \\ fs [FUNION_DEF,FAPPLY_FUPDATE_THM]
    \\ fs [EXTENSION] \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC \\ fs []);
  val th = MP th lemma
  val th = th |> SIMP_RULE std_ss [SPEC_MOVE_COND]
  val goal = th |> concl |> dest_imp |> fst
  val th = MP th (RW [] (EVAL goal))
  in th end

val standalone_bc_init_state_def = Define `
  standalone_bc_init_state init_pc bc_code =
    init_bc_state (ARB with <| pc := init_pc;
                               code := bc_code;
                               inst_length := x64_inst_length |>)`;

val standalone_bc_init_state_lemma = prove(
  ``((standalone_bc_init_state init_pc bc_code).inst_length = x64_inst_length) /\
    ((standalone_bc_init_state init_pc bc_code).code = bc_code) /\
    ((standalone_bc_init_state init_pc bc_code).pc = init_pc)``,
  EVAL_TAC);

val jump = let
  val ((th,_,_),_) = prog_x64Lib.x64_spec "48E9"
  val th = th |> RW [GSYM IMM32_def] |> Q.INST [`rip`|->`p`]
  in th end

val SEP_REFINE_DISJ = prove(
  ``SEP_REFINE (p \/ q) m1 m2 s <=>
    SEP_REFINE q m1 m2 s \/ SEP_REFINE p m1 m2 s``,
  fs [SEP_REFINE_def,SEP_DISJ_def] \\ METIS_TAC []);

local val fs = fsrw_tac[] in
val TEMPORAL_LEMMA = prove(
  ``TEMPORAL m (c1 UNION c2) (T_IMPLIES (NOW p) (T_DISJ q (EVENTUALLY (NOW err)))) ==>
    SPEC m i (c1 UNION c2) (p \/ err) ==>
    TEMPORAL m (c1 UNION c2) (T_IMPLIES (NOW i) (T_DISJ (EVENTUALLY q)
                                            (EVENTUALLY (NOW err))))``,
  fs [SPEC_EQ_TEMPORAL]
  \\ Q.SPEC_TAC (`c1 UNION c2`,`c`)
  \\ REPEAT STRIP_TAC
  \\ PairCases_on `m`
  \\ fs [TEMPORAL_def,LET_DEF]
  \\ fs [T_IMPLIES_def,T_DISJ_def,EVENTUALLY_def,NOW_def]
  \\ fs [N_NEXT_thm,EVENTUALLY_def,NOW_def]
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 METIS_TAC []
  \\ Q.MATCH_ASSUM_RENAME_TAC `rel_sequence m1 s state`
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`s`,`r`]) \\ fs []
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 METIS_TAC []
  \\ fs [SEP_CLAUSES,SEP_REFINE_DISJ] THEN1 METIS_TAC []
  \\ IMP_RES_TAC rel_sequence_shift
  \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `k`)
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`(s (k:num))`,`\j. s (k + j:num)`,`r`])
  \\ fs [] \\ REPEAT STRIP_TAC
  THEN1 (DISJ1_TAC \\ Q.EXISTS_TAC `k` \\ fs [AC ADD_ASSOC ADD_COMM])
  \\ METIS_TAC []);
end

val TEMPORAL_THM = prove(
  ``TEMPORAL m c2 (T_IMPLIES (NOW p) (T_DISJ q (EVENTUALLY (NOW err)))) ==>
    SPEC m i c1 (p \/ err) ==>
    TEMPORAL m (c1 UNION c2) (T_IMPLIES (NOW i)
      (T_DISJ (EVENTUALLY q) (EVENTUALLY (NOW err))))``,
  METIS_TAC [TEMPORAL_LEMMA,TEMPORAL_EXTEND_CODE,SPEC_ADD_CODE,UNION_COMM]);

val EVENTUALLY_zBYTECODE_DIVERGED = prove(
  ``EVENTUALLY (zBYTECODE_DIVERGED y (x,z)) =
    zBYTECODE_DIVERGED y (x,z)``,
  fs [EVENTUALLY_def,FUN_EQ_THM,zBYTECODE_DIVERGED_def,ALWAYS_def,EVENTUALLY_def]
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC THEN1
   (POP_ASSUM (MP_TAC o Q.SPEC `k'`) \\ fs []
    \\ REPEAT STRIP_TAC \\ Q.EXISTS_TAC `k + k''`
    \\ fs [AC ADD_COMM ADD_ASSOC])
  \\ Q.EXISTS_TAC `0` \\ fs []);

val zSTANDALONE_DIVERGES = curry save_thm "zSTANDALONE_DIVERGES" let
  val th = zBC_HEAP_INIT
  val cb = get_pc th |> rand
  val cb = ``^cb + 6w``
  val f2 = find_term (can (match_term ``FEMPTY |+ (1:num,xxx:'a)``)) (concl th)
  val lemma = prove(
    ``EVEN (w2n ^cb) = EVEN (w2n (p:word64))``,
    SIMP_TAC std_ss [EVEN_w2n] \\ blastLib.BBLAST_TAC)
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
  val s = th |> concl |> find_term (can (match_term ``full_s_with_stop ss ppp``))
  val th = zBC_HEAP_DIVERGES
    |> Q.INST [`ev`|->`T`,`stack`|->`[]`,`out`|->`""`,`x`|->`RefPtr 1`,
               `cs`|->`full_cs init p`,`s`|->`^s`]
    |> DISCH_ALL |> Q.GEN `sb` |> SIMP_RULE std_ss [LENGTH]
    |> Q.GEN `cb` |> SPEC cb
    |> Q.GEN `f2` |> SPEC f2
    |> CONV_RULE (RATOR_CONV (SIMP_CONV std_ss
            [FDOM_FUPDATE,FDOM_FEMPTY,IN_INSERT,NOT_IN_EMPTY]))
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> Q.INST [`s1`|->`standalone_bc_init_state init_pc bc_code`]
    |> RW [standalone_bc_init_state_lemma,lemma]
    |> SIMP_RULE std_ss [AC STAR_COMM STAR_ASSOC]
  val th1 = SPEC_COMPOSE_RULE [zBC_HEAP_INIT,jump]
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> SIMP_RULE std_ss [AC STAR_COMM STAR_ASSOC]
    |> Q.INST [`cs`|->`full_cs init p`,`cb`|->`^cb`]
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> Q.INST [`i`|->`<| pc := init_pc; code := bc_code;
                         inst_length := x64_inst_length |>`]
    |> RW [GSYM standalone_bc_init_state_def]
    |> DISCH ``SIGN_EXTEND 32 64 (w2n (imm32:word32)) = 2 * init_pc``
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
  val thA = MATCH_MP TEMPORAL_THM (th |> UNDISCH_ALL)
  in MATCH_MP thA (UNDISCH_ALL th1)
     |> RW [EVENTUALLY_zBYTECODE_DIVERGED]
     |> UNDISCH_ALL
     |> DISCH ``bc_diverges (standalone_bc_init_state init_pc bc_code)`` end;

val NEXT_N_thm = prove(
  ``!k p f s. N_NEXT k p f s = p f (\n. s (n + k))``,
  Induct \\ fsrw_tac[] [N_NEXT_def]
  \\ CONV_TAC (DEPTH_CONV ETA_CONV) \\ fsrw_tac[] [NEXT_def,ADD1,ADD_ASSOC]);

val SPEC_N_IMP_SPEC = store_thm("SPEC_N_IMP_SPEC",
  ``SPEC_N n model pre code post err ==>
    SPEC model pre code (post \/ err)``,
  `?to_set next instr less allow. model = (to_set,next,instr,less,allow)`
           by METIS_TAC [PAIR]
  \\ FULL_SIMP_TAC std_ss [SPEC_N_def,SPEC_EQ_TEMPORAL,TEMPORAL_def,LET_DEF]
  \\ REPEAT STRIP_TAC \\ RES_TAC
  \\ FULL_SIMP_TAC std_ss [T_IMPLIES_def] \\ REPEAT STRIP_TAC \\ RES_TAC
  \\ FULL_SIMP_TAC std_ss [T_OR_F_def]
  \\ FULL_SIMP_TAC std_ss [NEXT_def,EVENTUALLY_def,N_NEXT_thm]
  THEN1 (Q.EXISTS_TAC `k+n` \\ FULL_SIMP_TAC std_ss [ADD_ASSOC]
    \\ POP_ASSUM MP_TAC
    \\ SIMP_TAC std_ss [NOW_def,SEP_REFINE_def,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [SEP_DISJ_def] \\ METIS_TAC [])
  THEN1 (Q.EXISTS_TAC `k` \\ FULL_SIMP_TAC std_ss [ADD_ASSOC]
    \\ POP_ASSUM MP_TAC
    \\ SIMP_TAC std_ss [NOW_def,SEP_REFINE_def,SEP_CLAUSES]
    \\ SIMP_TAC std_ss [SEP_DISJ_def] \\ METIS_TAC []));

val bc_terminates_def = Define `
  bc_terminates s1 s2 =
    ?n b. NRC bc_next n s1 s2 /\ (bc_fetch s2 = SOME (Stop b))`;

val SPEC_EXTEND_CODE = prove(
  ``SPEC X64_MODEL p ((a + n2w n,xs) INSERT code) q ==>
    !zs.
      (?ys1 ys2. (zs = (ys1 ++ xs ++ ys2)) /\ (n = LENGTH ys1)) ==>
      SPEC X64_MODEL p ((a,zs) INSERT code) q``,
  SRW_TAC [] []
  \\ MATCH_MP_TAC (MP_CANON SPEC_X64_MERGE_CODE |> GEN_ALL) \\ fs []
  \\ MATCH_MP_TAC (MP_CANON SPEC_X64_MERGE_CODE |> GEN_ALL) \\ fs []
  \\ IMP_RES_TAC (MP_CANON SPEC_SUBSET_CODE)
  \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SUBSET_DEF]);

val SPEC_ADD_DISJ_BOTH = prove(
  ``SPEC m p c q ==> !r. SPEC m (p \/ r) c (q \/ r)``,
  fs [SPEC_PRE_DISJ,SPEC_ADD_DISJ] \\ REPEAT STRIP_TAC
  \\ `SEP_IMP r (q \/ r)` by fs [SEP_IMP_def,SEP_DISJ_def]
  \\ METIS_TAC [SPEC_REFL,SPEC_WEAKEN]);

val NRC_bc_next_code = prove(
  ``!n s1 s2. NRC bc_next n s1 s2 ==> (s1.code = s2.code) /\
                                      (s1.inst_length = s2.inst_length)``,
  Induct \\ fs [NRC,PULL_EXISTS] \\ REPEAT STRIP_TAC \\ RES_TAC
  \\ IMP_RES_TAC bytecodeExtraTheory.bc_next_preserves_code
  \\ IMP_RES_TAC bytecodeExtraTheory.bc_next_preserves_inst_length
  \\ METIS_TAC []);

val NRC_bc_next_standalone_bc_init_state = prove(
  ``NRC bc_next n (standalone_bc_init_state init_pc bc_code) s2 ==>
    (s2.code = bc_code) /\
    (s2.inst_length = x64_inst_length)``,
  REPEAT STRIP_TAC \\ IMP_RES_TAC NRC_bc_next_code
  \\ fs [standalone_bc_init_state_def,init_bc_state_def]);

val NRC_lemma = prove(
  ``((((?b. bc_fetch s2 = SOME (Stop b)) /\
     ?n. NRC bc_next n (standalone_bc_init_state init_pc bc_code) s2) /\
     (s2.code = bc_code)) /\
     (s2.inst_length = x64_inst_length) ==> t) ==>
    (bc_terminates (standalone_bc_init_state init_pc bc_code) s2 ==> t)``,
  Cases_on `t` \\ fs []
  \\ REPEAT STRIP_TAC
  \\ fs [bc_terminates_def] \\ fs []
  \\ IMP_RES_TAC NRC_bc_next_standalone_bc_init_state
  \\ METIS_TAC []);

val zSTANDALONE_TERMINATES = curry save_thm "zSTANDALONE_TERMINATES" let
  val th1 = zBC_HEAP_N
    |> Q.SPECL [`n`,`standalone_bc_init_state init_pc bc_code`,`s2`]
    |> UNDISCH_ALL
    |> MATCH_MP SPEC_N_IMP_SPEC |> DISCH_ALL
    |> RW [standalone_bc_init_state_lemma]
    |> Q.INST [`stack`|->`[]`]
    |> RW [LENGTH,ADD1] |> SIMP_RULE std_ss []
    |> UNDISCH_ALL
  val th2 =
    zBC_HEAP_Stop
    |> Q.INST [`s1`|->`s2`,`s2`|->`s3`,`stack`|->`[]`]
    |> UNDISCH_ALL
  val th3 =
    MATCH_MP SPEC_EXTEND_CODE th2 |> Q.SPEC `x64_code 0 bc_code`
    |> DISCH_ALL |> SIMP_RULE std_ss []
    |> SIMP_RULE std_ss [AND_IMP_INTRO]
  val goal = concl th3 |> dest_imp |> fst
  val goal =
    ``(bc_fetch s2 = SOME (Stop b)) /\ (s2.code = bc_code) /\
      (s2.inst_length = x64_inst_length) ==> ^goal``
  val lemma = prove(goal,
    fs [bc_fetch_def] \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC x64_code_EQ_x64 \\ fs [])
  val th4 = MP th3 (lemma |> UNDISCH)
  val set_lemma = prove(
    ``x INSERT (s UNION (x INSERT s)) = x INSERT s``,
    fs [EXTENSION] \\ METIS_TAC [])
  val th5 = SPEC_COMPOSE_RULE [th1,th4] |> RW [set_lemma]
  val th = zBC_HEAP_INIT
  val tm1 = find_term (can (match_term ``zBC_HEAP x1 x2 x3``)) (concl th)
  val tm2 = find_term (can (match_term ``zBC_HEAP x1 x2 x3``)) (concl th5)
  val x1 = tm1 |> rator |> rand
  val x2 = tm2 |> rator |> rand
  val y1 = tm1 |> rand
  val y2 = tm2 |> rand
  val th6 = th5 |> INST (fst (match_term x2 x1)) |> INST (fst (match_term y2 y1))
  val cb = get_pc th |> rand
  val cb = ``^cb + 6w``
  val f2 = find_term (can (match_term ``FEMPTY |+ (1:num,xxx:'a)``)) (concl th)
  val lemma = prove(
    ``EVEN (w2n ^cb) = EVEN (w2n (p:word64))``,
    SIMP_TAC std_ss [EVEN_w2n] \\ blastLib.BBLAST_TAC)
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
  val s = th |> concl |> find_term (can (match_term ``full_s_with_stop ss ppp``))
  val th = th6
    |> Q.INST [`ev`|->`T`,`stack`|->`[]`,`out`|->`""`,`x`|->`RefPtr 1`,
               `cs`|->`full_cs init p`,`s`|->`^s`,`cb:word64`|->`^cb`]
    |> DISCH_ALL |> RW [AND_IMP_INTRO]
    |> CONV_RULE (RATOR_CONV (SIMP_CONV (srw_ss())
            [FDOM_FUPDATE,FDOM_FEMPTY,IN_INSERT,NOT_IN_EMPTY]))
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> RW [standalone_bc_init_state_lemma,lemma]
    |> SIMP_RULE std_ss [AC STAR_COMM STAR_ASSOC]
    |> UNDISCH_ALL
  val th1 = SPEC_COMPOSE_RULE [zBC_HEAP_INIT,jump]
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> SIMP_RULE std_ss [AC STAR_COMM STAR_ASSOC]
    |> Q.INST [`cs`|->`full_cs init p`,`cb`|->`^cb`]
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
    |> Q.INST [`i`|->`<| pc := init_pc; code := bc_code;
                         inst_length := x64_inst_length |>`]
    |> RW [GSYM standalone_bc_init_state_def]
    |> DISCH ``SIGN_EXTEND 32 64 (w2n (imm32:word32)) = 2 * init_pc``
    |> SIMP_RULE std_ss [word_arith_lemma1,ADD_ASSOC]
  val thA = SPEC_COMPOSE_RULE [UNDISCH_ALL th1,th]
     |> RW [EVAL ``(full_s_with_stop init w).local.stop_addr``]
  val thB =
    thA |> SIMP_RULE std_ss [zBC_HEAP_def,LET_DEF,MAP,HD,TL,MAP_APPEND]
        |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
        |> SIMP_RULE std_ss [SEP_CLAUSES]
  val tm1 = thB |> concl |> rand
  val tm2 = zHEAP_TERMINATE |> concl
  val p1 = find_term (can (match_term ``zHEAP pat``)) tm1
  val p2 = find_term (can (match_term ``zHEAP pat``)) tm2
  val (i,_) = match_term p2 p1
  val p = get_pc thB |> rand
  val th1 = INST i (zHEAP_TERMINATE |> Q.INST [`p`|->`^p`])
    |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
    |> RW [EVAL ``(full_s_with_stop init w).local.printing_on``,
           EVAL ``1w = 0w:word64``]
    |> SIMP_RULE std_ss [word_arith_lemma1]
    |> Q.GENL [`x3`,`x2`]
    |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val th2 =
    MATCH_MP SPEC_ADD_DISJ_BOTH th1
    |> Q.SPEC `zHEAP_ERROR (full_cs init p)`
    |> SIMP_RULE std_ss [SEP_CLAUSES]
  val f = SIMP_RULE (srw_ss()++star_ss) []
          o RW [EVAL ``(full_s_with_stop init w).local.printing_on``,
             EVAL ``1w = 0w:word64``]
  val comp = ISPEC ``X64_MODEL`` SPEC_COMPOSE
  val th = MATCH_MP comp (CONJ (thB |> f) (th2 |> f))
  val th = th
    |> DISCH ``(s2:bc_state).inst_length = x64_inst_length``
    |> DISCH ``(s2:bc_state).code = bc_code``
    |> DISCH ``NRC bc_next n (standalone_bc_init_state init_pc bc_code) s2``
    |> DISCH ``bc_fetch s2 = SOME (Stop b)``
    |> Q.GENL [`n`,`b`] |> SIMP_RULE std_ss [GSYM PULL_EXISTS,AND_IMP_INTRO]
    |> MATCH_MP NRC_lemma
  in th end;

val bc_executes_ok_def = Define `
  bc_executes_ok s <=>
    bc_diverges s \/ ?s1. bc_terminates s s1`;

val T_DISJ_EVENTUALLY = prove(
  ``T_DISJ (EVENTUALLY p) (EVENTUALLY q) =
    EVENTUALLY (T_DISJ p q)``,
  fs [T_DISJ_def,EVENTUALLY_def,FUN_EQ_THM] \\ METIS_TAC []);

val SPEC_IMP_TEMPORAL = prove(
  ``SPEC m p c (q \/ q1) ==>
    TEMPORAL m c (T_IMPLIES (NOW p) (T_DISJ (EVENTUALLY (NOW q))
      (EVENTUALLY (NOW q1))))``,
  fs [T_DISJ_EVENTUALLY,SPEC_EQ_TEMPORAL]
  \\ PairCases_on `m`
  \\ fs [TEMPORAL_def,LET_DEF,T_IMPLIES_def,EVENTUALLY_def,
         NOW_def,SEP_REFINE_def,T_DISJ_def,SEP_CLAUSES]
  \\ fs [SEP_DISJ_def] \\ METIS_TAC []);

val T_DISJ_COMM = prove(
  ``T_DISJ p q = T_DISJ q p``,
  fs [FUN_EQ_THM,T_DISJ_def, AC DISJ_COMM DISJ_ASSOC]);

val combine_lemma = prove(
  ``(!s2.
       bc_terminates (standalone_bc_init_state init_pc bc_code) s2 ==>
       TEMPORAL m c1
         (T_IMPLIES (NOW (INIT_STATE init * (~zS * zPC p)))
           (EVENTUALLY
              (NOW
                 (zHEAP_OUTPUT (full_cs init p,s2.output) \/
                  zHEAP_ERROR (full_cs init p)))))) /\
    (bc_diverges (standalone_bc_init_state init_pc bc_code) ==>
     TEMPORAL m c2
       (T_IMPLIES (NOW (INIT_STATE init * (~zS * zPC p)))
        (T_DISJ (zBYTECODE_DIVERGED "" (full_cs init p,w))
           (EVENTUALLY (NOW (zHEAP_ERROR (full_cs init p))))))) ==>
    (bc_executes_ok (standalone_bc_init_state init_pc bc_code) ==>
     TEMPORAL m (c1 UNION c2)
       (T_IMPLIES (NOW (INIT_STATE init * (~zS * zPC p)))
         (T_DISJ (EVENTUALLY (NOW (zHEAP_ERROR (full_cs init p))))
                 (if bc_diverges (standalone_bc_init_state init_pc bc_code) then
                    (zBYTECODE_DIVERGED "" (full_cs init p,w))
                  else (EVENTUALLY (NOW (SEP_EXISTS s2.
                    zHEAP_OUTPUT (full_cs init p,s2.output) *
                    cond (bc_terminates
               (standalone_bc_init_state init_pc bc_code) s2))))))))``,
  Cases_on `bc_diverges (standalone_bc_init_state init_pc bc_code)` \\ fs []
  \\ REPEAT STRIP_TAC THEN1
   (ONCE_REWRITE_TAC [T_DISJ_COMM]
    \\ ONCE_REWRITE_TAC [UNION_COMM]
    \\ MATCH_MP_TAC (MP_CANON TEMPORAL_EXTEND_CODE) \\ fs [])
  \\ REPEAT STRIP_TAC
  \\ fs [bc_executes_ok_def] \\ fs []
  \\ RES_TAC \\ fs [GSYM SPEC_EQ_TEMPORAL]
  \\ MATCH_MP_TAC SPEC_IMP_TEMPORAL
  \\ MATCH_MP_TAC (MP_CANON SPEC_ADD_CODE)
  \\ IMP_RES_TAC SPEC_WEAKEN \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SEP_IMP_def,SEP_CLAUSES,SEP_EXISTS_THM]
  \\ REPEAT STRIP_TAC
  \\ Q.EXISTS_TAC `s1` \\ fs [SEP_CLAUSES]
  \\ fs [SEP_DISJ_def]);

val init_pc_bound = prove(
  ``init_pc < 2**30 ==>
    (SIGN_EXTEND 32 64 ((w2n:word32->num) (n2w (2 * init_pc))) = 2 * init_pc)``,
  fs [n2w_w2n] \\ REPEAT STRIP_TAC
  \\ `(2 * init_pc) < 2147483648` by DECIDE_TAC
  \\ `(2 * init_pc) < 4294967296` by DECIDE_TAC
  \\ fs [bitTheory.SIGN_EXTEND_def,bitTheory.BIT_def,bitTheory.BITS_THM,LET_DEF]
  \\ IMP_RES_TAC LESS_DIV_EQ_ZERO \\ fs [])

fun standalone_expand_code th = let
  val tm = th |> concl |> rator |> rand
  val lemma =
    (SIMP_CONV (srw_ss()) [fetch "-" "full_cs_def",
       code_abbrevs_def,full_code_abbrevs_def]
     THENC REWRITE_CONV [all_code_abbrevs,word_arith_lemma1,
             INSERT_UNION_EQ,UNION_EMPTY]
     THENC SIMP_CONV std_ss []) tm
  val th = th |> RW1 [lemma]
  in th end

val zSTANDALONE_CORRECT = curry save_thm "zSTANDALONE_CORRECT" let
  val th1 =
    zSTANDALONE_TERMINATES
    |> RW [SPEC_EQ_TEMPORAL]
    |> Q.GEN `s2`
  val th2 = zSTANDALONE_DIVERGES
  val th = MATCH_MP combine_lemma (CONJ th1 th2)
  val th = th
    |> DISCH ``SIGN_EXTEND 32 64 (w2n (imm32:word32)) = 2 * init_pc``
    |> Q.INST [`imm32`|->`n2w (2 * init_pc)`]
    |> (fn th => MATCH_MP th (UNDISCH init_pc_bound))
    |> UNDISCH_ALL
    |> standalone_expand_code
    |> DISCH_ALL
  in th end;

(*

  val (_,_,_,m1) = dest_spec (thB |> f |> concl)
  val (_,m2,_,_) = dest_spec (th2 |> f |> concl)

  fun term_diff tm1 tm2 =
    if is_comb tm1 andalso is_comb tm2 then let
      val (x1,y1) = dest_comb tm1
      val (x2,y2) = dest_comb tm2
      in if aconv x1 x2 then term_diff y1 y2 else
         if aconv y1 y2 then term_diff x1 x2 else
           (tm1,tm2)
      end else
    if is_abs tm1 andalso is_abs tm2 then let
      val (x1,y1) = dest_abs tm1
      val (x2,y2) = dest_abs tm2
      in if aconv x1 x2 then term_diff y1 y2 else
         if aconv y1 y2 then term_diff x1 x2 else
           (tm1,tm2)
      end else (T,T)

*)


(* generate a few tests *)

fun new_write_code_to_file filename th = let
  val _ = print ("Extracting code to file \"" ^ filename ^ "\" ... ")
  (* extract code from th *)
  val (m,pre,c,post) = (dest_spec o concl) th
  val cs = (list_dest pred_setSyntax.dest_insert c)
  val _ = pred_setSyntax.is_empty (last cs) orelse
          (print ("\n\nCode does not end in empty set. Found:\n\n"^
                  (term_to_string (last cs)) ^"\n\n"); fail())
  val cs = butlast cs
  (* turn into ML *)
  val p = hd cs |> rator |> free_vars |> hd
  val pat = ``^p + n2w m``
  fun dest_pc_plus_offset tm =
    if tm = p then 0 else
      let
        val (x,y) = wordsSyntax.dest_word_add tm
        val _ = if x = p then () else fail ()
        val n = y |> wordsSyntax.dest_n2w |> fst |> numSyntax.int_of_term
      in n end handle HOL_ERR _ =>
        failwith ("Unable to read offset from " ^ (term_to_string tm))
  val minus_zero = ``-1w:word8``
  fun dest_byte_list tm =
    listSyntax.dest_list tm |> fst
       |> map (fn tm => if tm = minus_zero then 255
                        else numSyntax.int_of_term (rand tm) mod 256)
  fun dest_code_pair tm = let
    val (x,y) = pairSyntax.dest_pair tm
    val n = dest_pc_plus_offset x
    in (n, dest_byte_list y) end
    handle HOL_ERR _ => (print "\n\n"; print_term tm; print "\n\n";
                         failwith "unable to extract code_pair")
  val code_pairs = map dest_code_pair cs
  (* sort, delete duplicates, check for overlaps etc. *)
  val vs = sort (fn (x,_) => fn (y:int,_) => x <= y) code_pairs
  fun del_repetations [] = []
    | del_repetations [x] = [x]
    | del_repetations (x::y::xs) = if x = y then del_repetations (x::xs) else
                                            x :: del_repetations (y::xs)
  val vs = del_repetations vs
  fun no_holes i [] = true
    | no_holes i ((j,c)::xs) =
       if i = j then no_holes (i + length c) xs else
       if i < j then failwith ("Gap in the code at location " ^ (int_to_string i))
       else failwith ("Duplicate code at location " ^ (int_to_string j))
  val _ = no_holes 0 vs
  (* compute size *)
  fun sum f [] k = k
    | sum f (n::ns) k = sum f ns (k + f n)
  val total = sum (length o snd) vs 0
  fun fill c d n s = if size s < n then fill c d n (c ^ s ^ d) else s
  fun num_to_string n =
    if n < 1000 then int_to_string n else
      num_to_string (n div 1000) ^ "," ^ fill "0" "" 3 (int_to_string (n mod 1000))
  val code_size_str = num_to_string total ^ " bytes"
  val _ = print (code_size_str ^ " ... ")
  (* produce output *)
  val {dir,...} = OS.Path.splitDirFile filename
  val () = if OS.FileSys.access (dir,[]) then () else OS.FileSys.mkDir dir
  val t = TextIO.openOut(filename)
  fun ex str = TextIO.output(t,str)
  fun print_bytes [] = ()
    | print_bytes [b] = ex (int_to_string b)
    | print_bytes (b::bs) = (ex (int_to_string b); ex ", "; print_bytes bs)
  fun print_lines [] = ()
    | print_lines ((n,bs)::rest) = let
    val _ = ex "\t.byte\t"
    val _ = print_bytes bs
    val _ = ex "\n"
    in print_lines rest end
  val l1 = "Machine code automatically extracted from a HOL4 theorem."
  val l2 = "The code size: " ^ code_size_str
  val l3 = "End of automatically extracted machine code."
  val _ = ex ("\n\t/*  " ^ l1 ^ "  */\n")
  val _ = ex ("\t/*  " ^ fill "" " " (size l1) l2 ^ "  */\n\n")
  val _ = print_lines vs
  val _ = ex ("\n\t/*  " ^ fill "" " " (size l1) l3 ^ "  */\n")
  val _ = TextIO.closeOut(t)
  val _ = print "done.\n"
  in () end;

local
  val pat = ``NUMERAL m + (NUMERAL n):num``
  fun ANY_ADD_EVAL_CONV tm =
    if can (match_term pat) tm then EVAL tm else NO_CONV tm
  val th0 = SPEC_COMPOSE_RULE [zHEAP_INIT,zHEAP_ABBREVS,
              zHEAP_SET_PRINTING_ON,zHEAP_SET_PRINTING_ON]
in
  fun generate_test th1 path = let
    val _ = print " [1]\n "
    val th = SPEC_COMPOSE_RULE [th0,th1,zHEAP_TERMINATE]
    val _ = print " [2]\n "
    val th = th |> SIMP_RULE (srw_ss()) [code_abbrevs_def,first_cs_def]
              |> SIMP_RULE (srw_ss()) [full_code_abbrevs_def,fetch "-" "full_cs_def"]
              |> RW [all_code_abbrevs,word_arith_lemma1]
              |> RW [INSERT_UNION_EQ,UNION_EMPTY]
              |> CONV_RULE ((RATOR_CONV o RAND_CONV) (DEPTH_CONV ANY_ADD_EVAL_CONV))
    val _ = print " [3]\n "
    val th = th |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) [first_cs_def,first_s_def]))
    val _ = print " [4]\n "
    val _ = time (new_write_code_to_file ("wrapper/" ^ path ^ "asm_code.s")) th
    in th end
end

(* generate some tests *)

val do_nothing_test = let
  val th0 = SPEC_COMPOSE_RULE [zHEAP_SET_PRINTING_ON]
            |> SIMP_RULE (srw_ss()) [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,first_s_def]
  in generate_test th0 "test-do-nothing/" end;

val print_true_test = let
  val th0 = SPEC_COMPOSE_RULE [print_true]
            |> SIMP_RULE (srw_ss()) [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,first_s_def]
  in generate_test th0 "test-print-true/" end;

val read_print_exit_test = let
  val th0 = SPEC_COMPOSE_RULE [zHEAP_NEXT_INPUT,zHEAP_READ_INPUT,zHEAP_PUT_CHAR]
            |> SIMP_RULE (srw_ss()) [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,first_s_def]
  in generate_test th0 "test-read-print-exit/" end;

val (res,echo_loop_def,echo_loop_pre_def) = x64_compile `
  echo_loop (s:zheap_state,x1) =
    let s = s with input := DROP 1 s.input in
    if s.input = "" then (s,x1) else
      let x1 = Number (&ORD (HD s.input)) in
      let s = s with output :=
                  STRCAT s.output (STRING (CHR (Num (getNumber x1))) "") in
        echo_loop (s:zheap_state,x1)`

val read_print_loop_test = let
  val res = res |> SIMP_RULE std_ss [LET_DEF]
                |> CONV_RULE (DEPTH_CONV (PairRules.PBETA_CONV))
  val th1 = SPEC_COMPOSE_RULE [res]
            |> SIMP_RULE (srw_ss()) [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,first_s_def]
  in generate_test th1 "test-read-print-loop/" end;

val (res,push_loop_def,_) = x64_compile `
  push_loop (s:zheap_state,x1,stack) =
    let s = s with input := DROP 1 s.input in
    if s.input = "" then (s,x1,stack) else
      let x1 = Number (&ORD (HD s.input)) in
      let stack = x1::stack in
        push_loop (s:zheap_state,x1,stack)`

val (res,print_loop_def,_) = x64_compile `
  print_loop (s:zheap_state,x1,stack) =
    let (x1,stack) = (HD stack, TL stack) in
      if isNumber x1 then
        let s = s with output :=
                    STRCAT s.output (STRING (CHR (Num (getNumber x1))) "") in
          print_loop (s:zheap_state,x1,stack)
      else (s:zheap_state,x1,stack)`

val (res,print_rev_def,_) = x64_compile `
  print_rev (s:zheap_state,stack) =
    let x1 = BlockNil in
    let stack = x1::stack in
    let (s,x1,stack) = push_loop (s,x1,stack) in
    let (s,x1,stack) = print_loop (s,x1,stack) in
      (s,x1,stack)`

val print_rev_test = let
  val res = res |> SIMP_RULE std_ss [LET_DEF]
                |> CONV_RULE (DEPTH_CONV (PairRules.PBETA_CONV))
  val th1 = SPEC_COMPOSE_RULE [res]
            |> SIMP_RULE (srw_ss()) [HD,TL,NOT_CONS_NIL,SEP_CLAUSES,first_s_def]
  in generate_test th1 "test-read-print-rev/" end;


val zHEAP_COND_TERMINATE = let
  val l = 0x8 + 7
  val (_,_,sts,_) = prog_x64Lib.x64_tools
  val th = zHEAP_TERMINATE |> RW [sts]
  val str = "jne " ^ int_to_string l
  val ((th1,_,_),th2x) = prog_x64Lib.x64_spec_memory64
          (x64_encodeLib.x64_encode str)
  val th2 = case th2x of SOME (x,_,_) => x | _ => fail()
  val thA = SPEC_COMPOSE_RULE [zHEAP_4EQ0,th2,th] |> RW [STAR_ASSOC]
             |> SIMP_RULE (std_ss++sep_cond_ss) [SEP_CLAUSES,precond_def]
             |> RW [SPEC_MOVE_COND] |> Q.INST [`rip`|->`p`]
  val th1 = SPEC_FRAME_RULE th1 ``zHEAP (cs,x1,x2,x3,x4,refs,stack,s,NONE) *
      zS1 Z_CF * zS1 Z_PF * zS1 Z_AF * zS1 Z_SF * zS1 Z_OF``
  val th1 = HIDE_POST_RULE ``zS1 Z_ZF`` th1
  val th1 = SPEC_COMPOSE_RULE [zHEAP_4EQ0,th1]
  val th1 = HIDE_STATUS_RULE true sts th1
  val thB = th1 |> SIMP_RULE (std_ss++sep_cond_ss) [SEP_CLAUSES,precond_def]
             |> RW [SPEC_MOVE_COND] |> Q.INST [`rip`|->`p`]
  val ss = SIMP_RULE (std_ss++star_ss) []
  val lemma = prove(
    ``(~b /\ d ==> (SPEC m p c1 q1)) /\
      (b /\ d ==> (SPEC m p c2 q2)) ==>
      c1 SUBSET c2 ==>
      (d ==> SPEC m p c2 (if b then q2 else q1))``,
    Cases_on `b` \\ Cases_on `d`
    \\ FULL_SIMP_TAC std_ss [] \\ METIS_TAC [SPEC_SUBSET_CODE])
  val th = MATCH_MP lemma (CONJ (ss thB) (ss thA))
  val th = th |> SIMP_RULE std_ss [STAR_ASSOC,INSERT_SUBSET,IN_INSERT,EMPTY_SUBSET]
              |> RW [GSYM SPEC_MOVE_COND]
  in th end

val getNumber_lex_until_semi_test = prove(
  ``~(getNumber (lex_until_semi_test input) < 0) /\
    isNumber (lex_until_semi_test input) /\
    ((getNumber (lex_until_semi_test input) = 0) =
      (lex_until_top_semicolon_alt input = NONE))``,
  SIMP_TAC std_ss [lex_until_semi_test_def]
  \\ Cases_on `lex_until_top_semicolon_alt input`
  \\ FULL_SIMP_TAC (srw_ss()) [] \\ EVAL_TAC);

val IF_SEP_DISJ = prove(
  ``((if b then c else d) \/ x) = if b then c \/ x else SEP_DISJ d x``,
  Cases_on `b` \\ SIMP_TAC std_ss [SEP_DISJ_def]);

val zHEAP_LEX_THEN_COND_TERMINATE =
  SPEC_COMPOSE_RULE [zHEAP_LEX,zHEAP_COND_TERMINATE]
  |> SIMP_RULE (srw_ss()) [getNumber_lex_until_semi_test,SEP_CLAUSES,IF_SEP_DISJ]

val zHEAP_BlockSome = let
  val tag = BlockSome_def |> SPEC_ALL |> concl |> rand |> rator |> rand
  val th1 =
    zHEAP_BIG_CONS
    |> Q.INST [`l`|->`1`,`n`|->`^tag`,`stack`|->`x::stack`]
    |> RW [GSYM BlockSome_def,EVAL ``REVERSE (TAKE 1 (x::xs))``,
         EVAL ``DROP 1 (x::xs)``] |> DISCH_ALL |> GEN_ALL
    |> SIMP_RULE (srw_ss()) [DECIDE ``1 <= SUC n:num``] |> SPEC_ALL
  in SPEC_COMPOSE_RULE [zHEAP_PUSH1,th1] end

val zHEAP_BlockPair = let
  val th1 =
    zHEAP_BIG_CONS
    |> Q.INST [`l`|->`2`,`n`|->`pair_tag`,`stack`|->`y::x::stack`]
    |> RW [EVAL ``REVERSE (TAKE 2 (y::x::xs))``,
         EVAL ``DROP 2 (y::x::xs)``] |> DISCH_ALL |> GEN_ALL
    |> SIMP_RULE (srw_ss()) [pair_tag_def,DECIDE ``2 <= SUC (SUC n):num``]
    |> SPEC_ALL |> RW [GSYM pair_tag_def,GSYM BlockPair_def]
  in SPEC_COMPOSE_RULE [zHEAP_PUSH2,zHEAP_PUSH1,th1] end

val zHEAP_ERASE_end_of_code = let
  val n = EVAL ``LENGTH end_of_code`` |> concl |> rand |> numLib.int_of_term
  fun rpt 0 x = [] | rpt n x = x :: rpt (n-1) x
  val f = foldr (fn (th1,th2) =>
            SPEC_COMPOSE_RULE [th1,th2] |> SIMP_RULE (srw_ss()) [])
  val th = f zHEAP_CODE_FRONT (rpt (n-1) zHEAP_CODE_FRONT)
  val lemma = prove(
    ``xs ++ y1::ys = SNOC y1 xs ++ ys``,
    SRW_TAC [] []);
  val th = th
    |> DISCH ``s.code = code ++ end_of_code``
    |> SIMP_RULE (srw_ss()) [end_of_code_def]
    |> RW [lemma,FRONT_SNOC,APPEND_NIL,rich_listTheory.NOT_SNOC_NIL,SEP_CLAUSES]
    |> RW [SNOC_APPEND,APPEND,GSYM APPEND_ASSOC]
    |> RW [GSYM end_of_code_def]
    |> RW [GSYM SPEC_MOVE_COND]
  in th end;

val zHEAP_1_Number_0 = zHEAP_Num1 |> Q.INST [`k`|->`0`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_2_Number_0 = zHEAP_Num2 |> Q.INST [`k`|->`0`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_3_Number_0 = zHEAP_Num3 |> Q.INST [`k`|->`0`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_1_Number_1 = zHEAP_Num1 |> Q.INST [`k`|->`1`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_1_Number_2 = zHEAP_Num1 |> Q.INST [`k`|->`2`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_LEX_THEN_COND_TERMINATE_UPDATE_JUMP = let
  val th1 = zHEAP_LEX_THEN_COND_TERMINATE
  val ((jmp_th,_,_),_) = prog_x64Lib.x64_spec_memory64 "E9"
  val th2 = SPEC_COMPOSE_RULE [zHEAP_BlockPair,zHEAP_BlockSome,
    zHEAP_MOVE_32,zHEAP_2_Number_0,zHEAP_UPDATE_REF,zHEAP_SET_PRINTING_OFF,
    zHEAP_POP4,zHEAP_POP1,jmp_th]
    |> SIMP_RULE std_ss [ADD_ASSOC]
  (* composing th1 and th2 *)
  val tm = ``lex_until_top_semicolon_alt s.input = NONE``
  val lemma = prove(``~(getNumber (lex_until_semi_test s.input) < 0)``,
    Cases_on `lex_until_top_semicolon_alt s.input`
    \\ ASM_SIMP_TAC (srw_ss()) [lex_until_semi_test_def] \\ EVAL_TAC)
  val thA = DISCH tm th1 |> SIMP_RULE std_ss [lemma,SEP_CLAUSES] |> UNDISCH
  val thB = DISCH (mk_neg tm) th1 |> SIMP_RULE std_ss [lemma,SEP_CLAUSES] |> UNDISCH
  val thB = SPEC_COMPOSE_RULE [thB, th2]
            |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND]
  val (_,_,c,_) = dest_spec (concl thB |> rand)
  val thA = SPEC c (MATCH_MP SPEC_SUBSET_CODE thA)
  val lemma = prove(thA |> concl |> dest_imp |> fst,
    SIMP_TAC std_ss [SUBSET_DEF,IN_INSERT,IN_UNION]
    \\ REPEAT STRIP_TAC \\ ASM_REWRITE_TAC [] \\ FULL_SIMP_TAC std_ss [])
  val thA = MP thA lemma
  val lemma = prove(
    ``(b1 ==> SPEC m p c q1) /\ (~b1 ==> b2 ==> SPEC m p c q2) ==>
      b2 ==> SPEC m p c (if b1 then q1 else q2)``,
    Cases_on `b2` \\ Cases_on `b1` \\ FULL_SIMP_TAC std_ss [])
  val th = MATCH_MP lemma (CONJ (DISCH_ALL thA) (DISCH_ALL thB))
           |> SIMP_RULE (srw_ss()) [ADD_ASSOC,GSYM SPEC_MOVE_COND]
  val th = th |> RW [isNumber_def,getNumber_def]
  in th end

(* printing a string (the error message, e.g. type error) *)

val (x64_print_str_spec,x64_print_str_def,x64_print_str_pre_def) = x64_compile `
  x64_print_str (x1,x2,x3,s) =
    if isSmall x1 then (x1,x2,x3,s) else
      let x3 = x1 in
      let x2 = Number 0 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let s = s with output :=
           STRCAT s.output (STRING (CHR (Num (getNumber x1))) "") in
      let x1 = x3 in
      let x2 = Number 1 in
      let x1 = EL (Num (getNumber x2)) (getContent x1) in
      let x3 = Number 1 in
        x64_print_str (x1,x2,x3,s)`

val x64_print_str_thm = prove(
  ``!xs x2 x3 s. ?y2 y3.
      x64_print_str_pre (BlockList (MAP Chr xs),x2,x3,s) /\
      (x64_print_str (BlockList (MAP Chr xs),x2,x3,s) =
         (BlockList [],y2,y3,s with output := STRCAT s.output xs))``,
  Induct THEN1
   (ONCE_REWRITE_TAC [x64_print_str_def,x64_print_str_pre_def]
    \\ SIMP_TAC std_ss [isSmall_def,BlockList_def,MAP,BlockNil_def]
    \\ EVAL_TAC \\ Cases \\ SRW_TAC [] (TypeBase.updates_of ``:zheap_state``))
  \\ SIMP_TAC std_ss [BlockList_def,MAP,Chr_def,BlockCons_def]
  \\ ONCE_REWRITE_TAC [x64_print_str_def,x64_print_str_pre_def]
  \\ SIMP_TAC std_ss [isSmall_def,BlockList_def,MAP,BlockNil_def]
  \\ SIMP_TAC (srw_ss()) [LET_DEF,getNumber_def,getContent_def,EL,isBlock_def,
       canCompare_def,isNumber_def,ORD_BOUND]
  \\ REPEAT STRIP_TAC \\ POP_ASSUM (MP_TAC o
       Q.SPECL [`Number 1`,`Number 1`,
       `s with output := STRCAT s.output (STRING (CHR (ORD h)) "")`])
  \\ REPEAT STRIP_TAC \\ FULL_SIMP_TAC std_ss [BlockList_def,BlockNil_def]
  \\ Cases_on `s` \\ SIMP_TAC std_ss [CHR_ORD]
  \\ SRW_TAC [] (TypeBase.updates_of ``:zheap_state``));

val (x64_print_string_spec,x64_print_string_def,x64_print_string_pre_def) = x64_compile `
  x64_print_string (x1,x2,x3,s,stack) =
    let stack = x2::stack in
    let stack = x3::stack in
    let (x1,x2,x3,s) = x64_print_str (x1,x2,x3,s) in
    let (x3,stack) = (HD stack, TL stack) in
    let (x2,stack) = (HD stack, TL stack) in
      (x1,x2,x3,s,stack)`

val x64_print_string_thm = prove(
  ``(x1 = BlockList (MAP Chr xs)) ==>
    x64_print_string_pre (x1,x2,x3,s,stack) /\
    (x64_print_string (x1,x2,x3,s,stack) =
       (BlockList [],x2,x3,s with output := STRCAT s.output xs,stack))``,
  SIMP_TAC std_ss [x64_print_string_def,LET_DEF,x64_print_string_pre_def,HD,TL]
  \\ REPEAT STRIP_TAC
  \\ ASSUME_TAC x64_print_str_thm \\ SEP_I_TAC "x64_print_str"
  \\ FULL_SIMP_TAC std_ss [NOT_CONS_NIL]);

val zHEAP_PRINT_STRING = x64_print_string_spec
    |> RW [UNDISCH x64_print_string_thm]
    |> SIMP_RULE std_ss [LET_DEF,SEP_CLAUSES]
    |> DISCH_ALL |> RW [GSYM SPEC_MOVE_COND]

val bool_to_val_11 = prove(
  ``!b1 b2. (bool_to_val b1 = bool_to_val b2) = (b1 = b2)``,
  Cases \\ Cases \\ FULL_SIMP_TAC std_ss [] \\ EVAL_TAC);

val inl_tag = BlockInl_def |> SPEC_ALL |> concl |> rand |> rator |> rand

val zHEAP_IF_INL_JUMP =
  SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_TagEq,zHEAP_JumpIf]
  |> Q.INST [`k`|->`^inl_tag`,`imm32`|->`inl_jump`] (* BlockInl_def *)
  |> SIMP_RULE (srw_ss()) [HD,TL,bool_to_val_11,NOT_CONS_NIL,isBlock_def,
       SEP_CLAUSES,bc_tag_eq_pre_def,getTag_def,isNumber_def,getNumber_def,
       LET_DEF,EVAL ``small_int (& (^inl_tag))``]

val zHEAP_IF_INL_JUMP_FALSE =
  zHEAP_IF_INL_JUMP |> DISCH ``getTag x1 <> ^inl_tag``
  |> SIMP_RULE std_ss [] |> RW [GSYM SPEC_MOVE_COND]

val zHEAP_IF_INL_JUMP_TRUE =
  zHEAP_IF_INL_JUMP |> DISCH ``getTag x1 = ^inl_tag``
  |> SIMP_RULE std_ss [] |> RW [GSYM SPEC_MOVE_COND]

val ref_adjust_IMP_ODD = prove(
  ``!r. r IN FDOM (ref_adjust (cb2,sb2,F) bs2.refs) ==> ODD r``,
  SIMP_TAC (srw_ss()) [ref_adjust_def,LET_DEF,PULL_EXISTS]
  \\ FULL_SIMP_TAC std_ss [GSYM ADD1,ODD,EVEN_DOUBLE,GSYM EVEN_ODD]);

val ref_adjust_IMP_EVEN = prove(
  ``!r. r IN FDOM (ref_adjust (cb2,sb2,T) bs2.refs) ==> EVEN r``,
  SIMP_TAC (srw_ss()) [ref_adjust_def,LET_DEF,PULL_EXISTS]
  \\ FULL_SIMP_TAC std_ss [GSYM ADD1,ODD,EVEN_DOUBLE,GSYM EVEN_ODD]);

val all_refs_def = Define `
  all_refs cb ev stack_trunk refs globals =
    ref_adjust (cb,stack_trunk  0x8w,ev) refs 
    ref_globals (cb,stack_trunk  0x8w,ev) globals`;

val both_refs_def = Define `
  both_refs stack_trunk cb1 s1 cb2 s2 =
    FUNION (all_refs cb1 T stack_trunk s1.refs s1.globals)
           (all_refs cb2 F stack_trunk s2.refs s2.globals)`

val IN_FDOM_all_refs = prove(
  ``(!x. x IN FDOM (all_refs t1_cb F stack_trunk t1.refs t1.globals) ==> ODD x) /\
    (!x. x IN FDOM (all_refs t1_cb T stack_trunk t1.refs t1.globals) ==> EVEN x)``,
  fs [all_refs_def] \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC ref_adjust_IMP_EVEN
  \\ IMP_RES_TAC ref_adjust_IMP_ODD
  \\ fs [ref_globals_def]);

val zBC_HEAP_EVAL_UNTIL_STOP = let
  val th1 = zBC_HEAP_N
    |> Q.SPECL [`n`,`s1`,`s2`]
    |> UNDISCH_ALL
    |> MATCH_MP SPEC_N_IMP_SPEC |> DISCH_ALL
    |> RW [standalone_bc_init_state_lemma]
    |> Q.INST [`stack`|->`[]`]
    |> RW [LENGTH,ADD1] |> SIMP_RULE std_ss []
    |> UNDISCH_ALL
  val th2 =
    zBC_HEAP_Stop
    |> Q.INST [`s1`|->`s2`,`s2`|->`s3`,`stack`|->`[]`]
    |> UNDISCH_ALL
  val th3 =
    MATCH_MP SPEC_EXTEND_CODE th2 |> Q.SPEC `x64_code 0 bc_code`
    |> DISCH_ALL |> SIMP_RULE std_ss []
    |> SIMP_RULE std_ss [AND_IMP_INTRO]
  val goal = concl th3 |> dest_imp |> fst
  val goal =
    ``(bc_fetch s2 = SOME (Stop b)) /\ (s2.code = bc_code) /\
      (s2.inst_length = x64_inst_length) ==> ^goal``
  val lemma = prove(goal,
    fs [bc_fetch_def] \\ REPEAT STRIP_TAC
    \\ MATCH_MP_TAC x64_code_EQ_x64 \\ fs [])
  val th4 = MP th3 (lemma |> UNDISCH)
  val set_lemma = prove(
    ``x INSERT (s UNION (x INSERT s)) = x INSERT s``,
    fs [EXTENSION] \\ METIS_TAC [])
  val th5 = SPEC_COMPOSE_RULE [th1,th4]
            |> Q.INST [`bc_code`|->`s1.code`]
            |> RW [set_lemma]
  in th5 end;

val SPEC_zBC_HEAP_MOVE_CODE =
  SPEC_N_zBC_HEAP_MOVE_CODE |> Q.INST [`n`|->`0`] |> RW [SPEC_N_0]

val zBC_HEAP_EVAL_UNTIL_STOP_ALT =
  zBC_HEAP_EVAL_UNTIL_STOP
  |> Q.INST [`s`|->`s with code_mode := NONE`]
  |> MATCH_MP SPEC_zBC_HEAP_MOVE_CODE
  |> DISCH_ALL
  |> Q.GEN `cb`
  |> Q.GEN `sb` |> SIMP_RULE std_ss [GSYM AND_IMP_INTRO]
  |> UNDISCH_ALL

val bc_adjust_bool_to_val = prove(
  ``bc_adjust (cb,sb,ev) (bool_to_val b) = bool_to_val b``,
  Cases_on `b` \\ EVAL_TAC);

val SPEC_NEW_DISJ = prove(
  ``SPEC m p c q ==> !r. SPEC m (p \/ r) c (q \/ r)``,
  fs [SPEC_PRE_DISJ] \\ REPEAT STRIP_TAC
  THEN1
   (IMP_RES_TAC SPEC_WEAKEN
    \\ POP_ASSUM MATCH_MP_TAC
    \\ fs [SEP_IMP_def,SEP_DISJ_def])
  \\ `SPEC m r c r` by fs [SPEC_REFL]
  \\ IMP_RES_TAC SPEC_WEAKEN
  \\ POP_ASSUM (K ALL_TAC)
  \\ POP_ASSUM MATCH_MP_TAC
  \\ fs [SEP_IMP_def,SEP_DISJ_def]);

val NRC_bc_next_strip_labels = prove(
  ``!n s1 s2.
      NRC bc_next n s1 s2 /\ (s1.inst_length = x64_inst_length) ==>
      NRC bc_next n (strip_labels s1) (strip_labels s2)``,
  Induct \\ fs [NRC] \\ REPEAT STRIP_TAC
  \\ Q.EXISTS_TAC `(strip_labels z)`
  \\ `length_ok s1.inst_length` by fs [length_ok_x64_inst_length]
  \\ IMP_RES_TAC bytecodeLabelsTheory.bc_next_strip_labels
  \\ fs [] \\ FIRST_X_ASSUM MATCH_MP_TAC \\ fs []
  \\ IMP_RES_TAC bc_next_preserves_inst_length \\ fs []) |> SPEC_ALL;

val bc_fetch_strip_labels = prove(
  ``(bc_fetch s2 = SOME (Stop b)) /\ (s2.inst_length = x64_inst_length) ==>
    (bc_fetch (strip_labels s2) = SOME (Stop b))``,
  REPEAT STRIP_TAC
  \\ `length_ok s2.inst_length` by fs [length_ok_x64_inst_length]
  \\ IMP_RES_TAC bytecodeLabelsTheory.bc_fetch_strip_labels);

val zHEAP_EVAL_UNTIL_STOP = let
  val th =
    zBC_HEAP_EVAL_UNTIL_STOP
    |> SPEC_ALL
    |> DISCH ``(s1:bc_state).stack = []``
    |> DISCH ``(s2:bc_state).stack = []``
    |> DISCH ``s.local.printing_on = 0x0w``
    |> Q.INST [`stack`|->`[]`,`ev`|->`T`,
              `f2`|->`all_refs t1_cb F cs.stack_trunk t1.refs t1.globals`]
    |> DISCH ``cs.stack_trunk - 0x8w = sb`` |> Q.GEN `sb`
    |> SIMP_RULE std_ss [LENGTH,zBC_HEAP_def,LET_DEF,MAP,HD,TL,APPEND,SEP_CLAUSES,
         FUNION_ASSOC,GSYM all_refs_def,ref_addr_def,IN_FDOM_all_refs,
         EVAL ``((s2:bc_state) with stack := [x]).stack``,
         EVAL ``((s2:bc_state) with stack := [x]).refs``,
         EVAL ``((s2:bc_state) with stack := [x]).globals``,
         EVAL ``((s2:bc_state) with stack := [x]).handler``,
         bc_adjust_bool_to_val,GSYM SPEC_PRE_EXISTS,APPEND_NIL]
    |> UNDISCH_ALL
    |> SPEC_ALL
    |> DISCH ``cb + n2w (2 * s1.pc) =
               p + n2w (24 + SIGN_EXTEND 32 64 (w2n (imm32:word32))):word64``
    |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  val SPEC_zHEAP_SWAP = prove(
    ``SPEC m (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) * zPC p * ~zS) c q ==>
      !t p'. ((cs,x1,x2,x3,x4,refs,stack,s,space) = t) /\ (p = p') ==>
             SPEC m (zHEAP t * zPC p' * ~zS) c q``,
    fs []);
  val th1 =
    MATCH_MP SPEC_zHEAP_SWAP th
    |> Q.SPECL [`(cs',x1',x2',x3',x4',refs',stack',s'',space')`,`pp`]
    |> RW [PAIR_EQ,GSYM AND_IMP_INTRO]
    |> RW [theorem "zheap_state_component_equality"]
    |> SIMP_RULE (srw_ss()) []
    |> Q.INST [`s''`|->`s`] |> RW []
    |> UNDISCH_ALL
  val th = th |> Q.INST [`s`|->`s with local := s.local with stop_addr := p + 0x18w`]
  val th = SPEC_COMPOSE_RULE [zHEAP_SET_STOP_ADDR_ALT,th1]
  val th = th |> DISCH_ALL |> GEN_ALL |> SIMP_RULE std_ss []
              |> SPEC_ALL |> UNDISCH_ALL
  val th = th |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss()) []))
  val th = th |> RW [GSYM both_refs_def]
  val th = th |> Q.INST [`imm32`|->`repl_step_imm32`]
  val th1 = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_MOVE_23]
    |> Q.INST [`stack`|->`[Number 0]`]
    |> RW [HD,TL,NOT_CONS_NIL,SEP_CLAUSES]
    |> MATCH_MP SPEC_NEW_DISJ |> Q.SPEC `zHEAP_ERROR cs`
    |> Q.GENL [`x3`,`x2`] |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val lemma = SPEC_COMPOSE |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  val th = MATCH_MP (MATCH_MP lemma th1) th
  val th = th |> SIMP_RULE std_ss [word_arith_lemma1]
  val th = th
    |> Q.INST [`s1`|->`strip_labels s1`,`s2`|->`strip_labels s2`]
    |> DISCH_ALL |> SIMP_RULE (srw_ss()) [bytecodeLabelsTheory.strip_labels_def,
         both_refs_def] |> RW [GSYM bytecodeLabelsTheory.strip_labels_def]
    |> UNDISCH_ALL |> RW [GSYM both_refs_def]
    |> DISCH ``NRC bc_next n (strip_labels s1) (strip_labels s2)``
    |> (fn th => MATCH_MP th (UNDISCH NRC_bc_next_strip_labels))
    |> DISCH ``bc_fetch (strip_labels s2) = SOME (Stop b)``
    |> (fn th => MATCH_MP th (UNDISCH bc_fetch_strip_labels))
    |> DISCH_ALL |> RW [GSYM AND_IMP_INTRO] |> UNDISCH_ALL
  in th end

val EL_SIMPS =
  LIST_CONJ [EVAL ``EL 0 (x::xs)``,
             EVAL ``EL 1 (x::x1::xs)``,
             EVAL ``EL 2 (x::x1::x2::xs)``,
             EVAL ``EL 3 (x::x1::x2::x3::xs)``,
             EVAL ``EL 4 (x::x1::x2::x3::x4::xs)``,
             integerTheory.NUM_OF_INT,
             getNumber_def,getContent_def,LENGTH,isNumber_def,isBlock_def,
             integerTheory.INT_LT_CALCULATE,integerTheory.INT_LE_CALCULATE]

val zHEAP_REPL_STEP_UNTIL_INL_IF = let
  val th =
    zHEAP_EVAL_UNTIL_STOP
    |> Q.INST [`x`|->`Block 0 [RefPtr 1; RefPtr (2 * iptr + 2);
                                         RefPtr (2 * optr + 2)]`]
  val th =
    SPEC_COMPOSE_RULE [th,
       zHEAP_MOVE_42,zHEAP_1_Number_1,zHEAP_EL,
       zHEAP_MOVE_12,zHEAP_1_Number_2,zHEAP_EL,
       zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_DEREF]
    |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def]
    |> DISCH ``both_refs cs.stack_trunk cb s2 t1_cb t1 ' (2 * optr + 2) =
                 ValueArray (inl_or_inr::ys)``
    |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,getValueArray_def,
          isRefPtr_def,isValueArray_def] |> UNDISCH_ALL
  val th = SPEC_COMPOSE_RULE [th,zHEAP_IF_INL_JUMP]
  val th = th |> SIMP_RULE std_ss [ADD_ASSOC]
  in th end;

val zHEAP_ERROR_ERROR = prove(
  ``(if b then x \/ y else x2 \/ y) \/ y = if b then x \/ y else SEP_DISJ x2 y``,
  Cases_on `b` \\ fs [] \\ fs [SEP_DISJ_ASSOC] \\ fs [SEP_DISJ_def]);

val (code_length_inr,zHEAP_REPL_RUN_INR_RAW) = let
  val th = zHEAP_REPL_STEP_UNTIL_INL_IF
    |> Q.INST [`inl_or_inr`|->`BlockInr (BlockPair (msg_chars,y7))`]
    |> SIMP_RULE std_ss [(REWRITE_CONV[BlockInr_def]THENC EVAL) ``getTag (BlockInr x)``]
  val th = SPEC_COMPOSE_RULE [th,zHEAP_PUSH3,zHEAP_PUSH4]
  val th =
    SPEC_COMPOSE_RULE [th,
       zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_EL,zHEAP_MOVE_13,
       zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_EL]
    |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,
         BlockInr_def,BlockPair_def]
  val th =
    SPEC_COMPOSE_RULE [th,zHEAP_PRINT_STRING]
    |> SIMP_RULE (std_ss++sep_cond_ss) [SPEC_MOVE_COND] |> UNDISCH_ALL
  val th =
    SPEC_COMPOSE_RULE [th,
       zHEAP_MOVE_32,zHEAP_1_Number_1,zHEAP_EL,zHEAP_PUSH1,
       zHEAP_MOVE_42,zHEAP_1_Number_1,zHEAP_EL,
       zHEAP_MOVE_12,zHEAP_1_Number_1,zHEAP_EL,
       zHEAP_2_Number_0,zHEAP_MOVE_13,zHEAP_POP1]
    |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,
         BlockInr_def,BlockPair_def,HD,TL,NOT_CONS_NIL]
    |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[]))
  val th = SPEC_COMPOSE_RULE [th,zHEAP_LEX_THEN_COND_TERMINATE_UPDATE_JUMP]
    |> SIMP_RULE std_ss [HD,TL,NOT_CONS_NIL,getRefPtr_def,
         getNumber_def,isNumber_def,isRefPtr_def,EL_SIMPS]
    |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[]))
  val th = th
    |> DISCH ``both_refs cs.stack_trunk cb s2 t1_cb t1 ' (2 * iptr + 2) =
               ValueArray [tt]``
    |> SIMP_RULE std_ss [getValueArray_def,isValueArray_def,ADD_ASSOC,
         EVAL ``LUPDATE x 0 [y]``,LENGTH,SEP_CLAUSES] |> UNDISCH_ALL
    |> RW [zHEAP_ERROR_ERROR]
  val tm = get_pc th
  val code_length = tm |> rand |> rand |> rand |> rator |> rand
  val lemma = prove(``0x10000000000000000w:word64 = 0w``,fs [n2w_11])
  val th =
    th |> Q.INST [`imm32`|->`0w - n2w ^code_length`]
       |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[lemma]))
       |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss())[]))
       |> RW [EVAL ``-1w:word8``]
  val code_length_inr = code_length
  in (code_length_inr,th) end;

val (zHEAP_REPL_RUN_INR,zHEAP_REPL_RUN_INL_START) = let
  val th = zHEAP_REPL_STEP_UNTIL_INL_IF
    |> Q.INST [`inl_or_inr`|->`BlockInl (BlockPair (x7,y7))`]
    |> SIMP_RULE std_ss [(REWRITE_CONV[BlockInl_def] THENC EVAL) ``getTag (BlockInl x)``]
  val n = get_pc th |> rand |> rand |> rand |> rator |> rand
  val inl_jump = ``n2w (^code_length_inr - ^n):word32``
  val lemma = prove(``0x10000000000000000w:word64 = 0w``,fs [n2w_11])
  val th_inl =
    th |> Q.INST [`inl_jump`|->`^inl_jump`]
       |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[lemma]))
       |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss())[]))
  val th_inr = zHEAP_REPL_RUN_INR_RAW
       |> Q.INST [`inl_jump`|->`^inl_jump`]
       |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[lemma]))
       |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss())[]))
  in (th_inr,th_inl) end;

val zHEAP_RUN_INL_UP_TO_EVAL = let
  val th =
    zHEAP_REPL_RUN_INL_START
    |> Q.INST [`x7`|->`BlockList (MAP BlockNum3 code)`,
               `y7`|->`new_states`]
    |> RW [BlockInl_def,SEP_CLAUSES]
  val th1 =
    zHEAP_BIG_CONS
    |> Q.INST [`l`|->`2`,`n`|->`0`,`stack`|->`y::x::stack`]
    |> RW [EVAL ``REVERSE (TAKE 2 (y::x::xs))``,
         EVAL ``DROP 2 (y::x::xs)``] |> DISCH_ALL |> GEN_ALL
    |> SIMP_RULE std_ss [LENGTH,ADD1,GSYM ADD_ASSOC] |> SPEC_ALL
  val th2 = SPEC_COMPOSE_RULE [zHEAP_PUSH1,zHEAP_PUSH4,th1]
  val th3 =
    SPEC_COMPOSE_RULE [th,
      zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_EL,
      zHEAP_MOVE_12,zHEAP_1_Number_1,zHEAP_EL,
      zHEAP_1_Number_0,zHEAP_EL,zHEAP_MOVE_13,
      zHEAP_1_Number_1,zHEAP_EL,zHEAP_MOVE_42,
      zHEAP_BlockPair,zHEAP_MOVE_14,
      zHEAP_1_Number_1,zHEAP_EL,
      zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_EL,
      th2,zHEAP_MOVE_14,
      zHEAP_MOVE_34,
      zHEAP_2_Number_0,zHEAP_SET_PRINTING_ON,
      zHEAP_3_Number_0,zHEAP_PUSH2]
      |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,
           BlockPair_def]
  val th4 =
    zHEAP_INSTALL_CODE
    |> GSYM |> SIMP_RULE std_ss [SPEC_MOVE_COND]
    |> UNDISCH_ALL
  val th5 =
    SPEC_COMPOSE_RULE [th3,th4]
    |> RW [HD,TL]
    |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
  val pat = ``install_x64_code_lists x y``
  val tms = find_terms (can (match_term pat)) (concl th5)
  val tm1 = hd tms
  val tm2 = hd (tl tms) handle Empty => hd tms
  val f1 = mk_eq(tm1,mk_var("s_install1",type_of tm1))
  val f2 = mk_eq(tm2,mk_var("s_install2",type_of tm2))
  val th6 = th5
    |> DISCH f1 |> SIMP_RULE std_ss [] |> UNDISCH_ALL
    |> DISCH f2 |> SIMP_RULE std_ss [] |> UNDISCH_ALL
  in th6 end;

val both_refs_intro = prove(
  ``FUNION (all_refs s1_cb F t s1.refs s1.globals)
           (all_refs t1_cb T t t1.refs t1.globals) =
    both_refs t t1_cb t1 s1_cb s1``,
  fs [both_refs_def]
  \\ MATCH_MP_TAC FUNION_COMM
  \\ fs [DISJOINT_DEF,all_refs_def,ref_globals_def,EXTENSION]
  \\ REPEAT STRIP_TAC \\ CCONTR_TAC \\ fs []
  \\ IMP_RES_TAC ref_adjust_IMP_ODD
  \\ IMP_RES_TAC ref_adjust_IMP_EVEN
  \\ fs [ODD_EVEN] \\ SRW_TAC [] []
  \\ fs [EVAL ``ODD 0``,EVAL ``EVEN 1``]);

val zHEAP_RUN_INL_INCLUDING_EVAL = let
  val th =
    zBC_HEAP_EVAL_UNTIL_STOP_ALT
    |> SPEC_ALL
    |> DISCH ``(s1:bc_state).stack = []``
    |> DISCH ``(s2:bc_state).stack = []``
    |> DISCH ``s.local.printing_on = 1w``
    |> Q.INST [`stack`|->`[]`,`ev`|->`F`,`n`|->`n1`,
              `f2`|->`all_refs t1_cb T cs.stack_trunk t1.refs t1.globals`]
    |> DISCH ``cs.stack_trunk - 0x8w = sb`` |> Q.GEN `sb`
    |> SIMP_RULE std_ss [LENGTH,zBC_HEAP_def,LET_DEF,MAP,HD,TL,APPEND,SEP_CLAUSES,
         FUNION_ASSOC,GSYM all_refs_def,ref_addr_def,IN_FDOM_all_refs,
         EVAL ``((s2:bc_state) with stack := [x]).stack``,
         EVAL ``((s2:bc_state) with stack := [x]).refs``,
         EVAL ``((s2:bc_state) with stack := [x]).globals``,
         EVAL ``((s2:bc_state) with stack := [x]).handler``,
         bc_adjust_bool_to_val,GSYM SPEC_PRE_EXISTS]
    |> UNDISCH_ALL
    |> SPEC_ALL
    |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
    |> RW [both_refs_intro]
  val th1 = SPEC_COMPOSE_RULE [zHEAP_POP2,zHEAP_MOVE_23]
    |> Q.INST [`stack`|->`[Number 0]`]
    |> RW [HD,TL,NOT_CONS_NIL,SEP_CLAUSES]
    |> MATCH_MP SPEC_NEW_DISJ |> Q.SPEC `zHEAP_ERROR cs`
    |> Q.GENL [`x3`,`x2`] |> SIMP_RULE std_ss [SPEC_PRE_EXISTS]
  val lemma = SPEC_COMPOSE |> RW1 [CONJ_COMM] |> RW [GSYM AND_IMP_INTRO]
  val th = MATCH_MP (MATCH_MP lemma th1) th
  val th = th |> SIMP_RULE std_ss [word_arith_lemma1]
  val vs = free_vars (concl th)
  fun new_sub v = v |-> mk_var((dest_var v |> fst) ^ "_new", type_of v)
  val th = th
    |> INST (map new_sub vs)
    |> Q.INST [`cs_new`|->`cs`]
  val SPEC_zHEAP_SWAP = prove(
    ``SPEC m (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) * zPC p * ~zS) c q ==>
      !t p'. ((cs,x1,x2,x3,x4,refs,stack,s,space) = t) /\ (p = p') ==>
             SPEC m (zHEAP t * zPC p' * ~zS) c q``,
    fs []);
  val th1 =
    MATCH_MP SPEC_zHEAP_SWAP th
    |> Q.SPECL [`(cs,x1_3,x2_3,x3_3,x4_3,refs_3,stack_3,s_3,space_3)`,`pp`]
    |> RW [PAIR_EQ,GSYM AND_IMP_INTRO]
    |> RW [theorem "zheap_state_component_equality"]
    |> SIMP_RULE (srw_ss()) []
    |> Q.INST [`s_3`|->`s_new`] |> RW []
    |> UNDISCH_ALL
  val pc =
    zHEAP_RUN_INL_UP_TO_EVAL
    |> concl |> rator |> rand
    |> find_terms pairSyntax.is_pair |> hd |> rator |> rand
  val th = SPEC_COMPOSE_RULE [zHEAP_RUN_INL_UP_TO_EVAL,th1]
  val th = th |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
              |> RW [GSYM BlockBool_def]
  in th end;

val zHEAP_RUN_INL = let
  val th =
    SPEC_COMPOSE_RULE [zHEAP_RUN_INL_INCLUDING_EVAL,
      zHEAP_MOVE_13,zHEAP_MOVE_42,
      zHEAP_1_Number_1,zHEAP_EL,
      zHEAP_MOVE_12,zHEAP_1_Number_0,zHEAP_PUSH1,zHEAP_EL,zHEAP_MOVE_14,
      zHEAP_1_Number_1,zHEAP_EL,zHEAP_MOVE_32,zHEAP_BlockPair,
      zHEAP_PUSH4,zHEAP_MOVE_42,zHEAP_MOVE_14,
      zHEAP_1_Number_1,zHEAP_EL,
      zHEAP_MOVE_12,zHEAP_1_Number_1,zHEAP_EL,
      zHEAP_MOVE_12,zHEAP_MOVE_13,zHEAP_MOVE_41]
        |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,
             BlockPair_def]
  val th1 =
    SPEC_COMPOSE_RULE [th,zHEAP_LEX_THEN_COND_TERMINATE_UPDATE_JUMP]
      |> SIMP_RULE std_ss [isRefPtr_def,HD,TL,NOT_CONS_NIL,getRefPtr_def]
  val Num_0 = intLib.COOPER_PROVE ``Num 0 = 0``
  val th2 = th1
    |> SIMP_RULE std_ss [HD,TL,NOT_CONS_NIL,getRefPtr_def,
         getNumber_def,isNumber_def,isRefPtr_def,EL_SIMPS]
    |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[]))
    |> RW [zHEAP_ERROR_ERROR,Num_0]
  val c = SIMP_CONV (srw_ss()) []
  val c1 = SIMP_CONV std_ss [word_arith_lemma1]
  val th3 = th2
    |> DISCH ``both_refs cs.stack_trunk t1_cb_new t1_new
                 cs.code_heap_ptr s2_new ' (2 * iptr + 2) = ValueArray [tt]``
    |> SIMP_RULE std_ss [getValueArray_def,isValueArray_def,ADD_ASSOC,
         EVAL ``LUPDATE x 0 [y]``,LENGTH,SEP_CLAUSES] |> UNDISCH_ALL
    |> CONV_RULE (RAND_CONV c THENC (RATOR_CONV o RAND_CONV) c)
    |> DISCH_ALL |> RW [AND_IMP_INTRO]
    |> CONV_RULE ((RATOR_CONV o RAND_CONV) c)
    |> RW [GSYM AND_IMP_INTRO] |> UNDISCH_ALL
    |> CONV_RULE (RAND_CONV c1)
    |> RW1 [DECIDE ``m + n + k = (m+k)+n:num``]
    |> SIMP_RULE std_ss []
  val tm = get_pc th3
  val code_length = tm |> rand |> rand |> rand |> rator |> rand
  val lemma = prove(``0x10000000000000000w:word64 = 0w``,fs [n2w_11])
  val th4 =
    th3 |> Q.INST [`imm32`|->`0w - n2w ^code_length`]
        |> CONV_RULE (POST_CONV (SIMP_CONV (srw_ss())[lemma]))
        |> CONV_RULE ((RATOR_CONV o RAND_CONV) (SIMP_CONV (srw_ss())[]))
        |> RW [EVAL ``-1w:word8``]
  in th4 end;

(* merge code segments in the three main theorems *)

val (thm_inr,thm_inl,thm_inl_div) = let
  val th1 = zHEAP_REPL_RUN_INR
  val th2 = zHEAP_RUN_INL
  val th3 = zHEAP_RUN_INL_UP_TO_EVAL
  val insert_lemma = prove(
    ``$INSERT x = $UNION {x}``,
   fs [FUN_EQ_THM]);
  fun part P xs = let
    fun partition [] (ys,zs) = (rev ys,rev zs)
      | partition (x::xs) (ys,zs) =
          if P x then partition xs (x::ys,zs)
                 else partition xs (ys,x::zs)
    in partition xs ([],[]) end
  fun f th1 = let
    val th2 = th1 |> RW1 [insert_lemma] |> RW [UNION_EMPTY,code_abbrevs_def]
    val c = th2 |> concl |> rator |> rand
    val cs = list_dest pred_setSyntax.dest_union c |> all_distinct
    val (cs1,cs2) = part pred_setSyntax.is_insert cs
    in (map (rand o rator) cs1, cs2) end
  val (xs1,ys1) = f th1
  val (xs2,ys2) = f th2
  val (xs3,ys3) = f th3
  fun filter_same [] = []
    | filter_same (x::xs) =
        x :: filter_same (filter (fn y => y <> x) xs)
  val all_xs = filter_same (xs1 @ xs2 @ xs3)
  val all_ys = filter_same (ys1 @ ys2 @ ys3)
  val ys_set = foldl (fn (x,y) => pred_setSyntax.mk_union (y,x))
                  (hd all_ys) (tl all_ys)
  val new_code = foldr pred_setSyntax.mk_insert ys_set all_xs
  fun replace_with_new_code th = let
    val lemma = MATCH_MP SPEC_SUBSET_CODE th |> SPEC new_code
    val goal = lemma |> concl |> dest_imp |> fst
    val x = prove(goal,
      REWRITE_TAC [INSERT_SUBSET,UNION_SUBSET,EMPTY_SUBSET,code_abbrevs_def]
      \\ REWRITE_TAC [SUBSET_DEF,IN_INSERT,IN_UNION,NOT_IN_EMPTY]
      \\ REPEAT STRIP_TAC \\ ASM_REWRITE_TAC [])
    val th = MP lemma x
    in th end
  val th1 = th1 |> replace_with_new_code
  val th2 = th2 |> replace_with_new_code
  val th3 = th3 |> replace_with_new_code
  in (th1,th2,th3) end;

(* a bit of automation *)

val SPEC_WEAKEN_LEMMA_GEN = prove(
  ``(b ==> SPEC m p c q1) ==>
    !i q2. (i ==> b /\ SEP_IMP q1 q2) ==> SPEC m (p * cond i) c q2``,
  STRIP_TAC \\ STRIP_TAC \\ MATCH_MP_TAC SPEC_WEAKEN_LEMMA
  \\ Cases_on `i` \\ Cases_on `b` \\ fs [SPEC_MOVE_COND]);

val IMP_SPEC_POST_COND = prove(
  ``(b ==> SPEC m p c q) ==>
    b ==> SPEC m p c (q * cond b)``,
  fs [SEP_CLAUSES]);

val SPEC_HIDE_ASSUM_AND_POST = prove(
  ``(!x. a x ==> SPEC m p c (q x)) ==>
    ($? a) ==> SPEC m p c ($SEP_EXISTS q)``,
  REPEAT STRIP_TAC
  \\ `?x. a x` by (CONV_TAC (RAND_CONV ETA_CONV) \\ fs [])
  \\ RES_TAC
  \\ IMP_RES_TAC SPEC_WEAKEN
  \\ FIRST_X_ASSUM MATCH_MP_TAC
  \\ fs [SEP_IMP_def,SEP_EXISTS] \\ METIS_TAC []);

(* lemmas about COMPILER_RUN_INV *)

val COMPILER_RUN_INV_inst_length = prove(
  ``COMPILER_RUN_INV bs1 grd1 inp1 out1 ==>
    (bs1.inst_length = real_inst_length)``,
  fs [COMPILER_RUN_INV_def] \\ SRW_TAC [] []
  \\ fs [repl_bc_state_def,initCompEnvTheory.install_code_def]
  \\ POP_ASSUM (K ALL_TAC)
  \\ ASSUME_TAC bootstrap_bc_state_def \\ fs[]
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
  \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
  \\ fs [initCompEnvTheory.install_code_def,
         initCompEnvTheory.initial_bc_state_def,
         initCompEnvTheory.empty_bc_state_def]);

(* various lemmas *)

val DIV_2_ADD_LEMMA =
  ``2 * (k + 1) DIV 2``
  |> SIMP_CONV std_ss [RW1[MULT_COMM]MULT_DIV]
  |> SIMP_RULE std_ss [LEFT_ADD_DISTRIB];

val both_refs_FAPPLY = prove(
  ``n IN FDOM bs2.refs /\ (bs2.refs ' n = ValueArray xs) ==>
    (both_refs w cb bs2 t1_cb t1 ' (2 * n + 2) =
     ValueArray (MAP (bc_adjust (cb,w-8w,T)) xs))``,
  fs [both_refs_def,all_refs_def,FUNION_DEF,ref_globals_def,
      FAPPLY_FUPDATE_THM]
  \\ REPEAT STRIP_TAC
  \\ fs [ref_adjust_def,FUN_FMAP_DEF,LET_DEF,LEFT_ADD_DISTRIB,
         DECIDE ``(2*n = 2*m) = (n = m:num)``,DIV_2_ADD_LEMMA])

val FUNION_FUPDATE_MOVE = prove(
  ``(FUNION f1 f2) |+ (x,y) = FUNION (f1 |+ (x,y)) f2``,
  fs [GSYM fmap_EQ,FUN_EQ_THM,FAPPLY_FUPDATE_THM,FUNION_DEF]
  \\ METIS_TAC []);

val both_refs_FUPDATE = prove(
  ``both_refs w cb
       (bs2 with refs := bs2.refs |+ (n, ValueArray xs)) t1_cb t1 =
    both_refs w cb bs2 t1_cb t1 |+
       (2 * n + 2, ValueArray (MAP (bc_adjust (cb,w-8w,T)) xs))``,
  fs [both_refs_def,FUNION_FUPDATE_MOVE,all_refs_def]
  \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
  \\ Q.ABBREV_TAC `q = w + 0xFFFFFFFFFFFFFFF8w` \\ POP_ASSUM (K ALL_TAC)
  \\ fs [ref_adjust_def,LET_DEF]
  \\ fs [fmap_EXT,FAPPLY_FUPDATE_THM,FUNION_DEF,LEFT_ADD_DISTRIB]
  \\ STRIP_TAC \\ Cases_on `x = 2 * n + 2`
  \\ fs [FUN_FMAP_DEF,FDOM_FINITE,IMAGE_FINITE,FINITE_INSERT]
  \\ REPEAT STRIP_TAC \\ SRW_TAC [] []
  \\ fs [FUN_FMAP_DEF,IN_INSERT,DIV_2_ADD_LEMMA])

val bc_adjust_BlockList_Chr = prove(
  ``!msg xs. (bc_adjust (cb,w,b) (BlockList (MAP Chr msg)) =
              BlockList (MAP Chr xs)) = (msg = xs)``,
  Induct \\ Cases_on `xs` \\ fs [bc_adjust_def,BlockList_def,
    BlockNil_def,BlockCons_def,Chr_def,ORD_11]);

val bc_adjust_BlockList_BlockSym = prove(
  ``bc_adjust (cb,w,b) (BlockList (MAP BlockSym ts)) =
    BlockList (MAP BlockSym ts)``,
  Induct_on `ts` \\ fs [bc_adjust_def,BlockList_def,
    BlockNil_def,BlockCons_def,Chr_def,ORD_11,BlockSym_def]
  \\ Cases \\ EVAL_TAC \\ fs [bc_adjust_BlockList_Chr]);

val bc_adjust_BlockList_BlockNum3 = prove(
  ``bc_adjust (cb,w,b) (BlockList (MAP BlockNum3 code)) =
    BlockList (MAP BlockNum3 code)``,
  Induct_on `code` \\ fs [bc_adjust_def,BlockList_def,
    BlockNil_def,BlockCons_def,Chr_def,ORD_11,BlockNum3_def]
  \\ Cases \\ Cases_on `r` \\ EVAL_TAC \\ fs [bc_adjust_BlockList_Chr]);

val install_x64_code_lists_alt_def = Define `
  (install_x64_code_lists_alt [] n = []) /\
  (install_x64_code_lists_alt (x::xs) n =
     x64_code n [num_bc x] ++
     install_x64_code_lists_alt xs (n + LENGTH (x64_code n [num_bc x])))`

val install_x64_code_lists_alt_thm = prove(
  ``!xs ts.
      install_x64_code_lists xs ts =
      ts ++ install_x64_code_lists_alt xs (LENGTH ts)``,
  Induct \\ fs [install_x64_code_lists_def,install_x64_code_lists_alt_def]);

val install_x64_code_lists_x64_code = prove(
  ``!code ts.
      (install_x64_code_lists code (x64_code 0 ts) =
      x64_code 0 (ts ++ MAP num_bc code))``,
  fs [install_x64_code_lists_alt_thm]
  \\ fs [x64_code_APPEND,LENGTH_x64_code]
  \\ REPEAT STRIP_TAC
  \\ Q.SPEC_TAC (`(SUM (MAP x64_length ts))`,`n`)
  \\ Induct_on `code`
  \\ fs [install_x64_code_lists_alt_def,
         x64_code_def,x64_length_def,LENGTH_x64_IGNORE]);

val TWICE_SUM = prove(
  ``!xs. 2 * SUM xs = SUM (MAP (\n. 2 * n) xs)``,
  Induct \\ fs [LEFT_ADD_DISTRIB]);

val SUM_MAP_FILTER = prove(
  ``!xs f P.
      SUM (MAP f (FILTER P xs)) = SUM (MAP (\x. if P x then f x else 0) xs)``,
  Induct \\ fsrw_tac[] [] \\ SRW_TAC [] []);

val TWO_TIMES_next_addr = prove(
  ``2 * next_addr x64_inst_length t1.code = LENGTH (x64_code 0 t1.code)``,
  fs [LENGTH_x64_code,TWICE_SUM] \\ fs [MAP_MAP_o,o_DEF]
  \\ fs [SUM_MAP_FILTER]
  \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC)
  \\ fs [FUN_EQ_THM]
  \\ Cases_on `x` \\ EVAL_TAC
  \\ TRY (Cases_on `b` \\ EVAL_TAC)
  \\ SRW_TAC [] []
  \\ TRY (Cases_on `l` \\ EVAL_TAC)
  \\ SRW_TAC [] []);

val bc_next_11 = prove(
  ``!x y z. bc_next x y /\ bc_next x z ==> (y = z)``,
  REPEAT STRIP_TAC
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_next_bc_eval1 \\ fs []);

val NRC_11 = prove(
  ``(!x y z. R x y /\ R x z ==> (y = z)) ==>
    !x y z. NRC R n x y /\ NRC R n x z ==> (y = z)``,
  Induct_on `n` \\ fs [NRC]
  \\ REPEAT STRIP_TAC \\ fs [] \\ METIS_TAC []);


(* INR terminates case *)

val zHEAP_INR_TERMINATES = let
  val th = SMART_WEAKEN thm_inr
  val th = th |> Q.INST [`s1`|->`bs1`]
  val th = th |> SPEC
    ``COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\
      (basis_repl_step x = (INR (msg,states))) /\
      (lex_until_top_semicolon_alt input = NONE) /\
      (s.input = input) /\ (s.handler = 1) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32))))``
  val th = th |> SPEC
    ``zHEAP_OUTPUT (cs,STRCAT s.output msg) \/ zHEAP_ERROR cs``
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC COMPILER_RUN_INV_repl_step \\ fs []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `T` \\ fs []
    \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
    \\ IMP_RES_TAC COMPILER_RUN_INV_inst_length
    \\ IMP_RES_TAC COMPILER_RUN_INV_handler
    \\ fs [GSYM real_inst_length_thm] \\ fs []
    \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
    \\ IMP_RES_TAC RTC_NRC
    \\ `(bs1 with pc := code_start bs1) = bs1` by ALL_TAC
    THEN1 (fs [bc_state_component_equality])
    \\ fs [] \\ POP_ASSUM (K ALL_TAC)
    \\ Q.LIST_EXISTS_TAC [`n`,`bs2`] \\ fs []
    \\ (GEN_ALL COMPILER_RUN_INV_INR
        |> Q.SPECL [`states`,`out2`,`msg`,`inp1`,`grd2`,`bs2`] |> MP_TAC)
    \\ fs [] \\ REPEAT STRIP_TAC \\ POP_ASSUM (K ALL_TAC)
    \\ `?ibc. (FLOOKUP bs2.refs iptr = SOME (ValueArray [ibc]))` by
          METIS_TAC [COMPILER_RUN_INV_references]
    \\ fs [FLOOKUP_DEF]
    \\ IMP_RES_TAC both_refs_FAPPLY \\ fs []
    \\ fs [BlockInr_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL]
    \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
    \\ REPEAT STRIP_TAC \\ IMP_RES_TAC IN_FDOM_all_refs)
  val th = MP th lemma
  in th end;


(* INR continues case *)

val zHEAP_INR_CONTINUES = let
  val th = SMART_WEAKEN thm_inr
  val th = th |> Q.INST [`s1`|->`bs1`]
  val th = th |> SPEC
    ``COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\
      (basis_repl_step x = (INR (msg,states))) /\
      (lex_until_top_semicolon_alt input = SOME (ts,rest)) /\
      (s.input = input) /\ (s.handler = 1) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32))))``
  val th = th |> SPEC
    ``SEP_EXISTS bs2 grd2 inp2 out2 x.
        zHEAP (cs,Number 0,Number 0,RefPtr (2 * iptr + 2),
          Block 0 [RefPtr 0;
                Block 0 [RefPtr 1; RefPtr (2 * iptr + 2); RefPtr (2 * optr + 2)]],
          both_refs cs.stack_trunk cb bs2 t1_cb t1,[],s with
             <| input := lex_until_semi_state s.input;
                output := STRCAT s.output msg;
                local := <|stop_addr := 0x0w; printing_on := 0x0w|> |>,NONE) *
        ~zS * zPC p *
        cond (COMPILER_RUN_INV bs2 grd2 inp2 out2 /\
              INPUT_TYPE (SOME (ts,states)) inp2 /\
              (bs2.code = bs1.code) /\
              (bs2.inst_length = bs1.inst_length)) \/
        zHEAP_ERROR cs``
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC COMPILER_RUN_INV_repl_step \\ fs []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `T` \\ fs []
    \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
    \\ IMP_RES_TAC COMPILER_RUN_INV_inst_length
    \\ IMP_RES_TAC COMPILER_RUN_INV_handler
    \\ fs [GSYM real_inst_length_thm] \\ fs []
    \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
    \\ IMP_RES_TAC RTC_NRC
    \\ `(bs1 with pc := code_start bs1) = bs1` by ALL_TAC
    THEN1 (fs [bc_state_component_equality])
    \\ fs [] \\ POP_ASSUM (K ALL_TAC)
    \\ Q.LIST_EXISTS_TAC [`n`,`bs2`] \\ fs []
    \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
    \\ SRW_TAC [] [] \\ fs []
    \\ (GEN_ALL COMPILER_RUN_INV_INR
        |> Q.SPECL [`states`,`out2`,`msg`,`inp1`,`grd2`,`bs2`] |> MP_TAC)
    \\ fs [] \\ REPEAT STRIP_TAC \\ fs [LET_DEF]
    \\ POP_ASSUM (MP_TAC o Q.SPEC `ts`)
    \\ REPEAT STRIP_TAC
    \\ fs [lex_until_semi_res_def]
    \\ `?ibc. (FLOOKUP bs2.refs iptr = SOME (ValueArray [ibc]))` by
          METIS_TAC [COMPILER_RUN_INV_references]
    \\ fs [FLOOKUP_DEF]
    \\ IMP_RES_TAC both_refs_FAPPLY \\ fs []
    \\ fs [BlockInr_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL]
    \\ REPEAT STRIP_TAC THEN1 (IMP_RES_TAC IN_FDOM_all_refs)
    \\ fs [SEP_IMP_def,SEP_EXISTS_THM,SEP_DISJ_def]
    \\ REVERSE (REPEAT STRIP_TAC) THEN1 (fs [])
    \\ fs [cond_STAR]
    \\ Q.PAT_ASSUM `COMPILER_RUN_INV bs2' grd2' inp2 out2'` MP_TAC
    \\ Q.PAT_ABBREV_TAC `bs3 = (bs2 with refs := ttt)`
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`bs3`,`grd`,`new_inp`,`out2`]
    \\ fs [] \\ DISJ1_TAC \\ CONJ_TAC
    THEN1 (UNABBREV_ALL_TAC \\ fs [])
    \\ Q.PAT_ASSUM `fff s'` MP_TAC
    \\ fs [AC STAR_COMM STAR_ASSOC]
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(p = b) ==> (p ==> b)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) \\ fs []
    \\ REVERSE (REPEAT STRIP_TAC)
    THEN1 (fs [fetch "-" "zheap_state_component_equality"])
    \\ UNABBREV_ALL_TAC
    \\ fs [both_refs_FUPDATE]
    \\ fs [BlockInr_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL,BlockSome_def,
           bc_adjust_BlockList_BlockSym])
  val th = MP th lemma
  in th end;


(* INL will-diverge case *)

val zHEAP_INL_DIVERGES = let
  val th = SMART_WEAKEN thm_inl_div
  val th = th |> Q.INST [`s1`|->`bs1`,`t1_cb`|->`cs.code_heap_ptr`,`bs`|->`t1`]
  val th = th |> SPEC
    ``COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\
      (basis_repl_step x = INL (code,new_states)) /\
      code_executes_ok (install_bc_lists code t1) /\
      (bc_eval (install_bc_lists code t1) = NONE) /\
      (t1.inst_length = x64_inst_length) /\ (t1.handler = 0) /\
      (t1.stack = []) /\ EVEN (w2n cs.code_heap_ptr) /\
      (s.code = x64_code 0 t1.code) /\
      (s.handler = 1) /\ (s.code_mode = SOME T) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32))))``
  val th = th |> SPEC
    ``zHEAP_WILL_DIVERGE s.output cs cs.code_heap_ptr \/ zHEAP_ERROR cs``
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC COMPILER_RUN_INV_repl_step \\ fs []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `T` \\ fs []
    \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
    \\ IMP_RES_TAC COMPILER_RUN_INV_inst_length
    \\ IMP_RES_TAC COMPILER_RUN_INV_handler
    \\ fs [GSYM real_inst_length_thm] \\ fs []
    \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
    \\ IMP_RES_TAC RTC_NRC
    \\ `(bs1 with pc := code_start bs1) = bs1` by ALL_TAC
    THEN1 (fs [bc_state_component_equality])
    \\ fs [] \\ POP_ASSUM (K ALL_TAC)
    \\ (GEN_ALL COMPILER_RUN_INV_INL
          |> Q.SPECL [`new_states`,`out2`,`inp1`,`grd2`,`code`,`bs2`] |> MP_TAC)
    \\ fs [] \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`code`,`n`,
          `bc_adjust (cb,cs.stack_trunk - 8w,T) s_bc_val`,`bs2`,`[]`]
    \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
    \\ REPEAT STRIP_TAC
    THEN1
     (fs [FLOOKUP_DEF]
      \\ IMP_RES_TAC both_refs_FAPPLY \\ fs []
      \\ fs [BlockInl_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL,
           bc_adjust_BlockList_BlockNum3])
    THEN1 (IMP_RES_TAC IN_FDOM_all_refs)
    \\ fs [SEP_IMP_def,SEP_DISJ_def]
    \\ REPEAT STRIP_TAC \\ fs [] \\ DISJ1_TAC
    \\ fs [zHEAP_WILL_DIVERGE_def,SEP_CLAUSES,SEP_EXISTS_THM,
           zBC_HEAP_def,LET_DEF,ref_addr_def]
    \\ fs [both_refs_def]
    \\ Q.EXISTS_TAC `all_refs cb T cs.stack_trunk bs2.refs bs2.globals`
    \\ Q.EXISTS_TAC `s with
           <|output := s.output; handler := 1; code_mode := SOME T;
             code := install_x64_code_lists code s.code;
             code_start := s.code;
             local := <|stop_addr := p + 0x337w; printing_on := 0x1w|> |>`
    \\ Q.EXISTS_TAC `Block pair_tag [Block 0 [RefPtr 0; Block 0 [RefPtr
                      1; RefPtr (2 * iptr + 2); RefPtr (2 * optr + 2)]];
                      bc_adjust (cb,cs.stack_trunk +
                      0xFFFFFFFFFFFFFFF8w,T) s_bc_val]`
    \\ Q.EXISTS_TAC `install_bc_lists code t1` \\ fs []
    \\ Q.EXISTS_TAC `Number 0` \\ fs []
    \\ Q.EXISTS_TAC `Number 0` \\ fs []
    \\ SIMP_TAC (std_ss++sep_cond_ss) [cond_STAR]
    \\ `bc_diverges (install_bc_lists code t1)` by
     (fs [bc_diverges_def]
      \\ IMP_RES_TAC repl_funProofTheory.bc_eval_NONE_NRC \\ METIS_TAC [])
    \\ fs [] \\ STRIP_TAC THEN1
     (fs [install_bc_lists_def]
      \\ fs [initCompEnvTheory.install_code_def]
      \\ fs [install_x64_code_lists_x64_code]
      \\ REPEAT STRIP_TAC \\ IMP_RES_TAC IN_FDOM_all_refs)
    \\ fs [install_bc_lists_def]
    \\ fs [initCompEnvTheory.install_code_def,GSYM both_refs_def]
    \\ FULL_SIMP_TAC std_ss [FUNION_ASSOC,both_refs_intro,GSYM all_refs_def,
             GSYM (SIMP_CONV (srw_ss()) [] ``w-8w:word64``),
         TWO_TIMES_next_addr]
    \\ fs [AC STAR_ASSOC STAR_COMM]
    \\ Q.PAT_ASSUM `ff s'` MP_TAC
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(b=c) ==> (b ==> c)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC))
  val th = MP th lemma
  in th end;


(* INL terminates case *)

val zHEAP_INL_TERMINATES = let
  val th = SMART_WEAKEN thm_inl
  val th = th |> Q.INST [`s1`|->`bs1`,`t1_cb`|->`cs.code_heap_ptr`,`bs`|->`t1`]
  val th = th |> SPEC
    ``COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\
      (basis_repl_step x = INL (code,new_states)) /\
      code_executes_ok (install_bc_lists code t1) /\
      (bc_eval (install_bc_lists code t1) = SOME t2) /\
      (lex_until_top_semicolon_alt input = NONE) /\
      (s.input = input) /\ (t2.stack = []) /\
      (t1.inst_length = x64_inst_length) /\ (t1.handler = 0) /\
      (t1.stack = []) /\ EVEN (w2n cs.code_heap_ptr) /\
      (s.code = x64_code 0 t1.code) /\
      (s.handler = 1) /\ (s.code_mode = SOME T) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32))))``
  val th = th |> SPEC
    ``zHEAP_OUTPUT (cs,s.output ++ (t2:bc_state).output) \/ zHEAP_ERROR cs``
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC COMPILER_RUN_INV_repl_step \\ fs []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `T` \\ fs []
    \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
    \\ IMP_RES_TAC COMPILER_RUN_INV_inst_length
    \\ IMP_RES_TAC COMPILER_RUN_INV_handler
    \\ fs [GSYM real_inst_length_thm] \\ fs []
    \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
    \\ IMP_RES_TAC RTC_NRC
    \\ `(bs1 with pc := code_start bs1) = bs1` by ALL_TAC
    THEN1 (fs [bc_state_component_equality])
    \\ fs [] \\ POP_ASSUM (K ALL_TAC)
    \\ (GEN_ALL COMPILER_RUN_INV_INL
          |> Q.SPECL [`new_states`,`out2`,`inp1`,`grd2`,`code`,`bs2`] |> MP_TAC)
    \\ fs [] \\ REPEAT STRIP_TAC
    \\ Q.MATCH_ASSUM_RENAME_TAC `NRC bc_next n2 bs1 bs2`
    \\ fs [RW1 [DISJ_COMM] code_executes_ok_def]
    THEN1
     (FIRST_X_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `SUC n`)
      \\ fs [NRC_SUC_RECURSE_LEFT] \\ fs []
      \\ IMP_RES_TAC (MATCH_MP NRC_11 bc_next_11)
      \\ fs [] \\ METIS_TAC [])
    \\ Q.LIST_EXISTS_TAC [`b`,`code`] \\ fs []
    \\ Q.LIST_EXISTS_TAC [`n2`,`n`] \\ fs []
    \\ Q.EXISTS_TAC `bc_adjust (cb,cs.stack_trunk - 8w,T) s_bc_val`
    \\ Q.EXISTS_TAC `s.output`
    \\ Q.EXISTS_TAC `install_bc_lists code t1`
    \\ Q.EXISTS_TAC `bs2`
    \\ Q.EXISTS_TAC `t2`
    \\ fs [SEP_IMP_REFL]
    \\ Q.EXISTS_TAC `cb`
    \\ Q.EXISTS_TAC `bs2`
    \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
    \\ `?ibc. (FLOOKUP bs2.refs iptr = SOME (ValueArray [ibc]))` by
          METIS_TAC [COMPILER_RUN_INV_references]
    \\ fs [FLOOKUP_DEF]
    \\ IMP_RES_TAC both_refs_FAPPLY \\ fs []
    \\ fs [BlockInr_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL]
    \\ fs [install_bc_lists_def,initCompEnvTheory.install_code_def]
    \\ fs [TWO_TIMES_next_addr]
    \\ fs [both_refs_def,install_x64_code_lists_x64_code]
    \\ `s2 = t2` by ALL_TAC THEN1
     (`!s3. ~bc_next s2 s3` by fs [bc_next_cases]
      \\ IMP_RES_TAC bytecodeEvalTheory.RTC_bc_next_bc_eval \\ fs [])
    \\ fs [] \\ REVERSE (REPEAT STRIP_TAC)
    \\ IMP_RES_TAC IN_FDOM_all_refs
    \\ EVAL_TAC
    \\ fs [bc_adjust_BlockList_BlockNum3])
  val th = MP th lemma
  in th end;


(* INL continues case *)

val zHEAP_INL_CONTINUES = let
  val th = SMART_WEAKEN thm_inl
  val th = th |> Q.INST [`s1`|->`bs1`,`t1_cb`|->`cs.code_heap_ptr`,`bs`|->`t1`]
  val th = th |> SPEC
    ``COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\
      (basis_repl_step x = INL (code,new_states)) /\
      code_executes_ok (install_bc_lists code t1) /\
      (bc_eval (install_bc_lists code t1) = SOME t2) /\
      (bc_fetch t2 = SOME (Stop b)) /\
      (lex_until_top_semicolon_alt input = SOME (ts,rest)) /\
      (s.input = input) /\ (t2.stack = []) /\ (t2.handler = 0) /\
      (t1.inst_length = x64_inst_length) /\ (t1.handler = 0) /\
      (t1.stack = []) /\ EVEN (w2n cs.code_heap_ptr) /\
      (s.code = x64_code 0 t1.code) /\
      (s.handler = 1) /\ (s.code_mode = SOME T) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32))))``
  val th = th |> SPEC
    ``SEP_EXISTS bs2 grd2 inp2 out2 x.
        zHEAP (cs,Number 0,Number 0,RefPtr (2 * iptr + 2),
          Block 0 [RefPtr 0;
                Block 0 [RefPtr 1; RefPtr (2 * iptr + 2); RefPtr (2 * optr + 2)]],
          both_refs cs.stack_trunk cb bs2 cs.code_heap_ptr t2,[],s with
             <| input := lex_until_semi_state s.input;
                output := STRCAT s.output t2.output;
                code := x64_code 0 (install_bc_lists code t1).code;
                code_start := x64_code 0 t1.code;
                local := <|stop_addr := 0x0w; printing_on := 0x0w|> |>,NONE) *
        ~zS * zPC p *
        cond (COMPILER_RUN_INV bs2 grd2 inp2 out2 /\
              INPUT_TYPE (SOME (ts,b,new_states)) inp2 /\
              (bs2.code = bs1.code) /\
              (bs2.inst_length = bs1.inst_length)) \/
        zHEAP_ERROR cs``
  val goal = th |> concl |> dest_imp |> fst
(*
  gg goal
*)
  val lemma = prove(goal,
    REPEAT STRIP_TAC \\ fs []
    \\ MP_TAC COMPILER_RUN_INV_repl_step \\ fs []
    \\ REPEAT STRIP_TAC
    \\ Q.EXISTS_TAC `T` \\ fs []
    \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
    \\ IMP_RES_TAC COMPILER_RUN_INV_inst_length
    \\ IMP_RES_TAC COMPILER_RUN_INV_handler
    \\ fs [GSYM real_inst_length_thm] \\ fs []
    \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
    \\ IMP_RES_TAC RTC_NRC
    \\ `(bs1 with pc := code_start bs1) = bs1` by ALL_TAC
    THEN1 (fs [bc_state_component_equality])
    \\ fs [] \\ POP_ASSUM (K ALL_TAC)
    \\ (GEN_ALL COMPILER_RUN_INV_INL
          |> Q.SPECL [`new_states`,`out2`,`inp1`,`grd2`,`code`,`bs2`] |> MP_TAC)
    \\ fs [] \\ REPEAT STRIP_TAC
    \\ Q.MATCH_ASSUM_RENAME_TAC `NRC bc_next n2 bs1 bs2`
    \\ fs [RW1 [DISJ_COMM] code_executes_ok_def]
    THEN1
     (FIRST_X_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `SUC n`)
      \\ fs [NRC_SUC_RECURSE_LEFT] \\ fs []
      \\ IMP_RES_TAC (MATCH_MP NRC_11 bc_next_11)
      \\ fs [] \\ METIS_TAC [])
    \\ Q.MATCH_ASSUM_RENAME_TAC `bc_fetch s2 = SOME (Stop b1)`
    \\ Q.LIST_EXISTS_TAC [`b1`,`code`] \\ fs []
    \\ Q.LIST_EXISTS_TAC [`n2`,`n`] \\ fs []
    \\ Q.EXISTS_TAC `bc_adjust (cb,cs.stack_trunk - 8w,T) s_bc_val`
    \\ Q.EXISTS_TAC `s.output`
    \\ Q.EXISTS_TAC `install_bc_lists code t1`
    \\ Q.EXISTS_TAC `bs2`
    \\ Q.EXISTS_TAC `t2`
    \\ fs [SEP_IMP_REFL]
    \\ Q.EXISTS_TAC `cb`
    \\ Q.EXISTS_TAC `bs2`
    \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
    \\ `?ibc. (FLOOKUP bs2.refs iptr = SOME (ValueArray [ibc]))` by
          METIS_TAC [COMPILER_RUN_INV_references]
    \\ fs [FLOOKUP_DEF]
    \\ IMP_RES_TAC both_refs_FAPPLY \\ fs []
    \\ fs [CONJ_ASSOC] \\ STRIP_TAC
    THEN1
     (fs [BlockInr_def,BlockPair_def,bc_adjust_def,
             bc_adjust_BlockList_Chr,SEP_IMP_REFL]
      \\ fs [install_bc_lists_def,initCompEnvTheory.install_code_def]
      \\ fs [TWO_TIMES_next_addr]
      \\ fs [both_refs_def,install_x64_code_lists_x64_code]
      \\ `s2 = t2` by ALL_TAC THEN1
       (`!s3. ~bc_next s2 s3` by fs [bc_next_cases]
        \\ IMP_RES_TAC bytecodeEvalTheory.RTC_bc_next_bc_eval \\ fs [])
      \\ fs [] \\ REVERSE (REPEAT STRIP_TAC)
      \\ IMP_RES_TAC IN_FDOM_all_refs
      \\ EVAL_TAC
      \\ fs [bc_adjust_BlockList_BlockNum3])
    \\ `s2 = t2` by ALL_TAC THEN1
       (`!s3. ~bc_next s2 s3` by fs [bc_next_cases]
        \\ IMP_RES_TAC bytecodeEvalTheory.RTC_bc_next_bc_eval \\ fs [])
    \\ fs [SEP_IMP_def,SEP_EXISTS_THM,SEP_DISJ_def]
    \\ REVERSE (REPEAT STRIP_TAC) THEN1 (fs [])
    \\ fs [cond_STAR]
    \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`ts:symbol list`,`b1`])
    \\ fs [LET_DEF] \\ REPEAT STRIP_TAC
    \\ POP_ASSUM MP_TAC
    \\ Q.PAT_ABBREV_TAC `bs3 = (bs2 with refs := ttt)`
    \\ REPEAT STRIP_TAC
    \\ Q.LIST_EXISTS_TAC [`bs3`,`grd`,`new_inp`,`out2`]
    \\ fs [] \\ DISJ1_TAC \\ CONJ_TAC
    THEN1 (UNABBREV_ALL_TAC \\ fs [])
    \\ Q.PAT_ASSUM `fff s'` MP_TAC
    \\ fs [AC STAR_COMM STAR_ASSOC]
    \\ MATCH_MP_TAC (METIS_PROVE [] ``(p = b) ==> (p ==> b)``)
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) \\ fs []
    \\ REVERSE (REPEAT STRIP_TAC)
    THEN1 (fs [fetch "-" "zheap_state_component_equality",
               install_x64_code_lists_x64_code,install_bc_lists_def,
               initCompEnvTheory.install_code_def])
    \\ UNABBREV_ALL_TAC
    \\ fs [both_refs_FUPDATE]
    \\ REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) \\ fs []
    \\ fs [BlockInr_def,BlockPair_def,bc_adjust_def,
           bc_adjust_BlockList_Chr,SEP_IMP_REFL,BlockSome_def,
           bc_adjust_BlockList_BlockSym]
    \\ fs [lex_until_semi_res_def]
    \\ Cases_on `b1` \\ EVAL_TAC)
  val th = MP th lemma
  in th end;


(* basis_main_loop implemented *)

val SPEC_COMPOSE_SIMPLE = SPEC_COMPOSE
  |> Q.SPECL [`x`,`p`,`c`,`m`,`c`,`q`]
  |> RW [UNION_IDEMPOT,GSYM AND_IMP_INTRO];

val SPEC_REFL_LEMMA = prove(
  ``SPEC m (p \/ e) c (e \/ q) <=> SPEC m p c (e \/ q)``,
  fs [SPEC_PRE_DISJ] \\ REPEAT STRIP_TAC
  \\ EQ_TAC \\ REPEAT STRIP_TAC \\ fs []
  \\ MATCH_MP_TAC (MP_CANON SPEC_WEAKEN)
  \\ Q.EXISTS_TAC `e` \\ fs [SPEC_REFL,SEP_IMP_def,SEP_DISJ_def]);

val env_rs_ignore_pc = prove(
  ``!x1 x2 x3 x4.
      env_rs x1 x2 x3 x4 bs ==>
      env_rs x1 x2 x3 x4 (bs with pc := x)``,
  REPEAT STRIP_TAC
  \\ MATCH_MP_TAC compilerProofTheory.env_rs_with_bs_irr
  \\ fs [] \\ Q.EXISTS_TAC `bs` \\ fs []);

val env_rs_ignore_output = prove(
  ``!x1 x2 x3 x4.
      env_rs x1 x2 x3 x4 (bs with output := x) <=>
      env_rs x1 x2 x3 x4 bs``,
  REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ MATCH_MP_TAC compilerProofTheory.env_rs_with_bs_irr
  THEN1 (fs [] \\ Q.EXISTS_TAC `bs with output := x` \\ fs [])
  \\ fs [] \\ Q.EXISTS_TAC `bs` \\ fs []);

val COMPILER_RUN_INV_ignore_pc = prove(
  ``COMPILER_RUN_INV bs2 grd2 inp2 out2 ==>
    COMPILER_RUN_INV (bs2 with pc := n) grd2 inp2 out2``,
  fs [COMPILER_RUN_INV_def] \\ REPEAT STRIP_TAC
  \\ fs [bc_state_component_equality]
  \\ MATCH_MP_TAC env_rs_ignore_pc \\ fs []);

val repl_bc_state_output_empty = prove(
  ``repl_bc_state.output = ""``,
  fs [bootstrapProofTheory.repl_bc_state_def,
      initCompEnvTheory.install_code_def]);

fun CC th = th |> UNDISCH_ALL
               |> CONV_RULE (BINOP1_CONV (SIMP_CONV (srw_ss()) []));

val diverges_def = Define `
  (diverges (Result x y) = diverges y) /\
  (diverges Terminate = F) /\
  (diverges Diverge = T)`

val repl_output_def = Define `
  (repl_output (Result x y) = x ++ repl_output y) /\
  (repl_output Terminates = "") /\
  (repl_output Diverges = "")`

val zHEAP_basis_main_loop = prove(
  ``!x bs input res x2 x3 bs1 s t1 grd1 inp1 out1 t1.
      COMPILER_RUN_INV bs1 grd1 inp1 out1 /\
      INPUT_TYPE x inp1 /\
      (bs1.pc = code_start bs1) /\ (bs = t1) /\
      (basis_main_loop x bs input = (res,T)) /\ (s.input = input) /\
      (t1.inst_length = x64_inst_length) /\ (t1.handler = 0) /\
      (t1.stack = []) /\ EVEN (w2n cs.code_heap_ptr) /\
      (s.code = x64_code 0 t1.code) /\
      (s.handler = 1) /\ (s.code_mode = SOME T) /\
      (s.local.printing_on = 0w) /\ EVEN (w2n (cb:word64)) /\
      (cb + n2w (2 * code_start bs1):word64 =
       p + n2w (24 + SIGN_EXTEND 32 64 (w2n (repl_step_imm32:word32)))) ==>
      ^(zHEAP_INL_CONTINUES |> UNDISCH_ALL |> concl |> rator)
        (zHEAP_ERROR cs \/
         if diverges res then
           zHEAP_WILL_DIVERGE (s.output ++ repl_output res) cs cs.code_heap_ptr
         else
           zHEAP_OUTPUT (cs,s.output ++ repl_output res))``,
  HO_MATCH_MP_TAC repl_funTheory.basis_main_loop_ind \\ REPEAT STRIP_TAC
  \\ Q.PAT_ASSUM `basis_main_loop x bs input = (res,T)` MP_TAC
  \\ ONCE_REWRITE_TAC [repl_funTheory.basis_main_loop_def]
  \\ REVERSE (Cases_on `basis_repl_step x`)
  THEN1 (* INR *)
   (Cases_on `y` \\ fs []
    \\ Cases_on `lex_until_top_semicolon_alt input` \\ fs []
    THEN1 (* terminates *)
     (SRW_TAC [] [] \\ fs [diverges_def,repl_output_def]
      \\ MATCH_MP_TAC
         (MATCH_MP SPEC_WEAKEN (zHEAP_INR_TERMINATES |> CC)
          |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO] |> GEN_ALL)
      \\ Q.EXISTS_TAC `x` \\ fs []
      \\ Q.LIST_EXISTS_TAC [`out1`,`inp1`,`grd1`]
      \\ fs [SEP_IMP_def,SEP_DISJ_def]
      \\ REPEAT STRIP_TAC \\ fs [])
    (* continues *)
    \\ Q.PAT_ASSUM `bs = t1` (fn th => fs [th])
    \\ Cases_on `x'` \\ fs []
    \\ Q.MATCH_ASSUM_RENAME_TAC
          `lex_until_top_semicolon_alt input = SOME (res1,res2)`
    \\ Cases_on `basis_main_loop (SOME (res1,r)) t1 res2`
    \\ fs [LET_DEF]
    \\ SIMP_TAC std_ss [Once EQ_SYM_EQ]
    \\ REPEAT STRIP_TAC \\ fs [diverges_def]
    \\ fs [repl_output_def]
    \\ MATCH_MP_TAC (MATCH_MP SPEC_COMPOSE_SIMPLE (zHEAP_INR_CONTINUES |> CC)
         |> DISCH_ALL |> RW [AND_IMP_INTRO] |> GEN_ALL)
    \\ fs [] \\ Q.EXISTS_TAC `x` \\ fs []
    \\ Q.LIST_EXISTS_TAC [`out1`,`inp1`,`grd1`]
    \\ fs [GSYM SPEC_PRE_EXISTS] \\ REPEAT STRIP_TAC
    \\ SIMP_TAC std_ss [SPEC_REFL_LEMMA]
    \\ SIMP_TAC std_ss [SPEC_MOVE_COND] \\ REPEAT STRIP_TAC
    \\ Q.ABBREV_TAC `s4 = s with
      <|input := lex_until_semi_state input;
        output := STRCAT s.output q;
        local := <|stop_addr := 0x0w; printing_on := 0x0w|> |>`
    \\ `STRCAT s.output q = s4.output` by (UNABBREV_ALL_TAC \\ fs []) \\ fs []
    \\ `(bs1.code = (bs2 with pc := code_start bs2).code) /\
        (bs2.inst_length = bs1.inst_length)` by SRW_TAC [] []
    \\ `both_refs cs.stack_trunk cb bs2 cs.code_heap_ptr t1 =
        both_refs cs.stack_trunk cb (bs2 with pc := code_start bs2)
          cs.code_heap_ptr t1` by fs [both_refs_def]
    \\ FULL_SIMP_TAC std_ss []
    \\ FIRST_X_ASSUM MATCH_MP_TAC
    \\ UNABBREV_ALL_TAC \\ fs []
    \\ fs [lex_until_semi_state_def,code_start_def]
    \\ Q.LIST_EXISTS_TAC [`grd2`,`inp2`,`out2`] \\ fs []
    \\ MATCH_MP_TAC COMPILER_RUN_INV_ignore_pc \\ fs [])
  (* INL *)
  \\ Q.PAT_ASSUM `bs = t1` (fn th => fs [th])
  \\ Cases_on `x'` \\ fs [LET_DEF]
  \\ Cases_on `bc_eval (install_bc_lists q t1)` \\ fs []
  THEN1 (* diverges *)
   (SRW_TAC [] [] \\ fs [diverges_def,repl_output_def]
    \\ MATCH_MP_TAC
       (MATCH_MP SPEC_WEAKEN (zHEAP_INL_DIVERGES |> CC)
        |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO] |> GEN_ALL)
    \\ Q.EXISTS_TAC `x` \\ fs []
    \\ Q.LIST_EXISTS_TAC [`out1`,`inp1`,`grd1`]
    \\ fs [SEP_IMP_def,SEP_DISJ_def]
    \\ REPEAT STRIP_TAC \\ fs [])
  \\ Cases_on `lex_until_top_semicolon_alt input` \\ fs []
  THEN1 (* terminates *)
   (SRW_TAC [] [] \\ fs [diverges_def,repl_output_def]
    \\ MATCH_MP_TAC
       (MATCH_MP SPEC_WEAKEN (zHEAP_INL_TERMINATES |> CC)
        |> SPEC_ALL |> DISCH_ALL |> RW [AND_IMP_INTRO] |> GEN_ALL)
    \\ Q.EXISTS_TAC `x` \\ fs []
    \\ Q.LIST_EXISTS_TAC [`out1`,`inp1`,`grd1`]
    \\ fs [SEP_IMP_def,SEP_DISJ_def]
    \\ REPEAT STRIP_TAC \\ fs []
    \\ REVERSE (fs [code_executes_ok_def]) THEN1
     (IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
      \\ IMP_RES_TAC RTC_NRC
      \\ FIRST_X_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `SUC n:num`)
      \\ fs [NRC_SUC_RECURSE_LEFT] \\ fs []
      \\ IMP_RES_TAC (MATCH_MP NRC_11 bc_next_11)
      \\ fs [] \\ METIS_TAC [])
    \\ `!s3. ~bc_next s2 s3` by fs [bc_next_cases]
    \\ IMP_RES_TAC bytecodeEvalTheory.RTC_bc_next_bc_eval
    \\ fs [] \\ rfs [])
  (* continues *)
  \\ Cases_on `x''` \\ fs []
  \\ Q.MATCH_ASSUM_RENAME_TAC
        `lex_until_top_semicolon_alt input = SOME (res1,res2)`
  \\ Cases_on `basis_main_loop (SOME (res1,bc_fetch x' = SOME (Stop T),r)) x'
      res2` \\ fs [LET_DEF]
  \\ SIMP_TAC std_ss [Once EQ_SYM_EQ]
  \\ REPEAT STRIP_TAC \\ fs [diverges_def]
  \\ fs [repl_output_def]
  \\ MATCH_MP_TAC (MATCH_MP SPEC_COMPOSE_SIMPLE (zHEAP_INL_CONTINUES |> CC)
       |> DISCH_ALL |> RW [AND_IMP_INTRO] |> GEN_ALL)
  \\ fs [] \\ Q.EXISTS_TAC `x` \\ fs []
  \\ Q.LIST_EXISTS_TAC [`out1`,`inp1`,`grd1`,`bc_fetch x' = SOME (Stop T)`]
  \\ fs [GSYM SPEC_PRE_EXISTS]
  \\ `(bc_fetch x' = SOME (Stop (bc_fetch x' = SOME (Stop T)))) /\
      (x'.stack = []) /\ (x'.handler = 0)` by ALL_TAC THEN1
   (REVERSE (fs [code_executes_ok_def]) THEN1
     (IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
      \\ IMP_RES_TAC RTC_NRC
      \\ FIRST_X_ASSUM (STRIP_ASSUME_TAC o Q.SPEC `SUC n:num`)
      \\ fs [NRC_SUC_RECURSE_LEFT] \\ fs []
      \\ IMP_RES_TAC (MATCH_MP NRC_11 bc_next_11)
      \\ fs [] \\ METIS_TAC [])
    \\ `!s3. ~bc_next s2 s3` by fs [bc_next_cases]
    \\ IMP_RES_TAC bytecodeEvalTheory.RTC_bc_next_bc_eval
    \\ fs [] \\ rfs [])
  \\ fs [] \\ REPEAT STRIP_TAC
  \\ SIMP_TAC std_ss [SPEC_REFL_LEMMA]
  \\ SIMP_TAC std_ss [SPEC_MOVE_COND] \\ REPEAT STRIP_TAC
  \\ Q.ABBREV_TAC `s4 = s with
      <|input := lex_until_semi_state input;
        output := STRCAT s.output x'.output;
        code := x64_code 0 (install_bc_lists q t1).code;
        code_start := x64_code 0 t1.code;
        local := <|stop_addr := 0x0w; printing_on := 0x0w|> |>`
  \\ `STRCAT s.output x'.output = s4.output` by (UNABBREV_ALL_TAC \\ fs [])
  \\ fs []
  \\ `(bs1.code = (bs2 with pc := code_start bs2).code) /\
      (bs2.inst_length = bs1.inst_length)` by SRW_TAC [] []
  \\ `both_refs cs.stack_trunk cb bs2 cs.code_heap_ptr x' =
      both_refs cs.stack_trunk cb (bs2 with pc := code_start bs2)
        cs.code_heap_ptr x'` by fs [both_refs_def]
  \\ FULL_SIMP_TAC std_ss []
  \\ FIRST_X_ASSUM MATCH_MP_TAC
  \\ UNABBREV_ALL_TAC \\ fs []
  \\ fs [lex_until_semi_state_def,code_start_def]
  \\ Q.LIST_EXISTS_TAC [`grd2`,`inp2`,`out2`] \\ fs []
  \\ REPEAT STRIP_TAC
  THEN1 (MATCH_MP_TAC COMPILER_RUN_INV_ignore_pc \\ fs [])
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
  \\ IMP_RES_TAC RTC_bc_next_preserves \\ fs []
  \\ fs [install_bc_lists_def,initCompEnvTheory.install_code_def]);

val code_start_with_pc = prove(
  ``code_start (bs1 with pc := w) = code_start bs1``,
  fs [code_start_def]);

val both_refs_with_pc = prove(
  ``both_refs t cb (bs1 with pc := w) x s =
    both_refs t cb bs1 x s``,
  fs [both_refs_def]);

val zHEAP_basis_repl_fun =
  zHEAP_basis_main_loop
  |> SIMP_RULE std_ss []
  |> SPEC_ALL
  |> DISCH ``s.output = ""``
  |> SIMP_RULE std_ss [AND_IMP_INTRO,APPEND]
  |> Q.INST [`x`|->`NONE`,`t1`|->`strip_labels initial_bc_state`]
  |> RW [GSYM repl_funTheory.basis_repl_fun_def,
         EVAL ``(strip_labels initial_bc_state).stack``,
         EVAL ``(strip_labels initial_bc_state).handler``,
         EVAL ``(strip_labels initial_bc_state).inst_length``,
         real_inst_length_thm]
  |> Q.INST [`bs1`|->`bs1 with pc := code_start bs1`]
  |> SIMP_RULE (srw_ss()) [code_start_with_pc]
  |> DISCH ``COMPILER_RUN_INV bs1 grd1 inp1 out1``
  |> SIMP_RULE std_ss [COMPILER_RUN_INV_ignore_pc,both_refs_with_pc]
  |> RW [AND_IMP_INTRO]






val bootstrap_bc_state_code = store_thm("bootstrap_bc_state_code",
  ``bootstrap_bc_state.code =
      initial_bc_state.code ++
      REVERSE (SND (THE prim_env)) ++
      REVERSE (SND (SND compile_repl_module))``,
  STRIP_ASSUME_TAC bootstrap_bc_state_def
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
  \\ IMP_RES_TAC bytecodeLabelsTheory.bc_next_strip_labels_RTC
  \\ imp_res_tac RTC_bc_next_preserves
  \\ fs [initCompEnvTheory.install_code_def,REVERSE_APPEND]);

val bootstrap_code_labelled_def = Define `
  bootstrap_code_labelled =
    (bootstrap_bc_state.code ++ REVERSE compile_call_repl_step)`;

val bootstrap_code_def = Define `
  bootstrap_code = code_labels real_inst_length bootstrap_code_labelled`;

val bc_eval_IMP_strip_labels = prove(
  ``(bc_eval s = SOME t) /\ (bc_fetch t = SOME (Stop T)) ==>
    length_ok s.inst_length ==>
    (bc_eval (strip_labels s) = SOME (strip_labels t)) /\
    (bc_fetch (strip_labels t) = SOME (Stop T)) /\
    (t.inst_length = s.inst_length) /\
    ((strip_labels t).code = (strip_labels s).code)``,
  STRIP_TAC \\ STRIP_TAC
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
  \\ IMP_RES_TAC bytecodeLabelsTheory.bc_next_strip_labels_RTC
  \\ imp_res_tac RTC_bc_next_preserves
  \\ POP_ASSUM (ASSUME_TAC o GSYM) \\ fs []
  \\ IMP_RES_TAC bytecodeLabelsTheory.bc_fetch_strip_labels \\ fs []
  \\ MATCH_MP_TAC (MP_CANON bytecodeEvalTheory.RTC_bc_next_bc_eval) \\ fs []
  \\ ASM_SIMP_TAC (srw_ss()) [bc_next_cases]);

val RTC_bc_next_append_code = prove(
  ``!s t.
      bc_next^* s t ==>
      bc_next^* (s with code := s.code ++ x) (t with code := s.code ++ x)``,
  HO_MATCH_MP_TAC RTC_INDUCT \\ REPEAT STRIP_TAC \\ fs []
  \\ MATCH_MP_TAC (CONJUNCT2 (relationTheory.RTC_RULES |> SPEC_ALL))
  \\ Q.EXISTS_TAC `(s' with code := s'.code ++ x)`
  \\ imp_res_tac bytecodeExtraTheory.bc_next_preserves_code
  \\ IMP_RES_TAC bytecodeExtraTheory.bc_next_append_code \\ fs []);

val bc_fetch_auc_APPEND = prove(
  ``!xs x y t.
      (bc_fetch_aux xs x y = SOME t) ==>
      (bc_fetch_aux (xs++ys) x y = SOME t)``,
  Induct \\ fs [bc_fetch_aux_def] \\ SRW_TAC [] []);

val bc_eval_Stop_T_IMP = prove(
  ``(bc_eval s = SOME t) /\ (bc_fetch t = SOME (Stop T)) ==>
    (bc_eval (s with code := s.code ++ x) = SOME (t with code := s.code ++ x)) /\
    (bc_fetch (t with code := s.code ++ x) = SOME (Stop T))``,
  STRIP_TAC
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next
  \\ IMP_RES_TAC RTC_bc_next_append_code
  \\ POP_ASSUM (MP_TAC o Q.SPEC `x`) \\ fs [] \\ STRIP_TAC
  \\ `(bc_fetch (t with code := s.code ++ x) = SOME (Stop T))` by
   (fs [bc_fetch_def]
    \\ MATCH_MP_TAC bc_fetch_auc_APPEND
    \\ imp_res_tac bytecodeExtraTheory.RTC_bc_next_preserves \\ fs []) \\ fs []
  \\ MATCH_MP_TAC (MP_CANON bytecodeEvalTheory.RTC_bc_next_bc_eval) \\ fs []
  \\ ASM_SIMP_TAC (srw_ss()) [bc_next_cases]);

val bootstrap_pc_def = Define `
  bootstrap_pc =
    next_addr initial_bc_state.inst_length initial_bc_state.code`;

local
  val lemma = prove(
    ``initial_bc_state with
        <|code := bootstrap_code_labelled; pc := n; output := ""|> =
      initial_bc_state with
        <|code := bootstrap_code_labelled; pc := n|>``,
    fs [initCompEnvTheory.initial_bc_state_def,
        initCompEnvTheory.empty_bc_state_def]);
  val bootstrap_bc_state_with_labels_lemma = prove(
    ``(bc_eval
        (install_code
           (SND (SND compile_repl_module) ++ SND (THE prim_env))
           initial_bc_state) = SOME bootstrap_bc_state) /\
      (bc_fetch bootstrap_bc_state = SOME (Stop T))``,
    fs [bootstrap_bc_state_def])
    |> SIMP_RULE (srw_ss()) [initCompEnvTheory.install_code_def,REVERSE_APPEND]
    |> RW [GSYM bootstrap_bc_state_code]
    |> RW [GSYM bootstrap_pc_def]
    |> MATCH_MP bc_eval_Stop_T_IMP
    |> SIMP_RULE (srw_ss()) [EVAL ``empty_bc_state.inst_length``]
    |> Q.INST [`x`|->`REVERSE compile_call_repl_step`]
    |> RW [GSYM bootstrap_code_def,GSYM bootstrap_code_labelled_def,lemma]
  val bootstrap_bc_state_strip_labels =
    bootstrap_bc_state_with_labels_lemma
    |> MATCH_MP bc_eval_IMP_strip_labels
    |> RW [bytecodeLabelsTheory.strip_labels_def]
    |> CONV_RULE (BINOP1_CONV (RAND_CONV EVAL))
    |> RW [GSYM real_inst_length_thm,length_ok_x64_inst_length]
    |> SIMP_RULE (srw_ss()) [EVAL ``empty_bc_state.inst_length``]
    |> RW [GSYM bootstrap_code_def,GSYM bootstrap_code_labelled_def]
  val lemmas = CONJUNCTS bootstrap_bc_state_strip_labels
in
  val bootstrap_bc_state_inst_length = el 3 lemmas
  val bootstrap_bc_state_with_labels =
    bootstrap_bc_state_with_labels_lemma
  val bootstrap_bc_state_strip_labels =
    CONJ (el 1 lemmas) (el 2 lemmas) |> RW [el 3 lemmas,el 4 lemmas,
      GSYM bootstrap_code_def,EVAL ``initial_bc_state.inst_length``]
end

val _ = temp_overload_on("init1",COMPILER_RUN_INV_init |> concl |> rator |> rand);
val _ = temp_overload_on("init2",COMPILER_RUN_INV_init |> concl |> rand);

val COMPILER_RUN_INV_init_alt = prove(
  ``COMPILER_RUN_INV
     ((bootstrap_bc_state with
        code := bootstrap_code_labelled) with output := "")
     bootstrap_grd init1 init2``,
  MP_TAC (COMPILER_RUN_INV_init
    |> RW [bootstrapProofTheory.repl_bc_state_def,
           initCompEnvTheory.install_code_def,
           GSYM bootstrap_code_labelled_def])
  \\ fs [COMPILER_RUN_INV_def]
  \\ ONCE_REWRITE_TAC [EQ_SYM_EQ]
  \\ REPEAT STRIP_TAC \\ fs []
  \\ fs [bc_state_component_equality]
  \\ MATCH_MP_TAC compilerProofTheory.env_rs_with_bs_irr
  \\ fs [] \\ Q.EXISTS_TAC `(bootstrap_bc_state with
         <|code := bootstrap_code_labelled;
           pc := next_addr bootstrap_bc_state.inst_length
                 bootstrap_bc_state.code; output := ""|>)` \\ fs []);

val code_start_rwt = prove(
  ``code_start (bootstrap_bc_state with
       <|code := bootstrap_code_labelled; output := ""|>) =
    code_start empty_bc_state``,
  fs [code_start_def,bootstrap_bc_state_inst_length]
  \\ NTAC 4 (AP_TERM_TAC ORELSE AP_THM_TAC) \\ EVAL_TAC);

val init_bc_code_stripped_def = Define `
  init_bc_code_stripped =
    code_labels real_inst_length initial_bc_state.code`

val loop_thm =
  zHEAP_basis_repl_fun
  |> Q.INST [`bs1`|->`((bootstrap_bc_state with
         code := bootstrap_code_labelled) with output := "")`,
       `grd1`|->`bootstrap_grd`,`inp1`|->`init1`,`out1`|->`init2`]
  |> SIMP_RULE (srw_ss()) [COMPILER_RUN_INV_init_alt,code_start_rwt,
       INPUT_TYPE_NONE,both_refs_def]
  |> RW [GSYM both_refs_def,GSYM bootstrap_code_def]
  |> SIMP_RULE (srw_ss()) [bytecodeLabelsTheory.strip_labels_def,both_refs_def]
  |> SIMP_RULE (srw_ss()) [GSYM bytecodeLabelsTheory.strip_labels_def,
       GSYM both_refs_def,EVAL ``initial_bc_state.inst_length``,
       GSYM init_bc_code_stripped_def]

val bootstrap_bc_state_stack_handler = prove(
  ``(bootstrap_bc_state.handler = 0) /\
    (bootstrap_bc_state.stack = [])``,
  ASSUME_TAC COMPILER_RUN_INV_init_alt
  \\ IMP_RES_TAC COMPILER_RUN_INV_empty_stack
  \\ IMP_RES_TAC COMPILER_RUN_INV_handler \\ fs []);

val bc_eval_intro_lemma = prove(
  ``(bc_next^* s1 s2 ==>
    (bc_fetch s2 = SOME (Stop b)) ==> b1) <=>
    ((bc_eval s1 = SOME s2) ==>
    (bc_fetch s2 = SOME (Stop b)) ==> b1)``,
  REPEAT STRIP_TAC \\ Cases_on `b1` \\ fs []
  \\ Cases_on `bc_fetch s2 = SOME (Stop b)` \\ fs []
  \\ REPEAT STRIP_TAC \\ EQ_TAC \\ REPEAT STRIP_TAC
  \\ IMP_RES_TAC bytecodeEvalTheory.bc_eval_SOME_RTC_bc_next \\ fs []
  \\ MATCH_MP_TAC (MP_CANON bytecodeEvalTheory.RTC_bc_next_bc_eval) \\ fs []
  \\ fs [bc_next_cases])

val PUSH_FORALL =
  METIS_PROVE [] ``(!x. P x ==> Q) <=> (?x. P x) ==> Q``

val ref_globals_NIL = prove(
  ``ref_globals (cb,w,b) [] =
        FEMPTY |+ (if b then 0 else 1,
          ValueArray (REPLICATE globals_count (Number 0)))``,
  fs [ref_globals_def]
  \\ REPEAT (AP_THM_TAC ORELSE AP_TERM_TAC)
  \\ fs [ref_globals_list_def,OPT_MAP_def]
  \\ Q.SPEC_TAC (`globals_count`,`n`)
  \\ Induct \\ fs [ref_globals_list_def,rich_listTheory.REPLICATE]);

val FUNION_FEMPTY_FEMPTY = prove(
  ``FUNION (FEMPTY |+ (0,y1)) (FEMPTY |+ (1:num,y2)) =
    FEMPTY |+ (0,y1) |+ (1,y2)``,
  fs [fmap_EXT,FUNION_DEF,FAPPLY_FUPDATE_THM,EXTENSION]
  \\ SRW_TAC [] [AC DISJ_COMM DISJ_ASSOC] \\ fs []);

val zHEAP_bootstrap_bc_state = let
  val th0 =
    set_ref_addr
    |> RW [ref_addr_def]
    |> Q.INST [`refs`|->`FEMPTY`]
    |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]
  val th1 =
    zHEAP_EVAL_UNTIL_STOP
    |> DISCH ``bc_fetch s2 = SOME (Stop b)``
    |> DISCH ``NRC bc_next n s1 s2``
    |> Q.GEN `n` |> SIMP_RULE std_ss [PUSH_FORALL,GSYM RTC_eq_NRC]
    |> RW [bc_eval_intro_lemma]
    |> RW [AND_IMP_INTRO]
    |> Q.INST [`s1`|->`(initial_bc_state with
         <|code := bootstrap_code_labelled; pc := bootstrap_pc|>)`]
    |> RW [bootstrap_bc_state_with_labels]
    |> DISCH_ALL |> Q.GENL [`s2`,`b`]
    |> SIMP_RULE (srw_ss()) [bootstrap_bc_state_with_labels,
         bootstrap_bc_state_inst_length,
         EVAL ``initial_bc_state.handler``,
         EVAL ``initial_bc_state.stack``,
         EVAL ``initial_bc_state.inst_length``,
         real_inst_length_thm,GSYM bootstrap_code_def,
         bootstrap_bc_state_stack_handler,
         both_refs_def,
         EVAL ``initial_bc_state.refs``,
         EVAL ``initial_bc_state.globals``]
    |> Q.INST [`t1_cb`|->`cs.code_heap_ptr`,
               `t1`|->`initial_bc_state`,
               `repl_step_imm32`|->`repl_step_imm32_fst`]
    |> RW [GSYM both_refs_def]
    |> RW [EVAL ``initial_bc_state.refs``,ref_adjust_FEMPTY,
           EVAL ``initial_bc_state.globals``,all_refs_def,
           ref_globals_NIL]
    |> SIMP_RULE std_ss [Once EQ_SYM_EQ]
    |> SIMP_RULE (srw_ss()) [FUNION_DEF]
    |> UNDISCH_ALL
  val SPEC_zHEAP_SWAP = prove(
    ``SPEC m (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) * ~zS * zPC p) c q ==>
      !t p'. ((cs,x1,x2,x3,x4,refs,stack,s,space) = t) /\ (p = p') ==>
             SPEC m (zHEAP t * ~zS * zPC p') c q``,
    fs []);
  val th2 =
    MATCH_MP SPEC_zHEAP_SWAP th1
    |> SIMP_RULE bool_ss [FORALL_PROD]
    |> SPEC_ALL |> RW [PAIR_EQ,FUNION_FEMPTY_FEMPTY]
    |> UNDISCH_ALL
  val th =
    SPEC_COMPOSE_RULE [th0,th2]
    |> DISCH_ALL |> GEN_ALL
    |> SIMP_RULE (srw_ss()) [] |> SPEC_ALL |> UNDISCH_ALL
  in th end

val iptr_index =
  COMPILER_RUN_INV_ptrs
  |> SPEC_ALL |> concl |> rand |> dest_conj |> fst
  |> dest_eq |> fst |> rator |> rand

val optr_index =
  COMPILER_RUN_INV_ptrs
  |> SPEC_ALL |> concl |> rand
  |> dest_conj |> snd |> dest_conj |> snd |> dest_conj |> fst
  |> dest_eq |> fst |> rator |> rand

val zHEAP_IPTR_Number_1 = zHEAP_Num1 |> Q.INST [`k`|->`^iptr_index`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val zHEAP_OPTR_Number_1 = zHEAP_Num1 |> Q.INST [`k`|->`^optr_index`]
  |> SIMP_RULE (srw_ss()) [SEP_CLAUSES]

val rwt_lemmas = prove(
  ``^iptr_index < globals_count /\ ^optr_index < globals_count``,
  fs [globals_count_def]);

val Cons3 =
  zHEAP_BIG_CONS
  |> Q.INST [`n`|->`0`,`l`|->`3`]
  |> DISCH_ALL |> GEN_ALL
  |> SIMP_RULE (srw_ss()) [] |> SPEC_ALL |> UNDISCH

val Cons2 =
  zHEAP_BIG_CONS
  |> Q.INST [`n`|->`0`,`l`|->`2`]
  |> DISCH_ALL |> GEN_ALL
  |> SIMP_RULE (srw_ss()) [] |> SPEC_ALL |> UNDISCH

val both_refs_0 = prove(
  ``both_refs x1 x2 x3 x4 x5 ' 0 =
    ValueArray (ref_globals_list
     (OPT_MAP (bc_adjust (x2,x1 - 8w,T)) x3.globals) globals_count)``,
  fs [both_refs_def,all_refs_def,ref_adjust_def,LET_DEF,
      ref_globals_def,FAPPLY_FUPDATE_THM,FUNION_DEF]);

val EL_ref_globals_list_alt = prove(
  ``!xs n i.
      i < n ==>
      (EL i (ref_globals_list xs n) =
       if LENGTH xs <= i then Number 0 else
         case EL i xs of NONE => Number 0 | SOME x => x)``,
  Induct \\ fs [ref_globals_list_def]
  THEN1 (fs [ref_globals_list_NIL,rich_listTheory.EL_REPLICATE])
  \\ Cases \\ Cases \\ fs [ref_globals_list_def] \\ Cases \\ fs []);

val EL_iptr_index = prove(
  ``(EL ^iptr_index (ref_globals_list
       (OPT_MAP (bc_adjust (cb,w,T)) bootstrap_bc_state.globals)
         globals_count) = RefPtr (2 * iptr + 2)) /\
    (EL ^optr_index (ref_globals_list
       (OPT_MAP (bc_adjust (cb,w,T)) bootstrap_bc_state.globals)
         globals_count) = RefPtr (2 * optr + 2))``,
  STRIP_ASSUME_TAC (MATCH_MP COMPILER_RUN_INV_ptrs COMPILER_RUN_INV_init_alt)
  \\ fs []
  \\ `^iptr_index < LENGTH bootstrap_bc_state.globals /\
      ^optr_index < LENGTH bootstrap_bc_state.globals` by DECIDE_TAC
  \\ `^iptr_index < globals_count /\
      ^optr_index < globals_count` by fs [globals_count_def]
  \\ IMP_RES_TAC EL_ref_globals_list
  \\ fs [bc_adjust_def,LEFT_ADD_DISTRIB]);

val x64_code_rev_def = Define `
  (x64_code_rev i [] res = res) /\
  (x64_code_rev i (b::bs) res =
     let c = x64 i b in x64_code_rev (i + LENGTH c) bs (REVERSE c ++ res))`;

val x64_code_rev_eval =
  ([],``!b. x64_code_rev i (b::bs) res =
          let c = x64 i b in
            x64_code_rev (i + LENGTH c) bs (REVERSE c ++ res)``)
  |> (Cases \\ TRY (Cases_on `b'`) \\ TRY (Cases_on `l`)) |> fst
  |> map (SIMP_RULE std_ss [LET_DEF] o REWRITE_CONV [x64_code_rev_def] o snd)
  |> (fn thms => LIST_CONJ (CONJUNCT1 x64_code_rev_def::thms))
  |> SIMP_RULE std_ss [x64_def,LET_DEF,APPEND,LENGTH,small_offset_def,REVERSE_DEF,
       small_offset6_def,small_offset12_def,small_offset16_def,IMM32_def,LENGTH_IF,
       globals_count_def]
  |> REWRITE_RULE [APPEND_IF,APPEND,IF_AND]
  |> SIMP_RULE std_ss []
  |> REWRITE_RULE [GSYM IF_AND]

val _ = save_thm("x64_code_rev_eval",x64_code_rev_eval);

val x64_code_rev_thm = prove(
  ``!bs i res. x64_code_rev i bs res = REVERSE (x64_code i bs) ++ res``,
  Induct THEN1 (SRW_TAC [] [x64_code_def,x64_code_rev_def])
  \\ SRW_TAC [] [x64_code_ALT,x64_code_rev_def] \\ SRW_TAC [] []);

val x64_code_rev_thm = store_thm("x64_code_rev_thm",
  ``!bs i. x64_code i bs = REVERSE (x64_code_rev i bs [])``,
  SRW_TAC [] [x64_code_rev_thm]);

val x64_code_INTRO = prove(
  ``(x64_code_rev n xs [] = ys) = (x64_code n xs = REVERSE ys)``,
  SRW_TAC [] [x64_code_rev_thm]);

val x64_code_init_bc_code_stripped =
  ``x64_code_rev 0 init_bc_code_stripped []``
  |> (REWRITE_CONV [EVAL ``init_bc_code_stripped``] THENC EVAL)
  |> RW [x64_code_INTRO] |> CONV_RULE (RAND_CONV EVAL)

fun gen tm = let
  val th = append_imm_code |> SPEC tm |> SPEC_ALL
      |> SIMP_RULE std_ss [LENGTH,ADD1]
      |> PURE_REWRITE_RULE [append_imm_code_def,word_arith_lemma1]
      |> SIMP_RULE std_ss []
  in th end;

val install_init_bc_code_stripped =
  append_imm_code
  |> SPEC (x64_code_init_bc_code_stripped |> concl |> rand)
  |> SPEC_ALL
  |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss()) []))
  |> CONV_RULE (PRE_CONV (SIMP_CONV (srw_ss()) []))
  |> CONV_RULE (RAND_CONV (SIMP_CONV (srw_ss())
        [GSYM x64_code_init_bc_code_stripped]))
  |> PURE_REWRITE_RULE [append_imm_code_def,word_arith_lemma1]

val init_loop_thm = let
  val th1 =
    SPEC_COMPOSE_RULE [zHEAP_bootstrap_bc_state,
      zHEAP_MOVE_42,zHEAP_1_Number_0,zHEAP_EL,zHEAP_MOVE_13,
      zHEAP_1_Number_1,zHEAP_EL,zHEAP_MOVE_14,zHEAP_MOVE_32,
      zHEAP_PUSH4,
      zHEAP_IPTR_Number_1,zHEAP_DEREF,zHEAP_PUSH1,
      zHEAP_OPTR_Number_1,zHEAP_DEREF,zHEAP_PUSH1,
      Cons3,zHEAP_PUSH2,zHEAP_PUSH1,Cons2,
      zHEAP_MOVE_14,zHEAP_1_Number_0] |> DISCH_ALL
        |> SIMP_RULE std_ss [EL_SIMPS,SEP_CLAUSES,getRefPtr_def,
             BlockPair_def,isRefPtr_def,LENGTH,
             EVAL ``TAKE 3 [x1;x2;x3]``,LENGTH_ref_globals_list,
             EVAL ``DROP 3 [x1;x2;x3]``,isValueArray_def,
             EVAL ``REVERSE [x1;x2;x3]``,both_refs_0,getValueArray_def,
             EVAL ``REVERSE [x1;x2]``,
             EVAL ``TAKE 2 [x1;x2]``,
             EVAL ``DROP 2 [x1;x2]``,rwt_lemmas]
        |> UNDISCH_ALL |> RW [EL_iptr_index]
  val th = SPEC_COMPOSE_RULE [th1,install_init_bc_code_stripped,zHEAP_CODE_SAFE]
  val c = SIMP_CONV (srw_ss()) []
  val th = th |> CONV_RULE (PRE_CONV c THENC POST_CONV c)
  val th = th |> PURE_REWRITE_RULE [SPEC_MOVE_COND,GSYM AND_IMP_INTRO]
              |> UNDISCH_ALL
  in th end;

val sum_lengths_def = Define `
  (sum_lengths [] n = n) /\
  (sum_lengths (x::xs) n =
     if is_Label x then sum_lengths xs n
                   else sum_lengths xs (n + 1 + real_inst_length x))`

val sum_lengths_LEMMA = prove(
  ``!xs n. sum_lengths xs 0 + n = sum_lengths xs n``,
  Induct \\ fs [sum_lengths_def]
  \\ POP_ASSUM (fn th => ONCE_REWRITE_TAC [GSYM th])
  \\ DECIDE_TAC);

val code_start_eq = prove(
  ``code_start empty_bc_state =
    sum_lengths bootstrap_bc_state.code 0``,
  fs [code_start_def]
  \\ Q.SPEC_TAC (`bootstrap_bc_state.code`,`xs`)
  \\ fs [EVAL ``empty_bc_state.inst_length``]
  \\ Induct \\ fs [sum_lengths_def]
  \\ SRW_TAC [] [] \\ fs []
  \\ ONCE_REWRITE_TAC [GSYM sum_lengths_LEMMA]
  \\ DECIDE_TAC);

val sum_lengths_APPEND = prove(
  ``!xs ys n.
      sum_lengths (xs ++ ys) n =
      sum_lengths xs (sum_lengths ys n)``,
  Induct \\ fs [sum_lengths_def]
  \\ ONCE_REWRITE_TAC [GSYM sum_lengths_LEMMA]
  \\ ONCE_REWRITE_TAC [GSYM sum_lengths_LEMMA]
  \\ DECIDE_TAC);

val sum_lengths_REVERSE = prove(
  ``!xs n. sum_lengths (REVERSE xs) n = sum_lengths xs n``,
  Induct \\ fs [sum_lengths_APPEND,sum_lengths_def] \\ SRW_TAC [] []);

val code_start_empty_bc_state =
  ``code_start empty_bc_state``
  |> (REWRITE_CONV [code_start_eq,EVAL ``empty_bc_state.inst_length``,
        bootstrap_bc_state_code,EVAL ``initial_bc_state.code``,
        initCompEnvTheory.prim_env_eq,SND,THE_DEF,sum_lengths_REVERSE,
        compileReplTheory.compile_repl_module_eq,sum_lengths_APPEND] THENC EVAL)

val SEP_DISJ_DISJ = prove(
  ``p \/ q \/ p = SEP_DISJ p q``,
  fs [FUN_EQ_THM,SEP_DISJ_def] \\ METIS_TAC []);

val init_and_loop = let
  val SPEC_zHEAP_SWAP = prove(
    ``SPEC m (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) * ~zS * zPC p) c q ==>
      !t p'. ((cs,x1,x2,x3,x4,refs,stack,s,space) = t) /\ (p = p') ==>
             SPEC m (zHEAP t * ~zS * zPC p') c q``,
    fs []);
  val th2 =
    MATCH_MP SPEC_zHEAP_SWAP (loop_thm |> UNDISCH_ALL)
    |> SIMP_RULE bool_ss [FORALL_PROD]
    |> SPEC_ALL |> RW [PAIR_EQ,FUNION_FEMPTY_FEMPTY]
    |> UNDISCH_ALL
  val th3 =
    SPEC_COMPOSE_RULE [init_loop_thm,th2 |> Q.INST [`s`|->`t`]]
    |> DISCH_ALL |> GEN_ALL |> SIMP_RULE std_ss []
  val th4 = th3 |> SPEC_ALL |> RW [AND_IMP_INTRO]
    |> CONV_RULE (BINOP1_CONV (SIMP_CONV (srw_ss()) []))
    |> RW [GSYM AND_IMP_INTRO] |> UNDISCH_ALL
  val (_,_,code,_) = dest_spec (concl th4)
  val pat = ``(p:word64,xs:word8 list)``
  fun get_code_end tm = let
    val _ = match_term pat tm
    val (x,y) = dest_pair tm
    val l1 = x |> rand |> rand |> numSyntax.int_of_term
    val l2 = listSyntax.dest_list y |> fst |> length
    in l1 + l2 end
  val xs = find_terms (can get_code_end) code
  fun max_list [] = hd []
    | max_list [x] = x
    | max_list (x::xs) = let
       val n = max_list xs
       in if n < x then x else n end
  val n = max_list (map get_code_end xs) |> numSyntax.term_of_int
  val th5 = th4 |> Q.INST [`cb`|->`p + n2w ^n`]
  val lemma = prove(
    ``(w = v1+v2+v3) <=> (v2 = w-v1-v3:word64)``,
    blastLib.BBLAST_TAC)
    |> Q.INST [`v1`|->`n2w n1`,
               `v2`|->`n2w n2`,
               `v3`|->`n2w n3`,
               `w`|->`n2w n4`]
    |> RW [word_add_n2w]
  val cc =
    REWRITE_CONV [WORD_EQ_ADD_CANCEL,EVAL ``bootstrap_pc``,
               code_start_empty_bc_state,lemma,word_arith_lemma1]
    THENC SIMP_CONV (srw_ss()) []
  val th6 =
    th5 |> DISCH_ALL
        |> PURE_REWRITE_RULE [AND_IMP_INTRO,GSYM CONJ_ASSOC]
        |> CONV_RULE ((RATOR_CONV o RAND_CONV) cc)
        |> PURE_REWRITE_RULE [GSYM AND_IMP_INTRO] |> UNDISCH_ALL
  val pat = ``k MOD n = l:num``
  val xs = filter (can (match_term pat)) (th6 |> hyp)
  fun foo x = let
    val (x1,x2) = dest_eq x
    val v = hd (free_vars x1)
    in v|->``(n2w ^x2):word32`` end
  val sss = map foo xs
  val rwt = map (EVAL o fst o dest_eq o subst sss) xs
  val th7 = INST sss th6 |> DISCH_ALL |> RW rwt |> RW [SEP_DISJ_DISJ]
  in th7 |> UNDISCH_ALL end;

val lex_until_top_semicolon_alt_ADD_WHITE_SPACE = prove(
  ``lex_until_top_semicolon_alt (STRING #" " input) =
    lex_until_top_semicolon_alt input``,
  fs [lex_until_top_semicolon_alt_def]
  \\ ONCE_REWRITE_TAC [lex_aux_alt_def]
  \\ SIMP_TAC std_ss [Once next_sym_def]
  \\ SIMP_TAC std_ss [EVAL ``isSpace #" "``]);

val basis_repl_fun_ADD_WHITE_SPACE = prove(
  ``basis_repl_fun (STRING #" " input) = basis_repl_fun input``,
  fs [basis_repl_fun_def]
  \\ ONCE_REWRITE_TAC [basis_main_loop_def]
  \\ SIMP_TAC std_ss [lex_until_top_semicolon_alt_ADD_WHITE_SPACE]);

val all_the_code = let
  val SPEC_zHEAP_SWAP = prove(
    ``SPEC m (zHEAP (cs,x1,x2,x3,x4,refs,stack,s,space) * ~zS * zPC p) c q ==>
      !t p'. ((cs,x1,x2,x3,x4,refs,stack,s,space) = t) /\ (p = p') ==>
             SPEC m (zHEAP t * ~zS * zPC p') c q``, fs []);
  val th2 =
    MATCH_MP SPEC_zHEAP_SWAP (init_and_loop |> UNDISCH_ALL)
    |> SIMP_RULE bool_ss [FORALL_PROD]
    |> SPEC_ALL |> RW [PAIR_EQ,FUNION_FEMPTY_FEMPTY]
    |> UNDISCH_ALL
  val th1 =
    SPEC_COMPOSE_RULE [zHEAP_INIT,zHEAP_PUSH1,zWRITE_HANDLER,zHEAP_POP1,zHEAP_NOP]
    |> SIMP_RULE std_ss [HD,TL,LENGTH]
  val th3 = SPEC_COMPOSE_RULE [th1,th2 |> Q.INST [`s`|->`t`]]
  val th4 =
    th3 |> DISCH_ALL
        |> Q.INST [`t`|->`first_s init with handler := 1`,
                   `cs`|->`full_cs init p`,
                   `x1`|->`Number 0`]
        |> RW [AND_IMP_INTRO]
        |> CONV_RULE (BINOP1_CONV (SIMP_CONV (srw_ss()) [first_s_def,
             fetch "-" "full_cs_def",first_cs_def,local_zero_def]))
        |> RW [GSYM CONJ_ASSOC,basis_repl_fun_ADD_WHITE_SPACE,
               NOT_CONS_NIL,SEP_CLAUSES]
  val th5 =
    th4 |> RW [GSYM AND_IMP_INTRO]
        |> UNDISCH_ALL
  val tm =
    th5 |> hyp |> first (can (match_term ``EVEN (w2n (p + n2w kk))``))
  val lemma = prove(
    ``^tm = EVEN (w2n (p:word64))``,
    fs [EVEN_w2n] \\ blastLib.BBLAST_TAC)
  val th6 = th5 |> DISCH_ALL |> RW [lemma] |> UNDISCH_ALL
  in th6 |> RW [EVAL ``(full_cs init p).code_heap_ptr``] end

local val fs = fsrw_tac[] in
val DIV_COMPOSE_LEMMA = prove(
  ``let q1 = zBYTECODE_DIVERGED out (cs,w) in
      TEMPORAL m c (T_IMPLIES (NOW q) (T_DISJ q1 (EVENTUALLY (NOW err)))) ==>
      SPEC m p c (err \/ if b then q else q2) ==>
      TEMPORAL m c (T_IMPLIES (NOW p) (T_DISJ (EVENTUALLY (NOW err))
                      (if b then q1 else EVENTUALLY (NOW q2))))``,
  REVERSE (Cases_on `b`) \\ fs [SPEC_EQ_TEMPORAL,LET_DEF]
  \\ PairCases_on `m` \\ fs [TEMPORAL_def,LET_DEF]
  \\ fs [FUN_EQ_THM,T_DISJ_def,EVENTUALLY_def,NOW_def,T_IMPLIES_def,
          SEP_CLAUSES,SEP_REFINE_def] \\ fs [SEP_DISJ_def]
  THEN1 METIS_TAC []
  \\ REVERSE (REPEAT STRIP_TAC) THEN1 (METIS_TAC []) \\ fs [AND_IMP_INTRO]
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`state`,`seq'`,`r`])
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [] \\ METIS_TAC [])
  \\ REPEAT STRIP_TAC
  THENL [METIS_TAC [], ALL_TAC, METIS_TAC []]
  \\ IMP_RES_TAC rel_sequence_shift
  \\ POP_ASSUM (ASSUME_TAC o Q.SPEC `k`) \\ fs []
  \\ FIRST_X_ASSUM (MP_TAC o Q.SPECL [`seq' (k:num)`,`(\j. seq' (k + j))`,`r`])
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 (fs [] \\ METIS_TAC [])
  \\ REPEAT STRIP_TAC
  \\ fs [zBYTECODE_DIVERGED_def,ALWAYS_def,EVENTUALLY_def,NOW_def,
         SEP_CLAUSES,SEP_EXISTS_THM]
  \\ METIS_TAC [ADD_ASSOC]) |> SIMP_RULE std_ss [LET_DEF];
end

val x64_repl_implementation_thm = let
  val (_,_,code,_) = dest_spec (concl all_the_code)
  val th =
    zBC_HEAP_BC_DIV
    |> Q.INST [`cs`|->`full_cs init p`]
    |> MATCH_MP (GEN_ALL (RW [GSYM AND_IMP_INTRO] TEMPORAL_SUBSET_CODE))
    |> SPEC code
  val goal = th |> concl |> dest_imp |> fst
  val lemma = prove(goal,
    PURE_REWRITE_TAC [code_abbrevs_def,UNION_SUBSET]
    \\ PURE_REWRITE_TAC [SUBSET_DEF,IN_INSERT,IN_UNION]
    \\ REPEAT STRIP_TAC \\ ASM_REWRITE_TAC [])
  val th = MP th lemma
           |> RW [EVAL ``(full_cs init p).code_heap_ptr``]
  val th = MATCH_MP (MATCH_MP DIV_COMPOSE_LEMMA th) all_the_code
  val f = SIMP_CONV (srw_ss()) [fetch "-" "full_cs_def"]
  val xs = [``(full_cs init p).install_and_run_ptr``,
            ``(full_cs init p).lex_ptr``,
            ``(full_cs init p).equal_ptr``,
            ``(full_cs init p).alloc_ptr``,
            ``(full_cs init p).print_ptr``,
            ``(full_cs init p).bignum_ptr``,
            ``(full_cs init p).error_ptr``] |> map f
  val th = th |> RW (code_abbrevs_def::xs)
  in th end

val x64_repl_implementation_def = Define `
  x64_repl_implementation p =
    ^(x64_repl_implementation_thm |> concl |> rator |> rand)`;

val T_BOOL_def = Define `T_BOOL b f s = b`

val T_EXISTS = new_binder_definition("T_EXISTS",
  ``($T_EXISTS) = \g f s. ?y. g y f s``);

val SND_basis_repl_fun = prove(
  ``SND (basis_repl_fun input)``,
  MP_TAC (Q.SPEC `input` basis_repl_fun_thm)
  \\ Cases_on `basis_repl_fun input` \\ fs [LET_DEF] \\ SRW_TAC [] []);

val x64_repl_implementation_lemma =
  x64_repl_implementation_thm
  |> DISCH ``basis_repl_fun init.init_input = (res,T)``
  |> CONV_RULE (BINOP1_CONV (ONCE_REWRITE_CONV [GSYM PAIR]))
  |> PURE_REWRITE_RULE [PAIR_EQ] |> RW [SND_basis_repl_fun]
  |> Q.INST [`res`|->`FST (basis_repl_fun init.init_input)`]
  |> RW [GSYM x64_repl_implementation_def]
  |> DISCH_ALL

val TEMPORAL_IMP = prove(
  ``(!f s. q1 f s ==> q2 f s) ==>
    TEMPORAL m code (T_IMPLIES p q1) ==>
    TEMPORAL m code (T_IMPLIES p q2)``,
  PairCases_on `m` \\ fs [TEMPORAL_def,T_IMPLIES_def] \\ METIS_TAC [])

local val fs = fsrw_tac[] in
val zREPL_CORRECT = store_thm("zREPL_CORRECT",
  ``EVEN (w2n p) /\ EVEN (w2n init.init_code_heap_ptr) /\
    2048 <= w2n init.init_code_heap_size ==>
    TEMPORAL X64_MODEL (x64_repl_implementation p)
      (T_IMPLIES (NOW (INIT_STATE init * zPC p * ~zS))
        (T_DISJ (EVENTUALLY (NOW (zHEAP_ERROR (full_cs init p))))
           (T_EXISTS output.
              T_CONJ (T_BOOL (repl basis_repl_env init.init_input output))
                (if diverges output then
                  zBYTECODE_DIVERGED (repl_output output)
                    (full_cs init p,init.init_code_heap_ptr)
                else
                  EVENTUALLY
                    (NOW (zHEAP_OUTPUT (full_cs init p,repl_output output)))))))``,
  REPEAT STRIP_TAC
  \\ MP_TAC x64_repl_implementation_lemma \\ fs []
  \\ MATCH_MP_TAC IMP_IMP \\ STRIP_TAC THEN1 DECIDE_TAC
  \\ fs [AC STAR_COMM STAR_ASSOC]
  \\ MATCH_MP_TAC TEMPORAL_IMP
  \\ fs [T_DISJ_def] \\ REPEAT STRIP_TAC \\ fs [] \\ DISJ2_TAC
  \\ fs [T_EXISTS,T_CONJ_def,T_BOOL_def]
  \\ MP_TAC (Q.SPEC `init.init_input` basis_repl_fun_thm)
  \\ Cases_on `basis_repl_fun init.init_input` \\ fs [LET_DEF]
  \\ REPEAT STRIP_TAC \\ fs []
  \\ Q.EXISTS_TAC `output` \\ fs [diverges_def,repl_output_def]);
end

(*

val th = loop_thm

fun n2w_to_int tm =
  let
    val tm = if wordsSyntax.is_w2w tm then rhs(concl(EVAL tm)) else tm
    val tm = if numSyntax.is_numeral (rand tm) then tm else
               rhs(concl(RAND_CONV(EVAL) tm))
  in
    tm |> wordsSyntax.dest_n2w |> fst |> numSyntax.int_of_term
  end handle HOL_ERR e =>
    (print ("\nUnable to n2w_to_int: " ^ term_to_string tm ^ "\n");
     raise (HOL_ERR e))

fun int_to_hex x =
  String.concat["0x",Arbnum.toHexString (Arbnum.fromInt x)]

fun find_overlap th = let
  val th = th |> Q.INST [`p:word64`|->`0w`,`rip:word64`|->`0w`]
              |> SIMP_RULE std_ss [word_add_n2w]
  val (_,_,c,_) = dest_spec (concl (th |> SPEC_ALL |> UNDISCH_ALL))
  val pat = ``(p:word64, x::xs:word8 list)``
  val tms = find_terms (can (match_term pat)) c
  val xs = map pairSyntax.dest_pair tms
          |> map (fn (x,y) => (n2w_to_int x,
               map n2w_to_int (fst (listSyntax.dest_list y)))
               handle HOL_ERR _ => (0-500,[]))
  val vs = sort (fn (x,_) => fn (y:int,_) => x <= y) xs
  val vs = filter (fn (x,y) => 0 <= x) vs
  fun del_repetations (x::y::xs) = if x = y then del_repetations (x::xs) else
                                            x :: del_repetations (y::xs)
    | del_repetations zs = zs
  val vs = del_repetations vs
  fun no_overlap [] = true
    | no_overlap [(j,xs)] = true
    | no_overlap ((i,xs)::(j,ys)::rest) =
        if j < i + length xs
        then (print ("has overlap at " ^ int_to_hex j ^ "\n");
              no_overlap ((j,ys)::rest))
        else no_overlap ((j,ys)::rest)
  val _ = no_overlap vs
  in () end




has overlap at 0x172
has overlap at 0x173
has overlap at 0x174
has overlap at 0x175
has overlap at 0x176
has overlap at 0x3FF
has overlap at 0x400
has overlap at 0x401
has overlap at 0x402
has overlap at 0x403


th

max_print_depth := 10


  fun no_duplicates (x::y::xs) = if fst x = fst y then failwith"duplicate" else no_duplicates (y::xs)
    | no_duplicates _ = true
  val _ = no_duplicates vs
  fun no_holes i [] = true
    | no_holes i ((j,c)::xs) =
       if i = j then no_holes (i + (length c)) xs else (print("hole at "^(Int.toString i)^"\n");
                     no_holes (fst(hd xs)) xs)
  val _ = no_holes 0 vs







*)


(*
val _ = PolyML.SaveState.saveState "x64_heap_state";
*)

val _ = Feedback.set_trace "TheoryPP.include_docs" 0;
val _ = export_theory();
