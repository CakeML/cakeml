
in patSem
(* this check is failing, pair_CASE from FFI cases are appearing twice in do_app_cases *)

(*
val check =
  do_app_cases |> concl |> find_terms TypeBase.is_case
  |> List.map (#1 o strip_comb)
  |> List.all (fn tm => List.exists (same_const tm) [optionSyntax.option_case_tm, eq_result_CASE_tm])

val () = if check then () else raise(mk_HOL_ERR"patSemTheory""do_app_cases""check failed") *)



Theorem sv_rel_get_carg_sem_flat_eq:
   get_carg_sem refs ty arg = SOME carg /\
   v_rel genv arg arg' /\
   LIST_REL (sv_rel genv) refs refs' /\
   genv_c_ok genv.c ==>
    get_carg_flat refs' ty arg' = SOME carg
Proof
  rw [] >>
  Cases_on `ty` >> Cases_on `arg` >> fs [v_rel_eqns, sv_rel_cases, genv_c_ok_def] >>
  rveq >> fs [get_carg_sem_def, get_carg_flat_def] >>  every_case_tac >>
  TRY (Cases_on `l` >> fs [get_carg_sem_def, get_carg_flat_def] >> NO_TAC) >>
  fs [bool_case_eq, has_bools_def, Boolv_def, semanticPrimitivesTheory.Boolv_def,
      backend_commonTheory.true_tag_def, backend_commonTheory.false_tag_def] >>
  rveq >> rfs [] >> TRY (res_tac >> fs [] >> NO_TAC) >>
  fs [store_lookup_def, LIST_REL_EL_EQN, sv_rel_cases] >> res_tac >> fs []
QED


Theorem sv_rel_get_cargs_sem_flat_eq:
  !refs cts vs cargs refs' vs' genv.
  get_cargs_sem refs cts vs = SOME cargs /\
  LIST_REL (sv_rel genv) refs refs' /\
  LIST_REL (v_rel genv) vs vs' /\
  genv_c_ok genv.c  ==>
      get_cargs_flat refs' cts vs' = SOME cargs
Proof
  ho_match_mp_tac get_cargs_sem_ind >>
  rw [get_cargs_sem_def] >> fs[get_cargs_flat_def] >>
  metis_tac [sv_rel_get_carg_sem_flat_eq]
QED


Theorem v_rel_sem_flat_als_args_eq:
  get_cargs_sem st sign.args args = SOME cargs /\
  get_cargs_flat st' sign.args args' =  SOME cargs' /\
  LIST_REL (sv_rel genv) st st' /\
  LIST_REL (v_rel genv) args args'  /\
  genv_c_ok genv.c  ==>
  als_args sign.args args =  als_args sign.args args'
Proof
  (*
  rw [] >>
  drule (GEN_ALL get_cargs_flat_some_len_eq) >> rw [] >>
  dxrule get_cargs_flat_some_mut_args_refptr >> rw [] >>
  drule (GEN_ALL get_cargs_flat_some_len_eq) >> rw [] >>
  dxrule get_cargs_flat_some_mut_args_refptr >> rw [] >>
  `FILTER (is_mutty ∘ FST) (ZIP (sign.args,args)) =
  FILTER (is_mutty ∘ FST) (ZIP (sign.args,args'))` by
  (ho_match_mp_tac FILTER_EL_EQ >> rw []
   >- (qpat_x_assum `LENGTH _ =_ ` mp_tac >>
      drule EL_ZIP >> rw [] >>
      first_x_assum (qspec_then `n` mp_tac) >> rw [] >> fs [] >>
      qpat_x_assum `LENGTH _ =_ ` mp_tac >>
      drule EL_ZIP >> rw [] >>
      first_x_assum (qspec_then `n` mp_tac) >> rw [] >> fs []>>
      dxrule mutty_ct_elem_arg_loc >> rw [] >>
      dxrule mutty_ct_elem_arg_loc >> rw [] >>
      res_tac >> fs [] >> fs [LIST_REL_EL_EQN] >>
      qpat_x_assum `!n. n < _ ⇒ _` (qspec_then `n` mp_tac) >> rw []) >>
  qpat_x_assum `LENGTH _ =_ ` mp_tac >>
  drule EL_ZIP >> rw [] >>
  first_x_assum (qspec_then `n` mp_tac) >> rw [] >> fs [] >>
  qpat_x_assum `LENGTH _ =_ ` mp_tac >>
  drule EL_ZIP >> rw [] >>
  first_x_assum (qspec_then `n` mp_tac) >> rw [] >> fs []>>
  dxrule mutty_ct_elem_arg_loc >> rw [] >>
  dxrule mutty_ct_elem_arg_loc >> rw [] >>
  res_tac >> fs [] >> fs [LIST_REL_EL_EQN] >>
  qpat_x_assum `!n. n < _ ⇒ _` (qspec_then `n` mp_tac) >> rw []) >>
  rw [ffiTheory.als_args_def] *)
QED



srw_tac[][semanticPrimitivesPropsTheory.do_app_cases, semanticPrimitivesTheory.do_ffi_def,
        flatSemTheory.do_app_def, flatSemTheory.do_ffi_flat_def] >>
      every_case_tac >> fs [] >>
      imp_res_tac sv_rel_get_cargs_sem_flat_eq >> fs [] >> rveq >>
      imp_res_tac v_rel_sem_flat_als_args_eq >> fs [] >> rveq >> cheat
