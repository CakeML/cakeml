(*Generated by Lem from compiler.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory semanticPrimitivesTheory astTheory infer_tTheory intLangTheory toIntLangTheory toBytecodeTheory bytecodeTheory modLangTheory conLangTheory decLangTheory exhLangTheory patLangTheory;

val _ = numLib.prefer_num();



val _ = new_theory "compiler"

(*open import Pervasives*)
(*open import Lib*)
(*open import SemanticPrimitives*)
(*open import Ast*)
(*open import Infer_t*)
(*open import IntLang*)
(*open import ToIntLang*)
(*open import ToBytecode*)
(*open import Bytecode*)
(*open String_extra*)
(*open import ModLang*)
(*open import ConLang*)
(*open import DecLang*)
(*open import ExhLang*)
(*open import PatLang*)

val _ = Hol_datatype `
 compiler_state =
  <| next_global : num
   ; globals_env : (modN, ( (varN, num)fmap)) fmap # (varN, num) fmap
   ; contags_env : num # tag_env # (num, (conN # tid_or_exn)) fmap
   ; exh : exh_ctors_env
   ; rnext_label : num
   |>`;


val _ = Define `
 (compile_Cexp env rsz cs Ce =  
(let (Ce,nl) = (label_closures (LENGTH env) cs.next_label Ce) in
  let cs = (compile_code_env ( cs with<| next_label := nl |>) Ce) in
  compile env TCNonTail rsz cs Ce))`;


 val _ = Define `

(compile_print_vals [] _ s = s)
/\
(compile_print_vals ((x,((_:num),t))::types) map s =  
(let ty = (inf_type_to_string t) in
  let s = (emit s (MAP PrintC (EXPLODE (CONCAT ["val ";x;":"; ty;" = "])))) in
  let s = (emit s [Gread (fapply( 0) x map)]) in
  let s = (emit s (if t = (Infer_Tapp [] TC_word8) then (MAP PrintC (EXPLODE "0wx"))++[PrintWord8] else [Print])) in
  let s = (emit s (MAP PrintC (EXPLODE "\n"))) in
    compile_print_vals types map s))`;


 val _ = Define `

(compile_print_ctors [] s = s)
/\
(compile_print_ctors ((c,_)::cs) s =  
(compile_print_ctors cs
    (emit s (MAP PrintC (EXPLODE (CONCAT [c;" = <constructor>\n"]))))))`;


 val _ = Define `

(compile_print_types [] s = s)
/\
(compile_print_types ((_,_,cs)::ts) s =  
(compile_print_types ts (compile_print_ctors (REVERSE cs) s)))`;


 val _ = Define `

(compile_print_dec _ _ (Dtype ts) s = (compile_print_types (REVERSE ts) s))
/\
(compile_print_dec _ _ (Dexn c xs) s = (compile_print_types [(([]: tvarN list),"exn",[(c,xs)])] s))
/\
(compile_print_dec types map _ s =  
(compile_print_vals types map s))`;


val _ = Define `
 (compile_print_err cs =  
(let (cs,n) = (get_label cs) in
  let cs = (emit cs [Stack (Load( 0));
                    Stack (TagEq (block_tag+none_tag));
                    JumpIf (Lab n);
                    Stack (PushInt(( 0 : int)));
                    Stack El]) in
  let cs = (emit cs (MAP PrintC (EXPLODE "raise "))) in
  let cs = (emit cs [Print]) in
  let cs = (emit cs (MAP PrintC (EXPLODE "\n"))) in
  let cs = (emit cs [Stop F; Label n; Stack Pop]) in
  cs))`;


val _ = Define `
 (compile_print_top types map top cs =  
(let cs = (compile_print_err cs) in
  let cs = ((case types of   NONE => cs | SOME types =>
    (case top of
      (Tmod mn _ _) =>
        let str = (CONCAT["structure ";mn;" = <structure>\n"]) in
        emit cs (MAP PrintC (EXPLODE str))
    | (Tdec dec) => compile_print_dec types map dec cs
    )    )) in
  emit cs [Stop T]))`;


val _ = Define `
 (compile_top types cs top =  
(let n = (cs.next_global) in
  let (m10,m20) = (cs.globals_env) in  
  (case top_to_i1 n m10 m20 top of
      (_,m1,m2,p) =>
  let (c,exh,p) = (prompt_to_i2 cs.contags_env p) in
  let (n,e) = (prompt_to_i3 (none_tag, SOME (TypeId (Short "option")))
                 (some_tag, SOME (TypeId (Short "option"))) n p) in
  let exh = (FUNION exh cs.exh) in
  let e = (exp_to_exh exh e) in
  let e = (exp_to_pat [] e) in
  let e = (exp_to_Cexp e) in
  let r = (compile_Cexp [] ( 0) <| out := []; next_label := cs.rnext_label |>
             e) in
  let r = (compile_print_top types m2 top r) in
  let cs = (<| next_global := n ; globals_env := (m1,m2) ; contags_env := c
            ; exh := exh ; rnext_label := r.next_label |>) in
  (cs, ( cs with<| globals_env := (m1,m20) |>), r.out)
  )))`;


val _ = Define `
 (compile_prog init_compiler_state prog =  
(let n = (init_compiler_state.next_global) in
  let (m1,m2) = (init_compiler_state.globals_env) in  
  (case prog_to_i1 n m1 m2 prog of
      (_,_,m2,p) =>
  (case prog_to_i2 init_compiler_state.contags_env p of
      (_,exh,p) =>
  (case prog_to_i3 (none_tag, SOME (TypeId (Short "option")))
          (some_tag, SOME (TypeId (Short "option"))) n p of
      (_,e) =>
  let e = (exp_to_exh (FUNION exh init_compiler_state.exh) e) in
  let e = (exp_to_pat [] e) in
  let e = (exp_to_Cexp e) in
  let r = (compile_Cexp [] ( 0)
             <| out := []; next_label := init_compiler_state.rnext_label |> 
           e) in
  let r = (compile_print_err r) in
  let r = ((case FLOOKUP m2 "it" of
                 NONE => r
             | SOME n => let r = (emit r [Gread n; Print]) in
                         emit r (MAP PrintC (EXPLODE "\n"))
           )) in let r = (emit r [Stop T]) in REVERSE (r.out)
  )
  )
  )))`;


(* special entrypoints *)

val _ = Define `
 (compile_special cs top =  
(let n = (cs.next_global) in
  let (m1,m2) = (cs.globals_env) in  
  (case top_to_i1 n m1 m2 top of
      (_,_,_,p) =>
  (case prompt_to_i2 cs.contags_env p of
      (_,exh,p) =>
  let e = (decs_to_i3 n (case p of Prompt_i2 ds => ds )) in
  let exh = (FUNION exh cs.exh) in
  let e = (exp_to_exh exh e) in
  let e = (exp_to_pat [] e) in
  let e = (exp_to_Cexp e) in
  let r = (compile [] TCNonTail ( 0)
             <|out:=[]; next_label := cs.rnext_label|> e) in
  (emit r [Stack Pop; Stop T]).out
  )
  )))`;


val _ = Define `
 (prompt_to_i3_initial next (Prompt_i2 ds) =  
(let n = (num_defs ds) in
  ((next+n), Let_i2 NONE (Extend_global_i2 n) (decs_to_i3 next ds))))`;


 val _ = Define `
 (prog_to_i3_initial next [] = (next, Lit_i2 Unit))
    /\ (prog_to_i3_initial next (p::ps) =      
(let (next,p) = (prompt_to_i3_initial next p) in
      let (next',ps) = (prog_to_i3_initial next ps) in
      (next', Let_i2 NONE p ps)))`;


val _ = Define `
 (compile_initial_prog cs prog =  
(let n = (cs.next_global) in
  let (m1,m2) = (cs.globals_env) in  
  (case prog_to_i1 n m1 m2 prog of
      (_,m1,m2,p) =>
  let (c,exh,p) = (prog_to_i2 cs.contags_env p) in
  let (n,e) = (prog_to_i3_initial n p) in
  let exh = (FUNION exh cs.exh) in
  let e = (exp_to_exh exh e) in
  let e = (exp_to_pat [] e) in
  let e = (exp_to_Cexp e) in
  let r = (compile_Cexp [] ( 0) <|out := []; next_label := cs.rnext_label|> e) in
  let cs = (<| next_global := n ; globals_env := (m1,m2) ; contags_env := c
            ; exh := exh ; rnext_label := r.next_label |>) in
  (cs, (emit r [Stack Pop]).out)
  )))`;

val _ = export_theory()

