(*
  Filter case study from CASE.
*)
open preamble basis MapProgTheory ml_translatorLib ml_progLib basisFunctionsLib ml_translatorTheory
     charsetTheory regexpTheory regexp_parserTheory regexp_compilerTheory cfTacticsBaseLib
     cfDivTheory cfDivLib;

val _ = new_theory "filterProg";

(*---------------------------------------------------------------------------*)
(* The regexp wrt. which we're filtering                                     *)
(* In the real implementation it's read from the cmakeConstants SML module   *)
(* which is generated by the build system; here we hardcode a regex.         *)
(*---------------------------------------------------------------------------*)

val the_regexp = "through\^@";

val _ = translation_extends"MapProg";

(*---------------------------------------------------------------------------*)
(* Reuse of some code from regexpLib, so that some intermediate lemmas are   *)
(* kept for use in the proofs of side-condition theorems arising from        *)
(* translation.                                                              *)
(*---------------------------------------------------------------------------*)

val compset = regexpLib.regexp_compset();
val check_these_consts = computeLib.unmapped compset;
val regexpEval = computeLib.CBV_CONV compset;
val stdErr_print = regexpMisc.stdErr_print;

fun regexpc r =
 let open listSyntax regexpSyntax
     val _ = stdErr_print "Compiling regexp to DFA by deduction (can be slow) :\n"
     val regexp_tm = regexpSyntax.mk_regexp r
     val compile_thm = Count.apply regexpEval ``regexp_compiler$compile_regexp ^regexp_tm``
     val triple = rhs (concl compile_thm)
     val [t1,t2,t3] = strip_pair triple
     val start_state_thm = regexpEval ``lookup regexp_compare (normalize ^regexp_tm) ^t1``
     val dom_Brz_thm = EQT_ELIM (Count.apply regexpEval
                      ``dom_Brz_alt empty [normalize ^regexp_tm]``)
     val hyps_thm = LIST_CONJ [compile_thm, start_state_thm,dom_Brz_thm]
     val thm = SIMP_RULE list_ss [fromList_Vector,ORD_BOUND,alphabet_size_def]
                       (SPEC regexp_tm Brzozowski_partial_eval_conseq)
     val dfa_thm = MATCH_MP thm hyps_thm
     val eq_tm = snd(strip_forall (concl dfa_thm))
     val (_,[final,table,start,_]) = strip_comb(boolSyntax.lhs eq_tm)
     val ifinal = List.map (aconv boolSyntax.T)
                  (fst(listSyntax.dest_list (dest_vector final)))
     val istart = numSyntax.int_of_term start
     val rows1 = dest_vector table
     fun dest_row row =
        let val opts = fst (listSyntax.dest_list row)
        in List.map (numSyntax.int_of_term o optionSyntax.dest_some) opts
        end
     val rows2 = fst(listSyntax.dest_list(snd(listSyntax.dest_map rows1)))
     val itable = List.map dest_row rows2
     val len = length ifinal
     val _ = stdErr_print (Int.toString len^" states.\n")
 in
     {certificate = SOME dfa_thm,
      aux = SOME hyps_thm,
      table = Vector.fromList (map Vector.fromList itable),
      start = istart,
      final = Vector.fromList ifinal}
 end;

val regexp_compilation_results as {certificate, aux, ...}
  = regexpc (Regexp_Type.fromString the_regexp);

val matcher_certificate = save_thm
  ("matcher_certificate",
    certificate
      |> valOf
      |> CONV_RULE(QUANT_CONV(LHS_CONV (REWRITE_CONV [MAP])))
);

(*---------------------------------------------------------------------------*)
(* Define a named matcher function                                           *)
(*---------------------------------------------------------------------------*)

val matcher_def =
 Define `matcher ^(matcher_certificate |> concl |> dest_forall |> fst) =
                 ^(matcher_certificate |> concl |> dest_forall |> snd |> lhs)`

val match_string_def = Define `match_string s = matcher(explode s)`

val language_def =
 Define `language =
                 ^(matcher_certificate |> concl |> dest_forall |> snd |> rhs |> rator)`

val match_string_eq = Q.prove(`match_string = language o explode`,
  `!s. match_string s = (language o explode) s` suffices_by metis_tac[]
  >> rw[match_string_def,language_def,matcher_def,matcher_certificate]);

(*---------------------------------------------------------------------------*)
(* Translator setup boilerplate                                              *)
(*---------------------------------------------------------------------------*)

fun def_of_const tm = let
  val res = dest_thy_const tm handle HOL_ERR _ =>
              failwith ("Unable to translate: " ^ term_to_string tm)
  val name = (#Name res)
  fun def_from_thy thy name =
    DB.fetch thy (name ^ "_def") handle HOL_ERR _ =>
    DB.fetch thy (name ^ "_DEF") handle HOL_ERR _ =>
    DB.fetch thy (name ^ "_thm") handle HOL_ERR _ =>
    DB.fetch thy name
  val def = def_from_thy (#Thy res) name handle HOL_ERR _ =>
            failwith ("Unable to find definition of " ^ name)
  in def end

val _ = find_def_for_const := def_of_const;

(* TODO: translate balanced_map module separately? *)

val _ = ml_translatorLib.pick_name :=
  let val default = !ml_translatorLib.pick_name in
    fn c =>
    if same_const c ``balanced_map$member`` then "balanced_map_member" else
    if same_const c ``balanced_map$empty`` then "balanced_map_empty" else
      default c
  end

val spec64 = INST_TYPE[alpha|->``:64``]

val _ = translate matcher_def

val mem_tolist = Q.prove(`MEM (toList l) (MAP toList ll) = MEM l ll`,
  Induct_on `ll` >> fs[]);

val length_tolist_cancel = Q.prove(
  `!n. n < LENGTH l ==> LENGTH (EL n (MAP mlvector$toList l)) = length (EL n l)`,
  Induct_on `l`
  >> fs[]
  >> rpt strip_tac
  >> Cases_on `n`
  >> fs[mlvectorTheory.length_toList]);

val EL_map_toList = Q.prove(`!n. n < LENGTH l ==> EL n' (EL n (MAP toList l)) = sub (EL n l) n'`,
  Induct_on `l`
  >> fs[]
  >> rpt strip_tac
  >> Cases_on `n`
  >> fs[mlvectorTheory.EL_toList]);

val exec_dfa_side_imp = Q.prove(
  `!finals table n s.
   good_vec (MAP toList (toList table)) (toList finals)
    /\ EVERY (λc. MEM (ORD c) ALPHABET) (EXPLODE s)
    /\ n < length finals
   ==> exec_dfa_side finals table n s`,
  Induct_on `s`
  >- fs[fetch "-" "exec_dfa_side_def"]
  >> PURE_ONCE_REWRITE_TAC [fetch "-" "exec_dfa_side_def"]
  >> fs[good_vec_def,mlvectorTheory.length_toList]
  >> rpt GEN_TAC
  >> Induct_on `table`
   >> rpt strip_tac
   >> fs[sub_def,length_def,mlvectorTheory.toList_thm]
   >> `MEM (toList (EL n l)) (MAP toList l)`
        by fs[EL_MEM,mem_tolist,mlvectorTheory.toList_thm]
   >- metis_tac[mlvectorTheory.length_toList]
   >> first_x_assum(MATCH_MP_TAC o Q.SPECL [`finals`,`Vector l`, `x1`])
    >> rpt strip_tac
    >> fs[mlvectorTheory.toList_thm, length_def, mem_tolist]
    >- metis_tac[]
    >> first_x_assum(ASSUME_TAC o Q.SPECL [`toList (EL n l)`,`ORD h`])
    >> first_x_assum(MATCH_MP_TAC o Q.SPECL [`n`,`ORD h`,`x1`])
    >> rfs[mlvectorTheory.length_toList,mem_tolist,EL_map_toList,length_tolist_cancel]);

val all_ord_string = Q.prove
(`EVERY (\c. MEM (ORD c) ALPHABET) s
   <=>
  EVERY (\c. ORD c < alphabet_size) s`,
 simp_tac list_ss [mem_alphabet_iff]);

val good_vec_thm =
 SIMP_RULE std_ss [dom_Brz_alt_equal]
    regexp_compilerTheory.compile_regexp_good_vec;

val matcher_side_lem = Q.prove(
  `!s. matcher_side s <=> T`,
  rw[fetch "-" "matcher_side_def"]
  >> match_mp_tac exec_dfa_side_imp
  >> rw_tac list_ss [mlvectorTheory.toList_thm]
    >- metis_tac [aux |> valOf,good_vec_thm]
    >- rw_tac list_ss [all_ord_string,ORD_BOUND,alphabet_size_def]
    >- EVAL_TAC)
 |>
 update_precondition;

val _ = translate match_string_def

(* val _ = translate(word_bit_test |> spec64); *)

(* TODO: this is largely copied from the bootstrap translation
         can it be properly abstracted out? *)
local
  val ths = ml_translatorLib.eq_lemmas();
in
  fun find_equality_type_thm tm =
    first (can (C match_term tm) o rand o snd o strip_imp o concl) ths
end

val EqualityType_WORD = find_equality_type_thm``WORD``
val no_closures_def = ml_translatorTheory.no_closures_def;
val LIST_TYPE_def = ml_translatorTheory.LIST_TYPE_def;
val EqualityType_def = ml_translatorTheory.EqualityType_def;
val types_match_def = ml_translatorTheory.types_match_def;
val ctor_same_type_def = semanticPrimitivesTheory.ctor_same_type_def;

val tolist_fromlist_map_cancel = Q.store_thm("tolist_fromlist_map_cancel",
  `MAP mlvector$toList (MAP fromList ll) = ll`,
  Induct_on `ll` >> fs[]);

(*---------------------------------------------------------------------------*)
(* Auxiliary functions to deal with null termination.                        *)
(*---------------------------------------------------------------------------*)

val null_index_def = tDefine "null_index"
  `null_index s n =
    if n >= strlen s then NONE
    else if strsub s n = CHR 0 then SOME n
    else null_index s (SUC n)`
  (wf_rel_tac `inv_image (measure (λ(a,b). SUC a - b)) (strlen ## I)`);

val null_index_ind = fetch "-" "null_index_ind";

val null_index_le_len = Q.store_thm("null_index_le_len",
  `!s n m. null_index s n = SOME m ==> m < strlen s`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_def])
  >> rw[]);

val null_index_in_bound = Q.store_thm("null_index_in_bound",
  `!s n m. null_index s n = SOME m ==> n <= m`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_def])
  >> rw[] >> fs[]);

val null_index_null = Q.store_thm("null_index_null",
  `!s n m. null_index s n = SOME m ==> strsub s m = CHR 0`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_def])
  >> rw[] >> fs[]);

val null_index_no_null = Q.store_thm("null_index_no_null",
  `!s n m. null_index s n = SOME m ==> EVERY ($~ o $= (CHR 0)) (TAKE (m-n) (DROP n (explode s)))`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_def])
  >> rw[]
  >> first_x_assum drule >> rpt(disch_then drule)
  >> strip_tac
  >> imp_res_tac null_index_le_len
  >> imp_res_tac null_index_in_bound
  >> qmatch_goalsub_abbrev_tac `EVERY _ (TAKE a1 a2)`
  >> Q.ISPECL_THEN [`a1`,`1`,`a2`] mp_tac take_drop_partition
  >> unabbrev_all_tac
  >> impl_tac >- intLib.COOPER_TAC
  >> disch_then(fn x => rw[GSYM x])
  >> fs[ADD1,DROP_DROP]
  >> `n < LENGTH(explode s)`
     by(fs[])
  >> drule TAKE1_DROP
  >> Cases_on `s` >> fs[mlstringTheory.strsub_def]);

val null_index_no_null2 = Q.store_thm("null_index_no_null2",
  `!s n. null_index s n = NONE ==> EVERY ($~ o $= (CHR 0)) (DROP n (explode s))`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_def])
  >> rw[] >> Cases_on `n ≥ strlen s`
  >> Cases_on `s` >> fs[GREATER_EQ]
  >> imp_res_tac DROP_LENGTH_TOO_LONG >> fs[]
  >> `n < STRLEN s'` by fs[]
  >> imp_res_tac DROP_CONS_EL >> fs[]);

val cut_at_null_def = Define `cut_at_null s =
  case null_index s 0 of
      NONE => strcat s (str(CHR 0))
    | SOME n => substring s 0 (SUC n)`

val cut_at_null_SPLITP = Q.store_thm("cut_at_null_SPLITP",
  `!s. cut_at_null s = implode(FST(SPLITP ($= (CHR 0)) (explode s)) ++ [CHR 0])`,
  Cases >> rw[cut_at_null_def] >> reverse(PURE_TOP_CASE_TAC >> rw[])
  >- (imp_res_tac null_index_le_len >> rw[mlstringTheory.substring_def]
      >> fs[mlstringTheory.strlen_def,mlstringTheory.implode_def]
      >> imp_res_tac null_index_no_null >> fs[]
      >> imp_res_tac null_index_null >> fs[]
      >> imp_res_tac SPLITP_TAKE_DROP >> rfs[]
      >> imp_res_tac (GSYM TAKE_SEG) >> fs[]
      >> fs[ADD1]
      >> Q.ISPECL_THEN [`s'`,`x`] assume_tac TAKE_EL_SNOC
      >> rfs[])
  >- (imp_res_tac null_index_no_null2
      >> fs[o_DEF] >> imp_res_tac SPLITP_EVERY
      >> fs[mlstringTheory.implode_def,mlstringTheory.strcat_thm]));

val _ = translate cut_at_null_def;

val null_index_side_lem = Q.prove(
  `!s n. null_index_side s n <=> T`,
  ho_match_mp_tac null_index_ind
  >> rw[]
  >> PURE_ONCE_REWRITE_TAC[fetch "-" "null_index_side_def"]
  >> fs[ADD1])
 |> update_precondition;

val cut_at_null_side_lem = Q.prove(`!s. cut_at_null_side s <=> T`,
  rw[fetch "-" "cut_at_null_side_def",null_index_side_lem]
  >> imp_res_tac null_index_le_len >> fs[])
 |> update_precondition;

val null_index_w_def = tDefine "null_index_w"
  `null_index_w s n =
    if n >= LENGTH s then NONE
    else if EL n s = 0w then SOME n
    else null_index_w s (SUC n)`
  (wf_rel_tac `inv_image (measure (λ(a,b). SUC a - b)) (LENGTH ## I)`);

val null_index_w_ind = fetch "-" "null_index_w_ind";

val null_index_w_le_len = Q.store_thm("null_index_w_le_len",
  `!s n m. null_index_w s n = SOME m ==> m < LENGTH s`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index_w` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_w_def])
  >> rw[]);

val null_index_w_in_bound = Q.store_thm("null_index_w_in_bound",
  `!s n m. null_index_w s n = SOME m ==> n <= m`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index_w` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_w_def])
  >> rw[] >> fs[]);

val null_index_w_null = Q.store_thm("null_index_w_null",
  `!s n m. null_index_w s n = SOME m ==> EL m s = 0w`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index_w` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_w_def])
  >> rw[] >> fs[]);

val null_index_w_no_null = Q.store_thm("null_index_w_no_null",
  `!s n m. null_index_w s n = SOME m ==> EVERY ($~ o $= 0w) (TAKE (m-n) (DROP n s))`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index_w` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_w_def])
  >> rw[]
  >> first_x_assum drule >> rpt(disch_then drule)
  >> strip_tac
  >> imp_res_tac null_index_w_le_len
  >> imp_res_tac null_index_w_in_bound
  >> qmatch_goalsub_abbrev_tac `EVERY _ (TAKE a1 a2)`
  >> Q.ISPECL_THEN [`a1`,`1`,`a2`] mp_tac take_drop_partition
  >> unabbrev_all_tac
  >> impl_tac >- intLib.COOPER_TAC
  >> disch_then(fn x => rw[GSYM x])
  >> fs[ADD1,DROP_DROP]
  >> `n < LENGTH s`
     by(fs[])
  >> drule TAKE1_DROP >> fs[]);

val null_index_w_no_null2 = Q.store_thm("null_index_w_no_null2",
  `!s n. null_index_w s n = NONE ==> EVERY ($~ o $= 0w) (DROP n s)`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index_w` (mp_tac o PURE_ONCE_REWRITE_RULE [null_index_w_def])
  >> rw[] >> Cases_on `n ≥ LENGTH s`
  >> fs[GREATER_EQ]
  >> imp_res_tac DROP_LENGTH_TOO_LONG >> fs[]
  >> `n < LENGTH s` by fs[]
  >> imp_res_tac DROP_CONS_EL >> fs[]);

val cut_at_null_w_def = Define `cut_at_null_w s =
  case null_index_w s 0 of
      NONE => s ++ [0w]
    | SOME n => SEG (SUC n) 0 s`

val cut_at_null_w_SPLITP = Q.store_thm("cut_at_null_w_SPLITP",
  `!s. cut_at_null_w s = FST(SPLITP ($= 0w) s) ++ [0w]`,
  rw[cut_at_null_w_def] >> reverse(PURE_TOP_CASE_TAC >> rw[])
  >- (imp_res_tac null_index_w_le_len >> rw[mlstringTheory.substring_def]
      >> fs[mlstringTheory.strlen_def,mlstringTheory.implode_def]
      >> imp_res_tac null_index_w_no_null >> fs[]
      >> imp_res_tac null_index_w_null >> fs[]
      >> imp_res_tac SPLITP_TAKE_DROP >> rfs[]
      >> fs[GSYM TAKE_SEG,ADD1]
      >> Q.ISPECL_THEN [`s`,`x`] assume_tac TAKE_EL_SNOC
      >> rfs[])
  >- (imp_res_tac null_index_w_no_null2
      >> fs[o_DEF] >> imp_res_tac SPLITP_EVERY >> fs[]));

val null_index_w_thm = Q.store_thm("null_index_w_thm",
  `∀s n. null_index_w (s:word8 list) n = null_index (implode (MAP (CHR ∘ w2n) s)) n`,
  ho_match_mp_tac null_index_w_ind
  >> rpt strip_tac
  >> MAP_EVERY PURE_ONCE_REWRITE_TAC [[null_index_def],[null_index_w_def]] >> rw[]
  >> fs[mlstringTheory.implode_def]
  >> `n < LENGTH s` by fs[]
  >> rfs[EL_MAP]
  >> qspecl_then [`[EL n s]`,`[0w]`] assume_tac MAP_CHR_w2n_11
  >> fs[]);

val cut_at_null_w_thm = Q.store_thm("cut_at_null_w_thm",
  `∀s. cut_at_null_w (s:word8 list) = MAP (n2w o ORD) (explode (cut_at_null (implode (MAP (CHR ∘ w2n) s))))`,
  rw[cut_at_null_w_def,cut_at_null_def,null_index_w_thm]
  >> PURE_TOP_CASE_TAC >> rw[MAP_MAP_o]
  >> fs[n2w_ORD_CHR_w2n]
  >> imp_res_tac null_index_le_len
  >> fs[mlstringTheory.implode_def,mlstringTheory.substring_def]
  >> MAP_EVERY PURE_ONCE_REWRITE_TAC [[null_index_def],[null_index_w_def]] >> rw[]
  >> fs[GSYM TAKE_SEG,MAP_TAKE,MAP_MAP_o,n2w_ORD_CHR_w2n]);

val cut_at_null_thm = Q.store_thm("cut_at_null_thm",
  `cut_at_null(strlit (MAP (CHR o w2n) l)) = strlit(MAP (CHR o w2n) (cut_at_null_w(l:word8 list)))`,
 rw[cut_at_null_w_thm,MAP_MAP_o,implode_def,CHR_w2n_n2w_ORD,REWRITE_RULE[implode_def] implode_explode]);

val null_terminated_def = Define `
  null_terminated s = ?m. null_index s 0 = SOME m`

val null_terminated_w_def = Define `
  null_terminated_w s = ?m. null_index_w s 0 = SOME m`

val null_terminated_w_thm = Q.store_thm("null_terminated_w_thm",`
  !s. null_terminated_w (s:word8 list) = null_terminated(implode(MAP (CHR o w2n) s))`,
  rw[null_terminated_def,null_terminated_w_def,null_index_w_thm]);

val null_index_strcat1 = Q.store_thm("null_index_strcat1",
  `!s1 n s2 m. null_index s1 n = SOME m ==> null_index (strcat s1 s2) n = SOME m`,
  ho_match_mp_tac null_index_ind
  >> rpt strip_tac
  >> qhdtm_x_assum `null_index` mp_tac
  >> PURE_ONCE_REWRITE_TAC [null_index_def]
  >> rw[] >> fs[]
  >> MAP_EVERY Cases_on [`s1`,`s2`]
  >> fs[mlstringTheory.strsub_def,mlstringTheory.strcat_def,mlstringTheory.concat_def,EL_APPEND_EQN])

val null_terminated_cut_APPEND = Q.store_thm("null_terminated_cut_APPEND",
  `!s1 s2. null_terminated s1 ==> cut_at_null(strcat s1 s2) = cut_at_null s1`,
  rw[null_terminated_def,cut_at_null_def] >> imp_res_tac null_index_strcat1
  >> fs[] >> imp_res_tac null_index_le_len
  >> MAP_EVERY Cases_on [`s1`,`s2`]
  >> fs[mlstringTheory.strsub_def,mlstringTheory.strcat_def,mlstringTheory.concat_def,
        mlstringTheory.substring_def]
  >> match_mp_tac SEG_APPEND1 >> fs[]);

val null_terminated_cut_w_APPEND = Q.store_thm("null_terminated_cut_APPEND",
  `!s1 s2. null_terminated_w(s1:word8 list) ==> cut_at_null_w(s1 ++ s2) = cut_at_null_w s1`,
  rw[null_terminated_w_thm,cut_at_null_w_thm]
  >> drule null_terminated_cut_APPEND
  >> disch_then(qspec_then `implode(MAP (CHR ∘ w2n) s2)` assume_tac)
  >> simp[mlstringTheory.implode_STRCAT]);
(*---------------------------------------------------------------------------*)
(* Loop processing input stream. Currently limited to strings <= 256 chars.  *)
(* This is not a HOL function so is not being pushed through translate.      *)
(*---------------------------------------------------------------------------*)

val dummyarr_e = ``(App Aw8alloc [Lit (IntLit 0); Lit (Word8 0w)])``
val eval_thm = let
  val env = get_ml_prog_state () |> ml_progLib.get_env
  val st = get_ml_prog_state () |> ml_progLib.get_state
  val new_st = ``^st with refs := ^st.refs ++ [W8array (REPLICATE 0 0w)]``
  val goal = list_mk_icomb (prim_mk_const {Thy="ml_prog", Name="eval_rel"},
    [st, env, dummyarr_e, new_st, mk_var ("x", semanticPrimitivesSyntax.v_ty)])
  val lemma = goal |> (EVAL THENC SIMP_CONV(srw_ss())[semanticPrimitivesTheory.state_component_equality])
  val v_thm = prove(mk_imp(lemma |> concl |> rand, goal),
    rpt strip_tac \\ rveq \\ match_mp_tac(#2(EQ_IMP_RULE lemma))
    \\ asm_simp_tac bool_ss [])
    |> GEN_ALL |> SIMP_RULE std_ss [] |> SPEC_ALL;
  val v_tm = v_thm |> concl |> strip_comb |> #2 |> last
  val v_def = define_abbrev false "dummyarr_loc" v_tm
  in v_thm |> REWRITE_RULE [GSYM v_def] end

val dummyarr_loc_def = fetch "-" "dummyarr_loc_def";

val _ = ml_prog_update (add_Dlet eval_thm "dummyarr" []);

val forward_matching_lines = process_topdecs`
fun forward_loop inputarr =
    (#(accept_call) "" inputarr;
     let val ln = Word8Array.substring inputarr 0 256;
         val ln' = cut_at_null ln;
     in
       if match_string ln' then
         #(emit_string) ln' dummyarr
       else ()
     end;
     forward_loop inputarr);

fun forward_matching_lines u =
    let val inputarr = Word8Array.array 256 (Word8.fromInt 0);
    in
      forward_loop inputarr
    end`

val _ = append_prog forward_matching_lines;

val st = get_ml_prog_state();

val maincall =
  ``Dlet unknown_loc (Pcon NONE []) (App Opapp [Var (Short "forward_matching_lines"); Con NONE []])``

val filter_ffi = Datatype `
  filter_ffi =
  <| input : word8 list llist
   |>`

val filter_oracle = Define `
  (filter_oracle:filter_ffi oracle) port st conf bytes =
  if port = "accept_call" then
    (if st.input = LNIL then Oracle_final FFI_diverged
     else if LENGTH bytes = 256 then
        Oracle_return (st with input := THE(LTL(st.input)))
                        (TAKE 256 (THE(LHD st.input)) ++ DROP (LENGTH(THE(LHD st.input))) bytes)
     else Oracle_final FFI_failed)
  else if port = "emit_string" then
    Oracle_return st bytes
  else Oracle_final FFI_failed
`

val encode_oracle_state_def = Define `
  encode_oracle_state st =
      (Fun
         (λffi.
            case ffi of
              iNum n =>
              (case LNTH n st.input of
                 SOME l => Str(MAP (CHR o w2n) l)
               | NONE => Num 0)
            | _ => ARB
         )
      )`

val filter_ffi_component_equality = fetch "-" "filter_ffi_component_equality"

val decode_oracle_state_def = Define `
  decode_oracle_state ffi =
     case destFun ffi of
       SOME instream =>
       <|input:= LUNFOLD (λn. OPTION_MAP ($, (SUC n) o MAP (n2w o ORD))
                              (destStr(instream (iNum n)))) 0|>`

val filter_cf_oracle = Define `
  filter_cf_oracle port conf bytes ffi =
  case filter_oracle port (decode_oracle_state ffi) conf bytes of
      Oracle_final FFI_failed => NONE
    | Oracle_final FFI_diverged => SOME FFIdiverge
    | Oracle_return st' bytes => SOME(FFIreturn bytes (encode_oracle_state st'))`

val seL4_IO_def = Define `
  seL4_IO input events =
  one(
    FFI_part
      (encode_oracle_state (<|input:=input|>))
      filter_cf_oracle
      ["accept_call";"emit_string"]
      events)`

Theorem LUNFOLD_ADD1:
  LUNFOLD (\n. lift ($, (SUC n)) (f (LNTH n (x:::y)))) 1 =
  LUNFOLD (\n. lift ($, (SUC n)) (f (LNTH n y))) 0
Proof
  PURE_ONCE_REWRITE_TAC[LUNFOLD_BISIMULATION] >>
  qexists_tac `\x y. x = SUC y` >>
  rw[] >> metis_tac[option_CASES]
QED

Theorem decode_encode_oracle_state_11:
  !ffi_st. decode_oracle_state(encode_oracle_state ffi_st) = ffi_st
Proof
  rw[encode_oracle_state_def,decode_oracle_state_def,
                   filter_ffi_component_equality] >>
  rename1 `_ = ll` >>
  qho_match_abbrev_tac `a1 ll = _` >>
  PURE_ONCE_REWRITE_TAC[LLIST_BISIMULATION] >>
  qexists_tac `\x y. ?ll. x = a1 ll /\ y = ll` >>
  qunabbrev_tac `a1` >>
  rw[] >>
  simp[SimpL ``$=``, Once LUNFOLD] >>
  simp[LNTH] >>
  rename1 `LHD ll` >> Cases_on `ll` >> fs[MAP_MAP_o,n2w_ORD_CHR_w2n] >>
  simp[GSYM OPTION_MAP_COMPOSE] >>
  PURE_ONCE_REWRITE_TAC[LUNFOLD_BISIMULATION] >>
  qexists_tac `\x y. x = SUC y` >>
  rw[] >> metis_tac[option_CASES]
QED

val next_filter_event = Define
  `next_filter_event filter_fun (ffi_st,last_input,b) =
   if b then
       SOME((ffi_st,
            last_input,F),
           IO_event "emit_string" (cut_at_null_w last_input) [])
   else if LLENGTH(ffi_st.input) = SOME 0 then
     NONE
   else
     let fhd = THE(LHD(ffi_st.input));
         ftl = THE(LTL(ffi_st.input));
         fhd' = TAKE 256 fhd ++ DROP (LENGTH fhd) last_input;
     in
       SOME((ffi_st with input := ftl,fhd',filter_fun(cut_at_null_w fhd)),
            IO_event "accept_call" [] (ZIP (last_input, fhd')))`

val filter_events = Define
  `filter_events filter_fun ffi_st =
   LUNFOLD (next_filter_event filter_fun) (ffi_st,REPLICATE 256 (0w:word8),F)
  `

val is_accept_def = Define
  `is_accept (IO_event s _ _) = (s = "accept_call")`

val bytes_of_def = Define
  `bytes_of (IO_event s conf bytes) = MAP SND bytes`

val finite_events_is_list = Q.prove(
  `
    !i1 f init b.
    IS_SOME(toList (LUNFOLD (next_filter_event f)
                            (<|input := fromList i1|>,init,b)))
  `,
  Induct >>
  rpt(rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM,IS_SOME_MAP]));

val finite_events_is_list2 = Q.prove(
  `
    !i1 f init b.
    ? l. toList(LUNFOLD (next_filter_event f) (<|input := fromList i1|>,init,b)) = SOME l /\
         (LENGTH l <= 2 * LENGTH i1 + if b then 1 else 0) /\
         LENGTH i1 <= LENGTH l
  `,
  Induct >-
    rpt(rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM]) >-
    (rw[] >>
     TRY(rename1 `T` >>
         ntac 2 (rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM])) >>
     TRY(rename1 `F` >>
         rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM]) >>
      simp[PULL_EXISTS] >>
      qmatch_goalsub_abbrev_tac `LUNFOLD (_ f) (_,init2,b)` >>
      first_x_assum(qspecl_then[`f`,`init2`,`b`] strip_assume_tac) >>
      asm_exists_tac >> simp[] >> Cases_on `b` >> fs[]));

val toList_FINITE_LAPPEND = Q.prove(
  `!ll1 l1 ll2 l2.
  toList ll1 = SOME l1
  /\ toList ll2 = SOME l2
  ==> toList(LAPPEND ll1 ll2) = SOME(l1 ++ l2)`,
  Induct_on `l1` >> Cases_on `ll1` >> rw[toList_THM]);

val finite_events_sane_length = Q.prove(
  `
    !i1 f init b.
    LENGTH init = 256 /\
    EVERY ($>= 256 o LENGTH) i1 ==>
    EVERY ($= 256 o LENGTH)
          (MAP bytes_of
            (FILTER is_accept(
                THE(toList (LUNFOLD (next_filter_event f)
                           (<|input := fromList i1|>,init,b))))))
  `,
  Induct >-
    ntac 2 (rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM,is_accept_def,bytes_of_def]) >>
  rw[] >>
  `LENGTH(TAKE 256 h ++ DROP (LENGTH h) init) = 256` by(rw[LENGTH_TAKE_EQ]) >>
  first_x_assum drule_all >>
  disch_then(qspecl_then [`f`,`f(cut_at_null_w h)`] assume_tac) >>
  Q.ISPECL_THEN [`i1`,`f`,`TAKE 256 h ++ DROP (LENGTH h) init`,`f(cut_at_null_w h)`] assume_tac finite_events_is_list >>
  fs[IS_SOME_EXISTS] >> fs[] >>
  ntac 2 (rw[Once LUNFOLD] >> rw[next_filter_event,toList_THM,is_accept_def,bytes_of_def]));

Theorem every_LTAKE:
  !i l ll.
  every f ll /\
  LTAKE i ll = SOME l
  ==> EVERY f l
Proof
  Induct >> Cases_on `ll` >> rw[] >> rw[] >> metis_tac[]
QED

Theorem every_LDROP:
  !i l ll1.
  every f ll1 /\
  LDROP i ll1 = SOME ll2
  ==> every f ll2
Proof
  Induct >> Cases_on `ll1` >> rw[] >> rw[] >> metis_tac[]
QED

Theorem filter_events_append:
!i1 i2 f.
EVERY (null_terminated_w) i1 /\
EVERY ($>= 256 o LENGTH) i1
==>
filter_events f
  (<|input := LAPPEND (fromList i1) i2|>
  )
=
LAPPEND (filter_events f
         <|input:=fromList i1|>)
        (LUNFOLD
          (next_filter_event f)
          (<|input := i2|>,
          LAST(REPLICATE 256 0w
           ::
           MAP bytes_of(FILTER is_accept
             (THE(toList(filter_events
              f
               <|input:=fromList i1|>))))),
           F))
Proof
  simp[filter_events] >>
  qpat_abbrev_tac `init = REPLICATE 256 0w` >>
  `LENGTH init = 256` by(unabbrev_all_tac >> simp[]) >>
  pop_assum mp_tac >> pop_assum kall_tac >>
  simp[PULL_FORALL] >> qid_spec_tac `init` >>
  Induct_on `i1` >-
    (rw[filter_events] >>
     CONV_TAC(RHS_CONV(RAND_CONV(RAND_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])))) >>
     CONV_TAC(RHS_CONV(RATOR_CONV(RAND_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])))) >>
     simp[next_filter_event,toList_THM,LAPPEND_NIL_2ND]) >-
    (rw[filter_events] >>
     Cases_on `f(cut_at_null_w h)`
       >-
       ((* f h *)
        CONV_TAC(LHS_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])) >>
        simp[next_filter_event] >>
        CONV_TAC(LHS_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD]))) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD]))) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RAND_CONV(RAND_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])))) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RAND_CONV(RAND_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])))) >>
        simp[next_filter_event,toList_THM] >>
        qmatch_goalsub_abbrev_tac `LUNFOLD _ (_,newinit,F)` >>
        first_x_assum(qspecl_then [`newinit`,`i2`,`f`] mp_tac) >>
        impl_tac >- (unabbrev_all_tac >> fs[LENGTH_TAKE_EQ]) >>
        impl_tac >- rw[] >>
        disch_then(fn thm => simp[thm]) >>
        Q.ISPECL_THEN [`i1`,`f`,`newinit`,`F`] mp_tac finite_events_is_list >>
        rw[IS_SOME_EXISTS] >>
        rw[is_accept_def,bytes_of_def] >>
        unabbrev_all_tac >> fs[] >>
        fs[MAP_ZIP,LENGTH_TAKE_EQ]
        ) >-
       ((* ¬f h *)
        CONV_TAC(LHS_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD]))) >>
        simp[next_filter_event] >>
        CONV_TAC(RHS_CONV(RAND_CONV(RAND_CONV(PURE_ONCE_REWRITE_CONV [LUNFOLD])))) >>
        simp[next_filter_event,toList_THM] >>
        qmatch_goalsub_abbrev_tac `LUNFOLD _ (_,newinit,F)` >>
        first_x_assum(qspecl_then [`newinit`,`i2`,`f`] mp_tac) >>
        impl_tac >- (unabbrev_all_tac >> fs[LENGTH_TAKE_EQ]) >>
        impl_tac >- rw[] >>
        disch_then(fn thm => simp[thm]) >>
        Q.ISPECL_THEN [`i1`,`f`,`newinit`,`F`] mp_tac finite_events_is_list >>
        rw[IS_SOME_EXISTS] >>
        rw[is_accept_def,bytes_of_def] >>
        unabbrev_all_tac >> fs[] >>
        fs[MAP_ZIP,LENGTH_TAKE_EQ]
       )
    )
QED

val LLENGTH_NONE_LTAKE = Q.prove(
  `!n ll. LLENGTH ll = NONE ==> ?l. LTAKE n ll = SOME l`,
  Induct >> Cases_on `ll` >> rw[]);

Theorem forward_matching_lines_div_spec:
  !input output rv.
    limited_parts ["accept_call";"emit_string"] p /\
    LLENGTH input = NONE /\
    every (null_terminated_w) input /\
    every ($>= 256 o LENGTH) input
    ==>
    app (p:'ffi ffi_proj) ^(fetch_v "forward_matching_lines" st) [rv]
      (seL4_IO input [] * W8ARRAY dummyarr_loc [])
      (POSTd io. io = filter_events (language o MAP (CHR o w2n)) <|input:=input|>)
Proof
  xcf "forward_matching_lines" st >>
  xlet_auto >- xsimpl >>
  xlet_auto >- xsimpl >>
  unfold_cf_app >>
  xcf_div "forward_loop" st >>
  rename1 `_ 0 inputarr` >>
  qabbrev_tac `a1 = λn. THE(toList(filter_events
        (language o MAP (CHR o w2n))
        <|input:=fromList(THE(LTAKE n input))|>))` >>
  MAP_EVERY qexists_tac
    [`λn. W8ARRAY dummyarr_loc [] *
      W8ARRAY inputarr
              (LAST(REPLICATE 256 0w::MAP bytes_of(FILTER is_accept(a1 n))))`,
     `a1`,
     `K($= inputarr)`,
     `λn. encode_oracle_state
      <|input:=THE(LDROP n input)|>`,
     `filter_cf_oracle`,
     `filter_events (language o MAP (CHR o w2n)) <|input:=input|>`
    ] >>
  qunabbrev_tac `a1` >>
  conj_tac >- simp[] >>
  conj_tac >-
    (xsimpl >>
     simp[seL4_IO_def,filter_events,Once LUNFOLD,next_filter_event] >>
     simp[Once LUNFOLD] >>
     simp[toList,LAPPEND_NIL_2ND,next_filter_event] >>
     xsimpl) >>
  simp[] >>
  conj_tac >-
    (strip_tac >>
     qmatch_goalsub_abbrev_tac `W8ARRAY inputarr inputbuff` >>
     `LENGTH inputbuff = 256`
       by(unabbrev_all_tac >>
          rw[filter_events] >>
          Q.ISPEC_THEN `\l. LENGTH l = 256` (ho_match_mp_tac o SIMP_RULE std_ss []) EVERY_LAST >>
          rw[] >>
          qspecl_then [`THE(LTAKE i input)`,`language o MAP (CHR o w2n)`,`REPLICATE 256 0w`,`F`] mp_tac finite_events_sane_length >>
          impl_tac >-
            (drule LLENGTH_NONE_LTAKE >>
             disch_then(qspec_then `i` strip_assume_tac) >>
             fs[] >> metis_tac[every_LTAKE]) >>
          match_mp_tac EVERY_MONOTONIC >> rw[]) >>
     xlet `(POSTv v. &UNIT_TYPE () v * W8ARRAY dummyarr_loc [] *
            W8ARRAY inputarr ((TAKE 256 (THE (LHD (THE (LDROP i input)))) ++
                              DROP (LENGTH (THE (LHD (THE (LDROP i input))))) inputbuff))  *
      one
        (FFI_part
           (encode_oracle_state
              <|input := THE (LDROP (SUC i) input)|>) filter_cf_oracle
           ["accept_call"; "emit_string"]
           (THE
              (toList
                 (filter_events (language ∘ MAP (CHR ∘ w2n))
                    <|input := fromList (THE (LTAKE i input))|>)) ++
              [IO_event "accept_call" [] (ZIP(inputbuff,
                                          ((TAKE 256 (THE (LHD (THE (LDROP i input)))) ++
                              DROP (LENGTH (THE (LHD (THE (LDROP i input))))) inputbuff))))]
           )))` >-
       (xffi >> xsimpl >>
        qmatch_goalsub_abbrev_tac `one(FFI_part s u ns events)` >>
        MAP_EVERY qexists_tac [`W8ARRAY dummyarr_loc []`,`s`,`u`,`ns`,`events`] >>
        unabbrev_all_tac >> xsimpl >>
        simp[filter_cf_oracle,decode_encode_oracle_state_11,filter_oracle] >>
        `?i1 input'. LDROP i input = SOME(i1:::input')`
          by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
             qid_spec_tac `input` >> rpt(pop_assum kall_tac) >>
             Induct_on `i` >> fs[] >>
             Cases >> rw[]) >>
        simp[LDROP_SUC] >>
        xsimpl) >>
     xlet `(POSTv v. &UNIT_TYPE () v * W8ARRAY dummyarr_loc [] *
            W8ARRAY inputarr ((TAKE 256 (THE (LHD (THE (LDROP i input)))) ++
                              DROP (LENGTH (THE (LHD (THE (LDROP i input))))) inputbuff))  *
      one
        (FFI_part
           (encode_oracle_state
              <|input := THE (LDROP (SUC i) input)|>) filter_cf_oracle
           ["accept_call"; "emit_string"]
           (THE
              (toList
                 (filter_events (language ∘ MAP (CHR ∘ w2n))
                    <|input := fromList (THE (LTAKE (SUC i) input))|>)))))` >-
       (xlet_auto >-
          (xsimpl >>
           `?i1 input'. LDROP i input = SOME(i1:::input')`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >> rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
           fs[] >>
           imp_res_tac every_LDROP >>
           fs[every_thm,LENGTH_TAKE_EQ]) >>
        xlet_auto >- xsimpl >>
        xlet_auto >- xsimpl >>
        reverse xif >-
          (xcon >> xsimpl >>
           `?i1 input'. LDROP i input = SOME(i1:::input')`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >> rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
           fs[] >>
           simp[LTAKE_SNOC_LNTH,LNTH_HD_LDROP] >>
           `?i2. LTAKE i input = SOME i2`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >>
                rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
           simp[] >> imp_res_tac every_LTAKE >>
           drule_all filter_events_append >>
           disch_then(qspecl_then [`fromList[i1]`,`language ∘ MAP (CHR ∘ w2n)`] mp_tac) >>
           simp[LAPPEND_fromList] >> disch_then kall_tac >>
           ntac 2 (simp[Once LUNFOLD] >> simp[next_filter_event]) >>
           fs[match_string_eq] >> fs[cut_at_null_w_thm,MAP_MAP_o,CHR_w2n_n2w_ORD,implode_def] >>
           imp_res_tac every_LDROP >> fs[every_thm] >>
           fs[null_terminated_w_thm,implode_def] >>
           fs[null_terminated_cut_APPEND,TAKE_APPEND,TAKE_LENGTH_TOO_LONG] >>
           fs[GSYM strlit_STRCAT,null_terminated_cut_APPEND] >>
           qspecl_then [`i2`,`language o MAP (CHR o w2n)`,`REPLICATE 256 0w`,`F`] mp_tac finite_events_is_list >>
           rw[IS_SOME_EXISTS] >>
           rw[filter_events] >>
           drule toList_FINITE_LAPPEND >>
           qmatch_goalsub_abbrev_tac `LAPPEND _ [|ll2|]` >>
           disch_then(qspecl_then [`[|ll2|]`,`[ll2]`] mp_tac) >>
           impl_tac >- simp[toList_THM] >>
           simp[] >> xsimpl) >-
          (xffi >>
           fs[cut_at_null_thm,STRING_TYPE_def] >>
           qmatch_goalsub_abbrev_tac `MAP _ a1 = _` >>
           qexists_tac `a1` >> qunabbrev_tac `a1` >>
           simp[] >>
           qmatch_goalsub_abbrev_tac `W8ARRAY inputarr ibuff` >>
           MAP_EVERY qexists_tac [`[]`,`W8ARRAY inputarr ibuff`] >>
           xsimpl >>
           qmatch_goalsub_abbrev_tac `FFI_part s u ns events` >>
           MAP_EVERY qexists_tac [`s`,`u`,`ns`,`events`] >>
           unabbrev_all_tac >> simp[filter_cf_oracle,filter_oracle] >>
           xsimpl >>
           `?i1 input'. LDROP i input = SOME(i1:::input')`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >> rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
           fs[] >>
           simp[LTAKE_SNOC_LNTH,LNTH_HD_LDROP] >>
           `?i2. LTAKE i input = SOME i2`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >>
                rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
           simp[] >> imp_res_tac every_LTAKE >>
           drule_all filter_events_append >>
           disch_then(qspecl_then [`fromList[i1]`,`language ∘ MAP (CHR ∘ w2n)`] mp_tac) >>
           simp[LAPPEND_fromList] >> disch_then kall_tac >>
           ntac 3 (simp[Once LUNFOLD] >> simp[next_filter_event]) >>
           fs[match_string_eq] >> fs[cut_at_null_w_thm,MAP_MAP_o,CHR_w2n_n2w_ORD,implode_def] >>
           imp_res_tac every_LDROP >> fs[every_thm] >>
           fs[null_terminated_w_thm,implode_def] >>
           fs[null_terminated_cut_APPEND,TAKE_APPEND,TAKE_LENGTH_TOO_LONG] >>
           fs[GSYM strlit_STRCAT,null_terminated_cut_APPEND] >>
           simp[next_filter_event] >>
           qspecl_then [`i2`,`language o MAP (CHR o w2n)`,`REPLICATE 256 0w`,`F`] mp_tac finite_events_is_list >>
           rw[IS_SOME_EXISTS] >>
           rw[filter_events] >>
           drule toList_FINITE_LAPPEND >>
           qmatch_goalsub_abbrev_tac `LAPPEND _ [|ll2;ll3|]` >>
           disch_then(qspecl_then [`[|ll2;ll3|]`,`[ll2;ll3]`] mp_tac) >>
           impl_tac >- simp[toList_THM] >>
           simp[decode_encode_oracle_state_11] >>
           PURE_REWRITE_TAC[GSYM APPEND_ASSOC,APPEND] >>
           xsimpl
          )
       ) >>
       xvar >> xsimpl >>
       `?i1 input'. LDROP i input = SOME(i1:::input')`
             by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
                qid_spec_tac `input` >> rpt(pop_assum kall_tac) >>
                Induct_on `i` >> fs[] >>
                Cases >> rw[]) >>
       fs[] >>
       simp[LTAKE_SNOC_LNTH,LNTH_HD_LDROP] >>
       `?i2. LTAKE i input = SOME i2`
         by(qpat_x_assum `LLENGTH input = NONE` mp_tac >>
            qid_spec_tac `input` >>
            rpt(pop_assum kall_tac) >>
            Induct_on `i` >> fs[] >>
            Cases >> rw[]) >>
       simp[] >> imp_res_tac every_LTAKE >>
       qunabbrev_tac `inputbuff` >>
       fs[] >>
       drule_all filter_events_append >>
       disch_then(qspecl_then [`fromList[i1]`,`language ∘ MAP (CHR ∘ w2n)`] mp_tac) >>
       simp[GSYM LAPPEND_fromList] >> disch_then kall_tac >>
       rpt(CHANGED_TAC(simp[Once LUNFOLD] >> rw[next_filter_event])) >>
       qspecl_then [`i2`,`language o MAP (CHR o w2n)`,`REPLICATE 256 0w`,`F`] mp_tac finite_events_is_list >>
       rw[IS_SOME_EXISTS] >>
       rw[filter_events] >>
       drule toList_FINITE_LAPPEND >>
       TRY(qmatch_goalsub_abbrev_tac `LAPPEND _ [|ll2;ll3|]` >>
           disch_then(qspecl_then [`[|ll2;ll3|]`,`[ll2;ll3]`] mp_tac) >>
           impl_tac >- simp[toList_THM] >>
           simp[Abbr `ll2`,Abbr `ll3`]) >>
       TRY(qmatch_goalsub_abbrev_tac `LAPPEND _ [|ll2|]` >>
           disch_then(qspecl_then [`[|ll2|]`,`[ll2]`] mp_tac) >>
           impl_tac >- simp[toList_THM] >>
           simp[Abbr `ll2`]) >>
       simp[FILTER_APPEND,is_accept_def,bytes_of_def] >>
       disch_then kall_tac >>
       SIMP_TAC bool_ss [GSYM SNOC_APPEND,GSYM SNOC,LAST_SNOC] >>
       qmatch_goalsub_abbrev_tac `ZIP(l1,l2)` >>
       `LENGTH l1 = LENGTH l2` suffices_by(simp[MAP_ZIP]) >>
       unabbrev_all_tac >>
       imp_res_tac every_LDROP >> fs[every_thm] >>
       qmatch_goalsub_abbrev_tac `LENGTH l1 = _` >>
       `LENGTH l1 = 256` suffices_by rw[LENGTH_TAKE_EQ] >>
       unabbrev_all_tac >>
       Q.ISPEC_THEN `\x. LENGTH x = 256` (match_mp_tac o CONV_RULE(DEPTH_CONV BETA_CONV)) EVERY_LAST >>
       simp[] >>
       Q.ISPEC_THEN `i2` mp_tac finite_events_sane_length >>
       disch_then(qspecl_then [`language o MAP(CHR o w2n)`,`REPLICATE 256 0w`,`F`] mp_tac) >>
       impl_tac >- simp[] >>
       simp[] >> match_mp_tac EVERY_MONOTONIC >> rw[]
    ) >>
  rw[lprefix_lub_def] >-
    (rw[LPREFIX_APPEND] >>
     `~LFINITE(input)` by simp[LFINITE_LLENGTH] >>
     drule(CONJUNCT1 LTAKE_DROP) >>
     disch_then(qspec_then `x` (fn thm => PURE_ONCE_REWRITE_TAC [GSYM thm] >> assume_tac thm)) >>
     drule LLENGTH_NONE_LTAKE >> disch_then(qspec_then `x` strip_assume_tac) >>
     imp_res_tac every_LTAKE >>
     drule_all filter_events_append >>
     disch_then(qspecl_then [`THE(LDROP x input)`,`language o (MAP (CHR o w2n))`] mp_tac) >>
     qpat_assum `LTAKE _ _ = _` (fn thm => PURE_ONCE_REWRITE_TAC [thm]) >>
     simp[] >> disch_then kall_tac >>
     qmatch_goalsub_abbrev_tac `LAPPEND ll1 _ = LAPPEND ll2 _` >>
     `ll1 = ll2` suffices_by metis_tac[] >>
     unabbrev_all_tac >>
     imp_res_tac LTAKE_LENGTH >>
     simp[LTAKE_LAPPEND1,LTAKE_fromList] >>
     match_mp_tac(GSYM to_fromList) >>
     rw[LFINITE_toList_SOME,filter_events] >>
     MATCH_ACCEPT_TAC finite_events_is_list) >>
  fs[PULL_EXISTS] >>
  qmatch_goalsub_abbrev_tac `LPREFIX ll ub` >>
  `ll = ub` suffices_by simp[] >>
  qunabbrev_tac `ll` >>
  fs[filter_events] >>
  rw[LTAKE_EQ] >>
  first_x_assum(qspec_then `2*n` assume_tac) >>
  fs[LPREFIX_APPEND] >>
  qspecl_then [`THE(LTAKE (2*n) input)`,`language o MAP (CHR o w2n)`
               ,`REPLICATE 256 0w`,`F`] strip_assume_tac finite_events_is_list2 >>
  fs[] >>
  drule_then(qspec_then `2*n` strip_assume_tac) LLENGTH_NONE_LTAKE >>
  drule_then (strip_assume_tac o GSYM) LTAKE_LENGTH >>
  fs[] >>
  `~LFINITE input` by fs[LFINITE_LLENGTH] >>
  drule_then(qspec_then `2 * n` mp_tac) (CONJUNCT1 LTAKE_DROP) >>
  disch_then(fn thm => PURE_ONCE_REWRITE_TAC [GSYM thm] >> assume_tac thm) >>
  imp_res_tac every_LTAKE >>
  drule filter_events_append >> disch_then drule >>
  qpat_assum `LTAKE _ _ = _` (fn thm => PURE_ONCE_REWRITE_TAC[thm]) >>
  simp[filter_events] >>
  disch_then kall_tac >>
  qmatch_asmsub_abbrev_tac `toList lll` >>
  `LFINITE lll` by(Q.ISPEC_THEN `lll` mp_tac (GEN_ALL LFINITE_toList_SOME) >> simp[]) >>
  `fromList l = LUNFOLD (next_filter_event (language ∘ MAP (CHR ∘ w2n)))
              (<|input := fromList l'|>,REPLICATE 256 0w,F)`
    by(drule to_fromList >> unabbrev_all_tac >> simp[]) >>
  `IS_SOME(LTAKE n lll)` suffices_by fs[IS_SOME_EXISTS,Abbr`lll`,LTAKE_LAPPEND1] >>
  unabbrev_all_tac >>
  pop_assum(assume_tac o GSYM) >>
  fs[] >>
  `n <= LENGTH l` by simp[] >>
  Q.ISPEC_THEN `l` assume_tac LTAKE_fromList >>
  drule_all LTAKE_TAKE_LESS >>
  simp[]
QED

Theorem LTAKE_LLENGTH_SOME2:
  LLENGTH ll = SOME n
  ==> ?l. ll = fromList l /\ LENGTH l = n
Proof
  strip_tac >> imp_res_tac LTAKE_LLENGTH_SOME >>
  qexists_tac `l` >>
  imp_res_tac LTAKE_LENGTH >> simp[] >>
  `LFINITE ll` by simp[LFINITE_LLENGTH] >>
  drule to_fromList >>
  disch_then(fn thm => PURE_ONCE_REWRITE_TAC[GSYM thm]) >>
  simp[]
QED

val STRING_TYPE_explode = Q.store_thm("STRING_TYPE_explode",
  `!s u. STRING_TYPE s u ==> u = Litv(StrLit(explode s))`,
  Cases >> rw[STRING_TYPE_def]);

Theorem forward_matching_lines_ffidiv_spec:
  !input rv.
    limited_parts ["accept_call";"emit_string"] p /\
    LLENGTH input = SOME n /\
    every (null_terminated_w) input /\
    every ($>= 256 o LENGTH) input
    ==>
    app (p:'ffi ffi_proj) ^(fetch_v "forward_matching_lines" st) [rv]
      (seL4_IO input [] * W8ARRAY dummyarr_loc [])
      (POSTf s. λconf (bytes:word8 list).
         &(s = "accept_call" /\ conf = []) *
         seL4_IO [||] (THE(toList(filter_events (language o MAP (CHR o w2n)) <|input:=input|>))) *
         W8ARRAY dummyarr_loc [] *
         SEP_EXISTS loc init. W8ARRAY loc init
      )
Proof
  xcf "forward_matching_lines" st >>
  xlet_auto >- xsimpl >>
  xlet_auto >- xsimpl >>
  unfold_cf_app >>
  imp_res_tac LTAKE_LLENGTH_SOME2 >> rveq >>
  simp[filter_events] >>
  qmatch_goalsub_abbrev_tac `W8ARRAY _ init` >>
  `LENGTH init = 256` by(qunabbrev_tac `init` >> simp[]) >>
  pop_assum mp_tac >> pop_assum kall_tac >>
  qmatch_goalsub_abbrev_tac `seL4_IO _ events` >>
  qmatch_goalsub_abbrev_tac `seL4_IO [||] newevents` >>
  `newevents = events ++ newevents` by(unabbrev_all_tac >> simp[]) >>
  pop_assum(fn thm => PURE_ONCE_REWRITE_TAC [thm]) >>
  qunabbrev_tac `newevents` >>
  pop_assum kall_tac >>
  rpt(pop_assum mp_tac) >>
  SPEC_ALL_TAC >>
  Induct_on `l` >-
    (rw[] >>
     xcf "forward_loop" st >>
     xlet `(POSTf s. (λconf bytes.
             &(s = "accept_call" ∧ conf = []) *
                seL4_IO [||] events * W8ARRAY v' init *
                 W8ARRAY dummyarr_loc []))` >-
       (simp[cf_ffi_def] >>
        match_mp_tac local_elim >>
        hnf >>
        simp[app_ffi_def] >> reduce_tac >>
        reverse conj_tac >- (simp[SEP_IMPPOSTe_POSTf_left,SEP_IMPPOSTd_POSTf_left]) >>
        xsimpl >>
        simp[seL4_IO_def] >>
        qmatch_goalsub_abbrev_tac `one(FFI_part s u ns events)` >>
        MAP_EVERY qexists_tac [`W8ARRAY dummyarr_loc []`,`s`,`u`,`ns`,`events`] >>
        unabbrev_all_tac >> xsimpl >>
        simp[filter_cf_oracle,decode_encode_oracle_state_11,filter_oracle] >>
        xsimpl) >>
     simp[SEP_IMPPOSTv_inv_def,SEP_IMPPOSTd_POSTf_left,SEP_IMPPOSTe_POSTf_left] >>
     rw[SEP_IMPPOSTf_def] >>
     simp[Once LUNFOLD] >> simp[next_filter_event,toList_THM] >>
     xsimpl >> metis_tac[SEP_IMP_REFL]) >>
  rw[] >>
  xcf "forward_loop" st >>
  qabbrev_tac `newinit = TAKE 256 h ++ DROP (LENGTH h) init` >>
  xlet `POSTv v. &UNIT_TYPE () v *
        W8ARRAY v' newinit * W8ARRAY dummyarr_loc [] *
        seL4_IO (fromList l) (SNOC (IO_event "accept_call" [] (ZIP(init,newinit))) events)` >-
    (xffi >> xsimpl >>
     simp[seL4_IO_def,Abbr `newinit`] >>
     qmatch_goalsub_abbrev_tac `one(FFI_part s u ns events)` >>
     MAP_EVERY qexists_tac [`W8ARRAY dummyarr_loc []`,`s`,`u`,`ns`,`events`] >>
     unabbrev_all_tac >> simp[] >> xsimpl >>
     simp[filter_cf_oracle,decode_encode_oracle_state_11,filter_oracle] >>
     xsimpl >>
     simp[SNOC_APPEND,SEP_IMP_REFL]) >>
  xlet `(POSTv v. &UNIT_TYPE () v * W8ARRAY dummyarr_loc [] *
         W8ARRAY v' newinit *
         seL4_IO (fromList l) (events ++ THE
                 (toList
                    (LUNFOLD
                       (next_filter_event (language ∘ MAP (CHR ∘ w2n)))
                       (<|input := [|h|]|>,init,F)))))` >-
    (xlet_auto >- (xsimpl >> simp[LENGTH_TAKE_EQ]) >>
     xlet_auto >- xsimpl >>
     xlet_auto >- xsimpl >>
     reverse xif >-
       (xcon >> xsimpl >>
        fs[match_string_eq] >>
        simp[Once LUNFOLD,next_filter_event] >>
        simp[Once LUNFOLD,next_filter_event] >>
        qunabbrev_tac `newinit` >>
        fs[null_terminated_w_thm,implode_def] >>
        rfs[null_terminated_cut_APPEND,TAKE_APPEND,TAKE_LENGTH_TOO_LONG,TAKE_TAKE_MIN] >>
        rfs[GSYM strlit_STRCAT,null_terminated_cut_APPEND] >>
        fs[cut_at_null_w_thm,MAP_MAP_o,CHR_w2n_n2w_ORD,implode_def] >>
        fs[DROP_APPEND1,DROP_LENGTH_TOO_LONG] >>
        simp[SNOC_APPEND,toList_THM] >> xsimpl >>
        PURE_REWRITE_TAC[GSYM APPEND_ASSOC,APPEND,SNOC_APPEND] >>
        xsimpl) >>
     xffi >> xsimpl >>
     simp[seL4_IO_def] >>
     imp_res_tac STRING_TYPE_explode >>
     rveq >> fs[] >>
     simp[cut_at_null_thm] >>
     qmatch_goalsub_abbrev_tac `one(FFI_part s u ns newevents)` >>
     MAP_EVERY qexists_tac [`cut_at_null_w(TAKE 256 newinit)`,`W8ARRAY v' newinit`,`s`,`u`,`ns`,`newevents`] >>
     unabbrev_all_tac >> simp[] >> xsimpl >>
     simp[filter_cf_oracle,decode_encode_oracle_state_11,filter_oracle] >>
     xsimpl >>
     ntac 2 (simp[Once LUNFOLD,next_filter_event]) >>
     fs[match_string_eq] >>
     fs[cut_at_null_w_thm,MAP_MAP_o,CHR_w2n_n2w_ORD,implode_def] >>
     fs[null_terminated_w_thm,implode_def] >>
     rfs[null_terminated_cut_APPEND,TAKE_APPEND,TAKE_LENGTH_TOO_LONG] >>
     rfs[GSYM strlit_STRCAT,null_terminated_cut_APPEND] >>
     simp[Once LUNFOLD,next_filter_event,toList_THM] >>
     PURE_REWRITE_TAC[GSYM APPEND_ASSOC,APPEND,SNOC_APPEND] >>
     xsimpl) >>
  qmatch_goalsub_abbrev_tac `seL4_IO _ oldevents` >>
  qmatch_goalsub_abbrev_tac `seL4_IO [||] newevents` >>
  `newevents = oldevents ++ THE(toList(LUNFOLD(next_filter_event (language o MAP(CHR o w2n)))
                                              (<|input := fromList l|>,newinit,F)))`
    by(unabbrev_all_tac >>
       simp[] >>
       simp[SimpL``$=``,Once LUNFOLD,next_filter_event] >>
       CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV[LUNFOLD]))) >>
       simp[next_filter_event] >>
       reverse(Cases_on `language (MAP (CHR ∘ w2n) (cut_at_null_w h))`) >-
         (CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV[LUNFOLD]))) >>
          simp[next_filter_event] >>
       simp[toList_THM] >>
       qmatch_goalsub_abbrev_tac `LUNFOLD (next_filter_event f)
                                           (<|input := fromList i1|>,innit,b)` >>
       qspecl_then [`i1`,`f`,`innit`,`b`] mp_tac finite_events_is_list >>
       rw[IS_SOME_EXISTS] >> rw[]) >>
       CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV[LUNFOLD]))) >>
       simp[SimpL``$=``,Once LUNFOLD,next_filter_event] >>
       CONV_TAC(RHS_CONV(RATOR_CONV(PURE_ONCE_REWRITE_CONV[LUNFOLD]))) >>
       simp[next_filter_event] >>
       simp[toList_THM] >>
       qmatch_goalsub_abbrev_tac `LUNFOLD (next_filter_event f)
                                           (<|input := fromList i1|>,innit,b)` >>
       qspecl_then [`i1`,`f`,`innit`,`b`] mp_tac finite_events_is_list >>
       rw[IS_SOME_EXISTS] >> rw[]) >>
  simp[] >>
  fs[LLENGTH_fromList] >>
  `LENGTH newinit = 256` by(fs[Abbr `newinit`,LENGTH_TAKE_EQ]) >>
  xapp >> xsimpl >>
  CONV_TAC SWAP_EXISTS_CONV >> qexists_tac `oldevents` >>
  xsimpl >>
  asm_exists_tac >> simp[] >>
  rw[] >> rename1 `W8ARRAY a b` >>
  MAP_EVERY qexists_tac [`a`,`b`] >>
  xsimpl
QED

val seL4_proj1_def = Define `
  seL4_proj1 = (λffi.
    FEMPTY |++ (mk_proj1 (encode_oracle_state,decode_oracle_state,
                          [("accept_call", filter_oracle "accept_call");
                           ("emit_string", filter_oracle "emit_string")]) ffi))`;

val seL4_proj2 = Define `seL4_proj2 =
  [(["accept_call";"emit_string"],filter_cf_oracle)]`

val filter_ffi_state_def = Define `filter_ffi input =
  <|oracle:=filter_oracle; ffi_state := input; io_events := []|>`;

Theorem limited_parts_proj:
  limited_parts ["accept_call";"emit_string"] (seL4_proj1,seL4_proj2)
Proof
  rw[limited_parts_def,seL4_proj2]
QED

Theorem parts_ok_filter:
  parts_ok (filter_ffi <|input:= input|>) (seL4_proj1,seL4_proj2)
Proof
  rw[cfStoreTheory.parts_ok_def,seL4_proj1_def,seL4_proj2,filter_ffi_state_def,
     cfStoreTheory.ffi_has_index_in_def,mk_proj1_def,FLOOKUP_UPDATE,
     FUPDATE_LIST_THM,FAPPLY_FUPDATE_THM,decode_encode_oracle_state_11,
     filter_oracle,filter_cf_oracle]
  >- metis_tac[NOT_SOME_NONE]
  >> rw[] >> fs[] >> rveq >> fs[]
  >> every_case_tac >> fs[] >> rveq >> fs[LENGTH_TAKE_EQ]
  >> rw[fmap_eq_flookup,FLOOKUP_UPDATE]
QED

Theorem forward_matching_lines_semantics:
 LLENGTH input = NONE /\ every null_terminated_w input /\
 every ($>= 256 ∘ LENGTH) input
 ==>
 semantics_prog (^(get_state st) with ffi := (filter_ffi <|input:=input|>)) ^(get_env st)
  [Dlet unknown_loc (Pcon NONE [])
           (App Opapp [Var (Short "forward_matching_lines"); Con NONE []])]
  (Diverge (filter_events (language o MAP (CHR o w2n)) <|input:=input|>))
Proof
  rpt strip_tac >>
  `nsLookup ^(get_env st).v (Short "forward_matching_lines") = SOME forward_matching_lines_v`
    by(unabbrev_all_tac >> EVAL_TAC) >>
  assume_tac limited_parts_proj >>
  drule_all forward_matching_lines_div_spec >>
  disch_then(qspec_then `ARB` mp_tac) >>
  disch_then(qspec_then `Conv NONE []` mp_tac) >>
  simp[app_def,app_basic_def] >>
  CONV_TAC(RATOR_CONV(RAND_CONV(RESORT_FORALL_CONV rev))) >>
  qmatch_goalsub_abbrev_tac `semantics_prog st` >>
  disch_then(qspec_then `st` mp_tac) >>
  unabbrev_all_tac >>
  simp[cfStoreTheory.st2heap_def,cfStoreTheory.store2heap_append,cfStoreTheory.ffi2heap_def,
       fetch "-" "filterProg_st_def",parts_ok_filter] >>
  qmatch_goalsub_abbrev_tac `FFI_split INSERT FFIset` >>
  `FFIset = {FFI_part (encode_oracle_state <|input:= input|>) filter_cf_oracle
                      ["accept_call"; "emit_string"] []}`
    by(unabbrev_all_tac >> rw[FUN_EQ_THM,EQ_IMP_THM] >-
        (pairarg_tac >> fs[seL4_proj2] >> rveq >>
         first_x_assum(qspec_then `"accept_call"` mp_tac) >>
         simp[seL4_proj1_def,mk_proj1_def] >>
         simp[FLOOKUP_UPDATE,FUPDATE_LIST_THM,filter_ffi_state_def]) >>
       Q.REFINE_EXISTS_TAC `(s,u,ns,ts)` >>
       rw[seL4_proj2,filter_ffi_state_def,seL4_proj1_def,mk_proj1_def,
          FLOOKUP_UPDATE,FUPDATE_LIST_THM,filter_ffi_state_def]) >>
  simp[] >> pop_assum kall_tac >> unabbrev_all_tac >>
  qmatch_goalsub_abbrev_tac `(Mem dummyarr _ INSERT junk) ∪ {_;FFIpart}` >>
  disch_then(qspecl_then [`FFI_split INSERT junk`,
                          `{Mem dummyarr (W8array []);FFIpart}`]
                         mp_tac) >>
  impl_tac >-
    (rw[SPLIT_def] >> unabbrev_all_tac >> simp[] >-
       (rw[FUN_EQ_THM,EQ_IMP_THM] >> rw[]) >-
       (simp[cfStoreTheory.FFI_part_NOT_IN_store2heap_aux,
             cfStoreTheory.store2heap_def]) >-
       (spose_not_then strip_assume_tac >>
        drule cfStoreTheory.store2heap_IN_LENGTH >> simp[])
    ) >>
  impl_tac >- (simp[STAR_def,seL4_IO_def,SPLIT_def,dummyarr_loc_def,
                    W8ARRAY_def] >>
               MAP_EVERY qexists_tac [`{FFIpart}`,`{Mem dummyarr (W8array [])}`] >>
               conj_tac >- (simp[FUN_EQ_THM,Abbr `FFIpart`] >> metis_tac[]) >>
               conj_tac >- simp[one_def] >>
               simp[SEP_EXISTS,cond_def,cell_def,one_def]) >>
  strip_tac >>
  Cases_on `r` >> fs[cond_def] >> rveq >>
  fs[evaluate_to_heap_def,semanticsTheory.semantics_prog_def] >>
  strip_tac >-
    (simp[semanticsTheory.evaluate_prog_with_clock_def,
          terminationTheory.evaluate_decs_def,
          astTheory.pat_bindings_def] >>
     simp[terminationTheory.evaluate_def] >>
     simp[semanticPrimitivesTheory.do_con_check_def,semanticPrimitivesTheory.build_conv_def] >>
     rw[evaluateTheory.dec_clock_def] >>
     fs[evaluate_ck_def] >>
     first_x_assum(qspec_then `k - 1` strip_assume_tac) >>
     fs[]) >>
  match_mp_tac(GEN_ALL lprefix_lub_subset) >>
  asm_exists_tac >> simp[] >> conj_tac >-
    (rw[IMAGE_DEF,SUBSET_DEF] >>
     qexists_tac `SUC ck` >>
     simp[semanticsTheory.evaluate_prog_with_clock_def,
          terminationTheory.evaluate_decs_def,
          astTheory.pat_bindings_def
         ] >>
     simp[terminationTheory.evaluate_def] >>
     simp[semanticPrimitivesTheory.do_con_check_def,semanticPrimitivesTheory.build_conv_def] >>
     rw[evaluateTheory.dec_clock_def] >>
     fs[evaluate_ck_def] >>
     rpt(PURE_TOP_CASE_TAC >> rveq >> fs[])) >>
  rw[PULL_EXISTS] >>
  simp[LPREFIX_fromList_fromList] >>
  simp[semanticsTheory.evaluate_prog_with_clock_def,
       terminationTheory.evaluate_decs_def,
       astTheory.pat_bindings_def
      ] >>
  simp[terminationTheory.evaluate_def] >>
  simp[semanticPrimitivesTheory.do_con_check_def,semanticPrimitivesTheory.build_conv_def] >>
  rw[evaluateTheory.dec_clock_def] >>
  fs[evaluate_ck_def] >>
  first_x_assum(qspec_then `k - 1` strip_assume_tac) >>
  fs[] >-
    (qexists_tac `ARB` >>
     qmatch_goalsub_abbrev_tac `evaluate st` >>
     Q.ISPEC_THEN `st` mp_tac
       (CONJUNCT1 evaluatePropsTheory.evaluate_io_events_mono
        |> SIMP_RULE std_ss [evaluatePropsTheory.io_events_mono_def]) >>
     simp[Abbr `st`]) >>
  qexists_tac `k - 1` >>
  every_case_tac >> fs[]
QED

Theorem forward_matching_lines_ffidiv_semantics:
 LLENGTH input = SOME n /\ every null_terminated_w input /\
 every ($>= 256 ∘ LENGTH) input
 ==>
 ?bytes.
 semantics_prog (^(get_state st) with ffi := (filter_ffi <|input:=input|>)) ^(get_env st)
  [Dlet unknown_loc (Pcon NONE [])
           (App Opapp [Var (Short "forward_matching_lines"); Con NONE []])]
  (Terminate (FFI_outcome(Final_event "accept_call" [] bytes FFI_diverged))
             (THE(toList(filter_events (language o MAP (CHR o w2n)) <|input:=input|>))))
Proof
  rpt strip_tac >>
  `nsLookup ^(get_env st).v (Short "forward_matching_lines") = SOME forward_matching_lines_v`
    by(unabbrev_all_tac >> EVAL_TAC) >>
  assume_tac limited_parts_proj >>
  drule_all forward_matching_lines_ffidiv_spec >>
  disch_then(qspec_then `Conv NONE []` mp_tac) >>
  simp[app_def,app_basic_def] >>
  CONV_TAC(RATOR_CONV(RAND_CONV(RESORT_FORALL_CONV rev))) >>
  qmatch_goalsub_abbrev_tac `semantics_prog st` >>
  disch_then(qspec_then `st` mp_tac) >>
  unabbrev_all_tac >>
  simp[cfStoreTheory.st2heap_def,cfStoreTheory.store2heap_append,cfStoreTheory.ffi2heap_def,
       fetch "-" "filterProg_st_def",parts_ok_filter] >>
  qmatch_goalsub_abbrev_tac `FFI_split INSERT FFIset` >>
  `FFIset = {FFI_part (encode_oracle_state <|input:= input|>) filter_cf_oracle
                      ["accept_call"; "emit_string"] []}`
    by(unabbrev_all_tac >> rw[FUN_EQ_THM,EQ_IMP_THM] >-
        (pairarg_tac >> fs[seL4_proj2] >> rveq >>
         first_x_assum(qspec_then `"accept_call"` mp_tac) >>
         simp[seL4_proj1_def,mk_proj1_def] >>
         simp[FLOOKUP_UPDATE,FUPDATE_LIST_THM,filter_ffi_state_def]) >>
       Q.REFINE_EXISTS_TAC `(s,u,ns,ts)` >>
       rw[seL4_proj2,filter_ffi_state_def,seL4_proj1_def,mk_proj1_def,
          FLOOKUP_UPDATE,FUPDATE_LIST_THM,filter_ffi_state_def]) >>
  simp[] >> pop_assum kall_tac >> unabbrev_all_tac >>
  qmatch_goalsub_abbrev_tac `(Mem dummyarr _ INSERT junk) ∪ {_;FFIpart}` >>
  disch_then(qspecl_then [`FFI_split INSERT junk`,
                          `{Mem dummyarr (W8array []);FFIpart}`]
                         mp_tac) >>
  impl_tac >-
    (rw[SPLIT_def] >> unabbrev_all_tac >> simp[] >-
       (rw[FUN_EQ_THM,EQ_IMP_THM] >> rw[]) >-
       (simp[cfStoreTheory.FFI_part_NOT_IN_store2heap_aux,
             cfStoreTheory.store2heap_def]) >-
       (spose_not_then strip_assume_tac >>
        drule cfStoreTheory.store2heap_IN_LENGTH >> simp[])
    ) >>
  impl_tac >- (simp[STAR_def,seL4_IO_def,SPLIT_def,dummyarr_loc_def,
                    W8ARRAY_def] >>
               MAP_EVERY qexists_tac [`{FFIpart}`,`{Mem dummyarr (W8array [])}`] >>
               conj_tac >- (simp[FUN_EQ_THM,Abbr `FFIpart`] >> metis_tac[]) >>
               conj_tac >- simp[one_def] >>
               simp[SEP_EXISTS,cond_def,cell_def,one_def]) >>
  strip_tac >>
  Cases_on `r` >> fs[SEP_CLAUSES,SEP_F_def] >> rveq >>
  fs[STAR_def,SEP_EXISTS_THM,cond_def] >> rveq >>
  fs[SPLIT_def,SPLIT3_def,seL4_IO_def,one_def] >> rveq >>
  fs[evaluate_to_heap_def,semanticsTheory.semantics_prog_def] >>
  qmatch_asmsub_abbrev_tac `{ffipart}` >>
  `ffipart ∈ st2heap (seL4_proj1,seL4_proj2) st'`
    by(unabbrev_all_tac >> fs[]) >>
  unabbrev_all_tac >>
  drule_all limited_FFI_part_IN_st2heap_IMP >>
  strip_tac >> fs[] >>
  fs[evaluate_to_heap_def,semanticsTheory.semantics_prog_def] >>
  simp[semanticsTheory.evaluate_prog_with_clock_def,
          terminationTheory.evaluate_decs_def,
          astTheory.pat_bindings_def] >>
  simp[terminationTheory.evaluate_def] >>
  simp[semanticPrimitivesTheory.do_con_check_def,semanticPrimitivesTheory.build_conv_def] >>
  rw[evaluateTheory.dec_clock_def] >>
  CONV_TAC SWAP_EXISTS_CONV >>
  qexists_tac `SUC ck` >>
  fs[evaluate_ck_def]
QED

val event_stream_finite = Q.store_thm("event_stream_finite",
  `!st f n.
  LLENGTH st.input = SOME n /\
  every null_terminated_w st.input /\
  every ($>= 256 o LENGTH) st.input
  ==> LFINITE(filter_events f st)`,
  rw[LFINITE_toList_SOME] >>
  Cases_on `st` >> simp[filter_events] >>
  `filter_ffi l = <|input := l|>` by simp[filter_ffi_component_equality] >>
  fs[] >> metis_tac[LTAKE_LLENGTH_SOME2,finite_events_is_list]);

val is_emit_def = Define
  `is_emit (IO_event s _ _) = (s = "emit_string")`

val output_event_of_def = Define
  `output_event_of s = IO_event "emit_string" s []`

val LDROP_APPEND3 = Q.store_thm("LDROP_APPEND3",
  `LLENGTH l1 = SOME n ==> LDROP n (LAPPEND l1 l2) = SOME l2`,
  strip_tac
  >> `LDROP n l1 = SOME [||]` by(rw[LDROP_EQ_LNIL])
  >> drule LDROP_APPEND1 >> rw[]);

val exists_split = Q.store_thm("exists_split",
  `!ll. exists f ll ==> ?ll1 e ll2. ll = LAPPEND ll1 (e:::ll2) /\ every ($~ ∘ f) ll1 /\ LFINITE ll1 /\ f e`,
  ho_match_mp_tac exists_strongind >> rpt strip_tac
  >- (qexists_tac `[||]` >> simp[])
  >> Cases_on `f h`
  >- (qexists_tac `[||]` >> simp[])
  >> qexists_tac `h:::ll1`
  >> fs[]
  >> metis_tac[]);

val not_o_not = Q.prove(`$~ ∘ ($~:bool -> bool) ∘ f = f`,
  rw[FUN_EQ_THM]);

val LUNFOLD_EQ_APPEND_IMP = Q.prove(
  `LUNFOLD f e = LAPPEND ll1 ll2 /\ LFINITE ll1
   ==> ll2 = LUNFOLD f (FUNPOW (FST o THE o f) (THE(LLENGTH ll1)) e)
  `,
  rpt strip_tac
  >> imp_res_tac to_fromList
  >> qmatch_asmsub_abbrev_tac `fromList a1`
  >> pop_assum kall_tac
  >> rveq >> fs[]
  >> rpt(pop_assum mp_tac)
  >> MAP_EVERY (W(curry Q.SPEC_TAC)) [`ll1`,`ll2`,`f`,`e`,`a1`]
  >> Induct
  >- fs[]
  >> rpt strip_tac
  >> fs[]
  >> qhdtm_x_assum `LUNFOLD` (assume_tac o PURE_ONCE_REWRITE_RULE[LUNFOLD])
  >> PURE_FULL_CASE_TAC >> fs[]
  >> PURE_FULL_CASE_TAC >> fs[FUNPOW]);

val LUNFOLD_EQ_APPEND_IMP2 = Q.prove(
  `LUNFOLD f e = LAPPEND ll1 ll2 /\ LFINITE ll1
   ==> toList(ll1) = LTAKE (THE(LLENGTH ll1)) (LUNFOLD f e)
  `,
  rpt strip_tac
  >> imp_res_tac to_fromList
  >> qmatch_asmsub_abbrev_tac `fromList a1`
  >> pop_assum kall_tac
  >> rveq >> fs[]
  >> rpt(pop_assum mp_tac)
  >> MAP_EVERY (W(curry Q.SPEC_TAC)) [`ll1`,`ll2`,`f`,`e`,`a1`]
  >> Induct
  >- fs[toList]
  >> rpt strip_tac
  >> fs[toList]
  >> qhdtm_x_assum `LUNFOLD` (assume_tac o PURE_ONCE_REWRITE_RULE[LUNFOLD])
  >> PURE_FULL_CASE_TAC >> fs[]
  >> PURE_FULL_CASE_TAC >> fs[FUNPOW]
  >> metis_tac[LTAKE_LAPPEND1,LTAKE_fromList]);

val next_filter_event_invariants_lemma = Q.prove(
  `!n inl f buff newbuff ffi b.
   (case LLENGTH inl of NONE => T | SOME l => n < SUC l) /\
   EVERY ($~ ∘ f ∘ cut_at_null_w) (THE(LTAKE (n-1) inl)) /\
   LENGTH buff = 256 /\
   ¬exists ($~ ∘ $>= 256 ∘ LENGTH) inl /\
   ¬exists ($~ ∘ null_terminated_w) inl /\
   FUNPOW (FST o THE o next_filter_event f) n (<|input := inl|>,buff,F)
   = (ffi,newbuff,b) ==>
   ffi = <|input := THE(LDROP n inl)|> /\
   LENGTH newbuff = 256 /\ (b = if n = 0 then F else f(cut_at_null_w(THE(LNTH (n-1) inl)))) /\
   if n = 0 then buff = newbuff else
    cut_at_null_w(THE(LNTH (n-1) inl)) =
    cut_at_null_w newbuff`,
  Induct
  >- fs[]
  >> rpt(gen_tac ORELSE disch_then strip_assume_tac)
  >> Cases_on `inl` >> fs[FUNPOW]
  >> fs[next_filter_event]
  >> Cases_on `n`
  >- (fs[] >> rveq >> simp[LENGTH_TAKE_EQ]
      >> fs[GREATER_EQ,TAKE_LENGTH_TOO_LONG,null_terminated_cut_w_APPEND])
  >> fs[] >> rename1 `SUC n`
  >> first_x_assum match_mp_tac
  >> Cases_on `LLENGTH t` >> fs[]
  >- (rename1 `LLENGTH newinput = NONE`
      >> `~LFINITE newinput` by(CCONTR_TAC >> fs[] >> imp_res_tac LFINITE_HAS_LENGTH >> fs[])
      >> drule NOT_LFINITE_TAKE >> disch_then(qspec_then `n` strip_assume_tac)
      >> fs[]
      >> qmatch_asmsub_abbrev_tac `FUNPOW _ _(_,oldbuff,_)`
      >> qexists_tac `oldbuff` >> qunabbrev_tac `oldbuff`
      >> simp[LENGTH_TAKE_EQ] >> rfs[])
  >> rename1 `LLENGTH newinput = SOME _`
  >> `LFINITE newinput` by(simp[LFINITE_LLENGTH])
  >> drule LFINITE_TAKE >> simp[] >> disch_then(qspec_then `n` mp_tac)
  >> impl_tac >- simp[]
  >> strip_tac >> fs[]
  >> qmatch_asmsub_abbrev_tac `FUNPOW _ _(_,oldbuff,_)`
  >> qexists_tac `oldbuff` >> qunabbrev_tac `oldbuff`
  >> simp[LENGTH_TAKE_EQ] >> rfs[]);

val next_filter_event_invariants_lemma' = Q.prove(
  `!n inl f buff newbuff ffi b.
   EVERY ($~ ∘ f ∘ cut_at_null_w) (THE(LTAKE (n-1) inl)) /\
   LENGTH buff = 256 /\
   ¬exists ($~ ∘ $>= 256 ∘ LENGTH) inl /\
   ¬exists ($~ ∘ null_terminated_w) inl /\
   FUNPOW (FST o THE o next_filter_event f) n (<|input := inl|>,buff,F)
                                          = (ffi,newbuff,b) /\
   less_opt n (lift SUC (LLENGTH inl)) ==>
   ffi = <|input := THE(LDROP n inl)|> /\
   LENGTH newbuff = 256 /\ (b = if n = 0 then F else f(cut_at_null_w(THE(LNTH (n-1) inl)))) /\
   if n = 0 then buff = newbuff else
    cut_at_null_w(THE(LNTH (n-1) inl)) =
    cut_at_null_w newbuff`,
  rpt(gen_tac ORELSE disch_then strip_assume_tac)
  >> ho_match_mp_tac(GEN_ALL next_filter_event_invariants_lemma)
  >> PURE_TOP_CASE_TAC >> fs[less_opt_def] >> asm_exists_tac >> fs[]);

val less_opt_SUC = Q.prove(`!n n'. less_opt (SUC n) (lift SUC n') = less_opt n n'`,
  Cases_on `n'` >> rw[less_opt_def]);

val next_filter_event_cut_lemma = Q.prove(
  `LFINITE ll1 /\
   toList ll1 =
   LTAKE (THE (LLENGTH ll1))
         (LUNFOLD (next_filter_event f)
                  (ffi,buff,F)) /\
   LFILTER is_emit ll1 = [||] /\ LENGTH buff = 256
   ==> EVERY ($~ ∘ f ∘ cut_at_null_w) (THE(LTAKE (THE(LLENGTH ll1) - 1) ffi.input)) /\
       less_opt(THE(LLENGTH ll1)) (lift SUC (LLENGTH ffi.input))
  `,
  rpt(disch_then strip_assume_tac)
  >> imp_res_tac to_fromList
  >> qmatch_asmsub_abbrev_tac `fromList a1`
  >> pop_assum kall_tac
  >> rveq >> fs[]
  >> rpt(pop_assum mp_tac)
  >> MAP_EVERY (W(curry Q.SPEC_TAC)) [`f`,`ffi`,`buff`,`a1`]
  >> Induct
  >- (rpt strip_tac >> fs[] >> Cases_on `LLENGTH ffi.input` >> fs[less_opt_def])
  >> rpt(gen_tac ORELSE disch_then strip_assume_tac)
  >> rfs[toList,LTAKE_fromList]
  >> PURE_FULL_CASE_TAC >> fs[]
  >> fs[LTAKE_LUNFOLD]
  >> fs[next_filter_event]
  >> PURE_FULL_CASE_TAC >> fs[] >> rveq
  >> Cases_on `a1` >- (fs[] >> Cases_on `LLENGTH ffi.input` >> fs[less_opt_def] >> Cases_on `ffi.input` >> fs[])
  >> Cases_on `ffi.input` >> fs[]
  >> `~f(cut_at_null_w(THE(LHD ffi.input)))`
     by(fs[LTAKE_LUNFOLD]
        >> fs[next_filter_event]
        >> rpt(PURE_FULL_CASE_TAC >> fs[] >> rveq >> fs[is_emit_def]))
  >> rfs[] >> fs[]
  >> first_x_assum (drule o GSYM)
  >> impl_tac >- simp[LENGTH_TAKE_EQ]
  >> strip_tac
  >> fs[less_opt_SUC]
  >> Cases_on `LTAKE (LENGTH t) t'`
  >> fs[less_opt_def]);

val LTAKE_DROP' = Q.prove(`
  !n ll. less_opt n (lift SUC (LLENGTH ll))
  ==> LAPPEND (fromList(THE(LTAKE n ll))) (THE(LDROP n ll)) = ll`,
  rpt strip_tac >> reverse(Cases_on `LLENGTH ll`) >> fs[less_opt_def]
  >- (`LFINITE ll` by(CCONTR_TAC >> imp_res_tac NOT_LFINITE_NO_LENGTH >> fs[])
      >> match_mp_tac(CONJUNCT2 LTAKE_DROP) >> fs[])
  >> `~LFINITE ll` by(fs[LFINITE_LLENGTH])
  >> metis_tac[LTAKE_DROP]);

val LTAKE_IS_SOME = Q.prove(`
  !n ll. less_opt n (lift SUC (LLENGTH ll))
  ==> IS_SOME(LTAKE n ll)`,
  rpt strip_tac >> reverse(Cases_on `LLENGTH ll`) >> fs[less_opt_def]
  >- (`LFINITE ll` by(fs[LFINITE_LLENGTH])
      >> fs[IS_SOME_EXISTS] >> fs[LESS_EQ] >> drule LFINITE_TAKE >> simp[])
  >> `~LFINITE ll` by(fs[LFINITE_LLENGTH])
  >> fs[IS_SOME_EXISTS,NOT_LFINITE_TAKE]);

val LTAKE_IS_SOME' = Q.prove(`
  !n ll. less_opt n (LLENGTH ll)
  ==> IS_SOME(LTAKE n ll)`,
  rpt strip_tac >> match_mp_tac LTAKE_IS_SOME  >> reverse(Cases_on `LLENGTH ll`) >> fs[less_opt_def]);

val LFILTER_fromList = Q.prove(`
  !l. LFILTER f (fromList l) = fromList(FILTER f l)`,
  Induct >> rw[]);

val LMAP_fromList = Q.prove(
  `!l. LMAP f (fromList l) = fromList(MAP f l)`,
  Induct >> rw[]);

val FILTER_EQ_NIL' = Q.prove(
  `!l. FILTER P l = [] ⇔ EVERY ($~ o P) l`,
  metis_tac[NOT_DEF,FILTER_EQ_NIL]);

val every_LDROP = Q.prove(`
  !n ll. every P ll /\ less_opt n (lift SUC(LLENGTH ll)) ==> every P (THE(LDROP n ll))
  `,
  Induct >> rpt strip_tac >> fs[]
  >> imp_res_tac less_opt_SUC_elim >> fs[]
  >> Cases_on `ll` >> fs[less_opt_def,less_opt_SUC]);

val filter_bisim_rel_def = Define `
  filter_bisim_rel =
  λl1 l2.
   (?inl buff.
     l1 = LFILTER is_emit (LUNFOLD (next_filter_event (language o MAP (CHR o w2n))) (<|input := inl|>,buff,F)) /\
     l2 = LMAP (output_event_of o cut_at_null_w) (LFILTER (language o MAP (CHR o w2n) o cut_at_null_w) inl) /\
     LENGTH buff = 256 /\
     every ($>= 256 ∘ LENGTH) inl /\
     every null_terminated_w inl)`

val filter_bisim_rel_is_bisim = Q.store_thm("filter_bisim_rel_is_bisim",
  `∀ll1 ll2.
    filter_bisim_rel ll1 ll2 ⇒
    ll1 = [||] ∧ ll2 = [||] ∨
    ∃h t1 t2. ll1 = h:::t1 ∧ ll2 = h:::t2 ∧ filter_bisim_rel t1 t2`,
  rw[filter_bisim_rel_def]
  >> rpt strip_tac >> simp[]
  >> qmatch_goalsub_abbrev_tac `a1 /\ _ \/ _`
  >> Cases_on `a1` (* Are there incoming messages that will pass the filter? *)
  >> fs[markerTheory.Abbrev_def]
  >- ((* No incoming messages *)
      `LFILTER (language ∘ MAP (CHR ∘ w2n) ∘ cut_at_null_w) inl = [||]` suffices_by fs[]
      >> fs[LFILTER_EQ_NIL]
      >> rpt(pop_assum mp_tac)
      >> MAP_EVERY (W(curry Q.SPEC_TAC)) [`buff`,`inl`]
      >> SIMP_TAC pure_ss [AND_IMP_INTRO,LEFT_FORALL_IMP_THM]
      >> ho_match_mp_tac every_coind
      >> rpt gen_tac >> rpt(disch_then strip_assume_tac)
      >> qpat_x_assum `_ _ (LUNFOLD _ _)` (assume_tac o PURE_ONCE_REWRITE_RULE [LUNFOLD])
      >> pop_assum (assume_tac o PURE_ONCE_REWRITE_RULE [next_filter_event])
      >> fs[is_emit_def]
      >> `¬language (MAP (CHR ∘ w2n) (cut_at_null_w h))`
         by(CCONTR_TAC
            >> qpat_x_assum `_ _ (LUNFOLD _ _)` (assume_tac o PURE_ONCE_REWRITE_RULE [LUNFOLD])
            >> pop_assum (assume_tac o PURE_ONCE_REWRITE_RULE [next_filter_event])
            >> rfs[is_emit_def])
      >> fs[]
      >> PURE_ONCE_REWRITE_TAC [CONJ_SYM] >> asm_exists_tac
      >> fs[LENGTH_TAKE_EQ])
  (* Some incoming messages *)
  >> fs[LFILTER_EQ_NIL,every_def]
  >> imp_res_tac exists_split >> fs[]
  >> fs[LFILTER_APPEND]
  >> fs[GSYM LFILTER_EQ_NIL]
  >> fs[not_o_not]
  >> drule LUNFOLD_EQ_APPEND_IMP >> disch_then drule
  >> disch_then(strip_assume_tac o PURE_ONCE_REWRITE_RULE[LUNFOLD])
  >> PURE_FULL_CASE_TAC >> fs[]
  >> PURE_FULL_CASE_TAC >> fs[]
  >> rveq
  >> qmatch_asmsub_abbrev_tac `next_filter_event _ a1`
  >> Cases_on `a1`
  >> rename1 `Abbrev((_,a2) = _)`
  >> Cases_on `a2`
  >> pop_assum(assume_tac o GSYM o PURE_ONCE_REWRITE_RULE[markerTheory.Abbrev_def])
  >> qhdtm_x_assum `next_filter_event` (assume_tac o PURE_ONCE_REWRITE_RULE [next_filter_event])
  >> rfs[]
  >> rename1 `if a3 then _ else _`
  >> Cases_on `a3` >> fs[] >> rveq >> fs[is_emit_def]
  >> rename1 `FUNPOW _ _ _ = (ffi,_)`
  >> rename1 `FUNPOW _ _ _ = (_,newbuff,_)`
  >> fs[PULL_EXISTS]
  >> qexists_tac `ffi.input`
  >> qexists_tac `newbuff`
  >> qmatch_goalsub_abbrev_tac `LFILTER _ (LUNFOLD _ (ffi1,_)) = LFILTER _ (LUNFOLD _ (ffi2,_))`
  >> `ffi1 = ffi2` by(unabbrev_all_tac >> fs[fetch "-" "filter_ffi_component_equality"])
  >> unabbrev_all_tac >> fs[]
  >> imp_res_tac LUNFOLD_EQ_APPEND_IMP2
  >> drule(GEN_ALL next_filter_event_cut_lemma)
  >> disch_then drule
  >> impl_tac >- simp[]
  >> strip_tac >> fs[]
  >> FULL_SIMP_TAC bool_ss
                   [Q.prove(`!a b c d. a o b o c o d = a o (b o c) o d`,simp[FUN_EQ_THM])]
  >> drule(GEN_ALL next_filter_event_invariants_lemma')
  >> rpt(disch_then drule) >> strip_tac
  >> fs[]
  >> conj_tac
  >- (drule(GSYM LTAKE_DROP') >> disch_then(fn thm => PURE_ONCE_REWRITE_TAC[thm] >> assume_tac thm)
      >> fs[LFILTER_APPEND]
      >> `?y. LLENGTH ll1 = SOME y` by(fs[LFINITE_LLENGTH])
      >> fs[]
      >> `LFINITE(fromList(THE(LTAKE y inl)))` by(fs[LFINITE_LLENGTH])
      >> fs[LFILTER_APPEND,LMAP_APPEND]
      >> fs[LFILTER_fromList]
      >> Cases_on `y` >> fs[]
      >> fs [LTAKE_SNOC_LNTH]
      >> imp_res_tac LTAKE_IS_SOME
      >> fs[IS_SOME_EXISTS]
      >> drule LTAKE_LNTH_EL >> disch_then(qspec_then `n` assume_tac) >> fs[]
      >> fs[less_opt_SUC]
      >> imp_res_tac LTAKE_IS_SOME'
      >> fs[IS_SOME_EXISTS]
      >> fs[FILTER_APPEND,LMAP_fromList]
      >> fs[GSYM FILTER_EQ_NIL']
      >> fs[output_event_of_def]
      >> fs[FUNPOW]
      >> qmatch_goalsub_abbrev_tac `LDROP _ (LAPPEND a1 _)`
      >> `LLENGTH a1 = SOME(SUC n)` by(qunabbrev_tac `a1` >> imp_res_tac LTAKE_LENGTH >> fs[])
      >> fs[LDROP_APPEND3])
  >> fs[GSYM every_def]
  >> imp_res_tac every_LDROP >> simp[]);

val semantics_diverge_filter = Q.store_thm("semantics_diverge_filter",
  `every ($>= 256 o LENGTH) inl
   /\ every (null_terminated_w) inl
   /\ semantics_prog (^(get_state st) with ffi:=(filter_ffi <|input:=inl|>))
                     ^(get_env st) [^maincall] (Diverge events)
   ==> LFILTER is_emit events = LMAP (output_event_of o cut_at_null_w) (LFILTER (language o MAP (CHR o w2n) o cut_at_null_w) inl)`,
  rpt strip_tac
  >> `LLENGTH inl = NONE`
      by(CCONTR_TAC >> fs[GSYM quantHeuristicsTheory.IS_SOME_EQ_NOT_NONE,IS_SOME_EXISTS]
         >> metis_tac[forward_matching_lines_ffidiv_semantics,ffiTheory.behaviour_distinct,
                      semanticsPropsTheory.semantics_prog_deterministic])
  >> imp_res_tac(GEN_ALL forward_matching_lines_semantics)
  >> first_x_assum(qspec_then `ffi` assume_tac)
  >> dxrule semanticsPropsTheory.semantics_prog_deterministic
  >> disch_then dxrule >> simp[]
  >> strip_tac >> rveq
  >> simp[filter_events]
  >> PURE_ONCE_REWRITE_TAC[LLIST_BISIMULATION0]
  >> qexists_tac `filter_bisim_rel`
  >> conj_tac
  >- (* The llists are in the candidate relation *)
    (rw[filter_bisim_rel_def] >> MAP_EVERY qexists_tac [`inl`,`REPLICATE 256 0w`] >> rw[] >> EVAL_TAC)
  (* The candidate relation is closed under destruction *)
  >> ACCEPT_TAC filter_bisim_rel_is_bisim);

val semantics_finite_filter = Q.store_thm("semantics_finite_filter",
  `every ($>= 256 o LENGTH) inl
   /\ every (null_terminated_w) inl
   /\ semantics_prog (^(get_state st) with ffi:=(filter_ffi <|input:=inl|>))
                     ^(get_env st) [^maincall] (Terminate outcome events)
   ==> LFILTER is_emit (fromList events) = LMAP (output_event_of o cut_at_null_w) (LFILTER (language o MAP (CHR o w2n) o cut_at_null_w) inl)`,
  rpt strip_tac
  >> `?n. LLENGTH inl = SOME n`
      by(simp[GSYM IS_SOME_EXISTS] >> CCONTR_TAC
         >> fs[]
         >> metis_tac[forward_matching_lines_semantics,ffiTheory.behaviour_distinct,
                      semanticsPropsTheory.semantics_prog_deterministic])
  >> drule forward_matching_lines_ffidiv_semantics >> rpt(disch_then drule) >> strip_tac
  >> dxrule(GEN_ALL semanticsPropsTheory.semantics_prog_deterministic)
  >> disch_then dxrule >> simp[]
  >> strip_tac >> rveq
  >> simp[filter_events]
  >> PURE_ONCE_REWRITE_TAC[LLIST_BISIMULATION0]
  >> qexists_tac `filter_bisim_rel`
  >> conj_tac
  >- (* The llists are in the candidate relation *)
  (rw[filter_bisim_rel_def] >> MAP_EVERY qexists_tac [`inl`,`REPLICATE 256 0w`] >> rw[]
   >> qmatch_goalsub_abbrev_tac `toList a1`
   >> `LFINITE a1`
       by (qunabbrev_tac `a1`
           >> match_mp_tac (PURE_ONCE_REWRITE_RULE [filter_events] event_stream_finite)
           >> EVAL_TAC >> fs[every_def])
   >> simp[to_fromList] >> qunabbrev_tac `a1` >> EVAL_TAC)
  (* The candidate relation is closed under destruction *)
  >> ACCEPT_TAC filter_bisim_rel_is_bisim);

(* S-expr generation handled by CMake build system
val _ = astToSexprLib.write_ast_to_file "../program.sexp" prog;
*)

val _ = export_theory ();
